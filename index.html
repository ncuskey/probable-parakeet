<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="manifest" href="manifest.json" />
  <title>Voronoi Heightmap Playground</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji"; }
    body { margin: 16px; line-height: 1.45; }
    svg { background-color: #5E4FA2; display: block; border-radius: 8px; }
    .mapCell { stroke: none; stroke-width: 0; }
    label { margin-right: 6px; }
    input[type="range"] { width: 280px; vertical-align: middle; }
    output { display: inline-block; min-width: 48px; text-align: right; margin-left: 8px; }
    .controls { margin-top: 12px; }
    button { margin-right: 8px; }
    details.tests { margin-top: 14px; }
    .pass { color: #0a0; }
    .fail { color: #b00; }
    .row { margin: 6px 0; }
    /* Coastline styling */
      .coast { fill: none; stroke: #111; stroke-width: 0.6px; stroke-linejoin: round; vector-effect: non-scaling-stroke; }
    .rivers { stroke: #4D83AE; stroke-linecap: round; stroke-linejoin: round; vector-effect: non-scaling-stroke; }
    .riversShade { stroke: rgba(0,0,0,0.35); stroke-linecap: round; stroke-linejoin: round; vector-effect: non-scaling-stroke; }
    
    /* Route styling */
    #routes .roads { stroke: #6b4e16; stroke-width: 1.4px; fill: none; stroke-linecap: round; }
#routes .trails { stroke: #9b7b3a; stroke-width: 1.0px; fill: none; stroke-dasharray: 3 3; stroke-linecap: round; }
#routes .searoutes { stroke: #ff0000; stroke-width: 5px; fill: none; stroke-dasharray: 6 4; opacity: 1.0; z-index: 1000; }
#routes .primary-road { stroke: #8B4513; stroke-width: 3px; fill: none; stroke-linecap: round; stroke-linejoin: round; }
    /* ensure export-friendly */
    #routes path { vector-effect: non-scaling-stroke; }

    /* Progress overlay styling */
    .progress-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      backdrop-filter: blur(2px);
    }

    .progress-content {
      background: rgba(255, 255, 255, 0.95);
      padding: 40px 50px;
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      text-align: center;
      min-width: 400px;
      border: 2px solid #4CAF50;
    }

    .progress-title {
      font-size: 20px;
      font-weight: bold;
      margin-bottom: 25px;
      color: #333;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .progress-bar {
      width: 100%;
      height: 12px;
      background: #e0e0e0;
      border-radius: 6px;
      overflow: hidden;
      margin-bottom: 20px;
      border: 1px solid #ccc;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #4CAF50, #45a049);
      width: 0%;
      transition: width 0.5s ease;
      border-radius: 6px;
      box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
    }

    .progress-text {
      font-size: 14px;
      color: #666;
      margin-bottom: 10px;
    }

    .progress-detail {
      font-size: 12px;
      color: #999;
      font-style: italic;
    }

    /* Add pulsing animation to make progress more visible */
    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.7; }
      100% { opacity: 1; }
    }

    /* Zoom and pan touch handling */
    #map { touch-action: none; cursor: grab; }
    #map:active { cursor: grabbing; }

    .progress-overlay {
      animation: pulse 2s ease-in-out infinite;
    }

    /* Mobile-first adjustments */
    @media (max-width: 768px) {
      body { margin: 8px; }
      #map { height: 60vh; }                 /* keep the map big enough to pinch/drag */
      .controls { position: sticky; bottom: 0; background: #fff; padding: 8px; border-top: 1px solid #ddd; }
      input[type="range"] { width: 100%; }    /* sliders fit narrow screens */
      #routes .searoutes { stroke-width: 2px; }  /* thinner lines on phones */
    }

    /* Finger-friendly tap targets on coarse pointers (phones/tablets) */
    @media (pointer: coarse) {
      button, .primary-btn, .settings-btn { min-height: 44px; font-size: 16px; }
      label { font-size: 16px; }
    }

    /* Safe-area insets for the modal (iOS) */
    @supports(padding: env(safe-area-inset-top)) {
      .modal-content { 
        margin: calc(8px + env(safe-area-inset-top)) auto calc(8px + env(safe-area-inset-bottom));
      }
    }

    /* Modal styles */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
    }

    .modal-content {
      background-color: #fefefe;
      margin: 5% auto;
      padding: 0;
      border: 1px solid #888;
      border-radius: 8px;
      width: 80%;
      max-width: 600px;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px 20px;
      border-bottom: 1px solid #ddd;
      background-color: #f8f9fa;
      border-radius: 8px 8px 0 0;
    }

    .modal-header h2 {
      margin: 0;
      color: #333;
      font-size: 1.5em;
    }

    .close {
      color: #aaa;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
      line-height: 1;
    }

    .close:hover {
      color: #000;
    }

    .modal-body {
      padding: 20px;
    }

    .settings-tabs {
      display: flex;
      border-bottom: 1px solid #ddd;
      margin-bottom: 20px;
    }

    .tab-btn {
      background: none;
      border: none;
      padding: 10px 20px;
      cursor: pointer;
      border-bottom: 2px solid transparent;
      font-size: 14px;
      color: #666;
    }

    .tab-btn:hover {
      background-color: #f0f0f0;
    }

    .tab-btn.active {
      color: #333;
      border-bottom-color: #007bff;
      font-weight: bold;
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    .hint {
      opacity: 0.7;
      font-size: 0.9em;
      color: #666;
      margin-left: 8px;
    }

    .primary-btn {
      background-color: #007bff;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
    }

    .primary-btn:hover {
      background-color: #0056b3;
    }

    .settings-btn {
      background-color: #6c757d;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
    }

    .settings-btn:hover {
      background-color: #545b62;
    }
  </style>
</head>
<body>
  <div style="display: flex; gap: 20px; align-items: flex-start;">
    <div id="mapContainer" style="flex: 1; min-width: 0; position: relative;">
      <svg id="map" width="1280" height="560" viewBox="0 0 1280 560" role="img" aria-label="Voronoi heightmap canvas" style="width: 100%; height: auto; max-width: none;"></svg>
      
      <!-- Progress Overlay -->
      <div id="progressOverlay" class="progress-overlay">
        <div class="progress-content">
          <div class="progress-title">Generating Map...</div>
          <div class="progress-bar">
            <div id="progressFill" class="progress-fill"></div>
          </div>
          <div id="progressText" class="progress-text">Initializing...</div>
          <div id="progressDetail" class="progress-detail"></div>
        </div>
      </div>
    </div>
    
    <div id="biomeLegend" style="display: none; min-width: 200px; background: rgba(255,255,255,0.9); padding: 10px; border-radius: 8px; border: 1px solid #ccc;">
      <h4 style="margin: 0 0 10px 0; font-size: 14px;">Biome Legend</h4>
      <div id="legendItems" style="font-size: 12px; line-height: 1.4;"></div>
    </div>
  </div>

  <div class="controls">
    <div class="row">
      <button onclick="generate()" class="primary-btn">Generate Map</button>
      <button onclick="toggleSettings()" class="settings-btn">⚙️ Settings</button>
    </div>

    <div class="row">
      <button onclick="saveSVG(document.querySelector('svg'), 'voronoi_map.svg')">Export SVG</button>
      <button onclick="savePNG(document.querySelector('svg'), 1280, 560, 'voronoi_map.png')">Export PNG</button>
    </div>
  </div>

  <!-- Settings Modal -->
  <div id="settingsModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Map Settings</h2>
        <span class="close" onclick="toggleSettings()">&times;</span>
      </div>
      
      <div class="modal-body">
        <div class="settings-tabs">
          <button class="tab-btn active" onclick="showTab('terrain')">Terrain</button>
          <button class="tab-btn" onclick="showTab('climate')">Climate</button>
          <button class="tab-btn" onclick="showTab('settlements')">Settlements</button>
          <button class="tab-btn" onclick="showTab('routes')">Routes</button>
        </div>

        <!-- Terrain Tab -->
        <div id="terrain-tab" class="tab-content active">
    <div class="row">
      <label>Graph Size:</label>
                    <input id="sizeInput" value="10000" type="range" min="100" max="25000" step="500" oninput="sizeOutput.value = sizeInput.valueAsNumber">
      <output id="sizeOutput">10000</output>
    </div>

    <div class="row">
      <label>Max High:</label>
      <input id="highInput" value="0.9" type="range" min="0.1" max="1" step="0.01" oninput="highOutput.value = highInput.valueAsNumber">
      <output id="highOutput">0.9</output>
    </div>

    <div class="row">
      <label>Radius:</label>
      <input id="radiusInput" value="0.9" type="range" min="0.5" max="0.999" step="0.001" oninput="radiusOutput.value = radiusInput.valueAsNumber">
            <output id="radiusOutput">0.9</output>
            <span class="hint">(change gently!)</span>
    </div>

    <div class="row">
      <label>Sharpness:</label>
      <input id="sharpnessInput" value="0.2" type="range" min="0" max="0.5" step="0.1" oninput="sharpnessOutput.value = sharpnessInput.valueAsNumber">
      <output id="sharpnessOutput">0.2</output>
    </div>

    <div class="row">
            <label># Small Hills:</label>
      <input id="smallCountInput" value="20" type="range" min="0" max="60" step="1" oninput="smallCountOutput.value = smallCountInput.valueAsNumber">
      <output id="smallCountOutput">20</output>
            <span class="hint">(auto‑seeded)</span>
    </div>

    <div class="row">
            <label>Sea Level:</label>
            <input id="seaLevelInput" value="0.35" type="range" min="0" max="1" step="0.01" oninput="seaLevelOutput.value = seaLevelInput.valueAsNumber;">
      <output id="seaLevelOutput">0.35</output>
    </div>

    <div class="row">
            <label>Water Border (%):</label>
            <input id="borderPctInput" value="8" type="range" min="2" max="20" step="1" oninput="borderPctOutput.value = borderPctInput.valueAsNumber; __state.applyBorder && __state.applyBorder(); __state.recolor && __state.recolor();">
      <output id="borderPctOutput">8</output>
    </div>

    <div class="row">
            <label>Min Lake Size:</label>
      <input id="minLakeSizeInput" value="3" type="range" min="1" max="10" step="1" oninput="minLakeSizeOutput.value = minLakeSizeInput.valueAsNumber; __state.recolor && __state.recolor();">
      <output id="minLakeSizeOutput">3</output>
    </div>

    <div class="row">
            <label>Min Lake Depth:</label>
      <input id="minLakeDepthInput" value="0.05" type="range" min="0.01" max="0.15" step="0.01" oninput="minLakeDepthOutput.value = minLakeDepthInput.valueAsNumber; __state.recolor && __state.recolor();">
      <output id="minLakeDepthOutput">0.05</output>
    </div>

    <div class="row">
      <label>World Type:</label>
      <select id="worldType" onchange="generate();">
        <option value="volcanicIsland">Volcanic Island</option>
        <option value="highIsland">High Island</option>
        <option value="lowIsland">Low Island</option>
        <option value="continents" selected>Continents</option>
        <option value="archipelago">Archipelago</option>
      </select>
    </div>

    <div class="row">
      <label>World Seed:</label>
      <input id="seedInput" value="" type="number" min="1" max="999999" onchange="generate();">
      <span class="hint">(leave empty for random, or set for reproducible results)</span>
    </div>

    <div class="row">
      <label>Debug Operations:</label>
      <input id="debugOpsInput" type="checkbox" onchange="generate();">
      <span>Show operation overlays</span>
    </div>

    <div class="row">
      <label>Thermal Erosion (Talus):</label>
      <input id="talusInput" value="0.02" type="range" min="0.01" max="0.05" step="0.005" oninput="talusOutput.value = talusInput.valueAsNumber; __state.recolor && __state.recolor();">
      <output id="talusOutput">0.02</output>
    </div>

    <div class="row">
      <label>Thermal Erosion (Strength):</label>
      <input id="thermalStrengthInput" value="0.5" type="range" min="0.1" max="1.0" step="0.1" oninput="thermalStrengthOutput.value = thermalStrengthInput.valueAsNumber; __state.recolor && __state.recolor();">
      <output id="thermalStrengthOutput">0.5</output>
    </div>

    <div class="row">
      <label>Land Smoothing (Alpha):</label>
      <input id="smoothAlphaInput" value="0.2" type="range" min="0.05" max="0.5" step="0.05" oninput="smoothAlphaOutput.value = smoothAlphaInput.valueAsNumber; __state.recolor && __state.recolor();">
      <output id="smoothAlphaOutput">0.2</output>
    </div>

    <div class="row">
      <label>River Style:</label>
      <select id="riverStyle" onchange="__state.recolor && __state.recolor();">
        <option value="lines">Lines</option>
        <option value="polygons" selected>Polygonal</option>
      </select>
    </div>

    <div class="row">
      <label>River Width:</label>
      <input id="riverWidthInput" value="200" type="range" min="50" max="400" step="10" oninput="riverWidthOutput.value = riverWidthInput.valueAsNumber; __state.recolor && __state.recolor();">
      <output id="riverWidthOutput">200</output>
    </div>
        </div>

        <!-- Climate Tab -->
        <div id="climate-tab" class="tab-content">
          <div class="row">
            <label>Rainfall:</label>
            <input id="rainInput" value="1.0" type="range" min="0" max="2" step="0.05" oninput="rainOutput.value = rainInput.valueAsNumber; __state.recolor && __state.recolor();">
            <output id="rainOutput">1.0</output>
          </div>

          <div class="row">
            <label>Wind Belts:</label>
            <select id="windBelts" onchange="__state.recolor && __state.recolor();">
              <option value="none" selected>None (Random)</option>
              <option value="hadley">Hadley/Ferrel/Polar</option>
            </select>
          </div>

          <div class="row">
            <label>River Density:</label>
            <input id="riverDensityInput" value="0.90" type="range" min="0.70" max="0.99" step="0.01" oninput="riverDensityOutput.value = riverDensityInput.valueAsNumber;">
            <output id="riverDensityOutput">0.90</output>
          </div>

          <div class="row">
            <label>Base Temperature (°F):</label>
            <input id="baseTempInput" value="67" type="range" min="41" max="77" step="1" oninput="baseTempOutput.value = baseTempInput.valueAsNumber; __state.recolor && __state.recolor();">
            <output id="baseTempOutput">67</output>
          </div>

          <div class="row">
            <label>Precipitation Scale:</label>
            <input id="precipScaleInput" value="1.1" type="range" min="0.1" max="2.0" step="0.1" oninput="precipScaleOutput.value = precipScaleInput.valueAsNumber; __state.recolor && __state.recolor();">
            <output id="precipScaleOutput">1.1</output>
          </div>

    <div class="row">
      <label>Render Mode:</label>
      <select id="renderMode" onchange="__state.recolor && __state.recolor();">
        <option value="heightmap" selected>Heightmap</option>
        <option value="biomes">Biomes</option>
        <option value="hybrid">Hybrid</option>
      </select>
    </div>

    <div class="row">
      <label>Shaded Relief:</label>
      <select id="shadingMode" onchange="__state.recolor && __state.recolor();">
        <option value="none" selected>None</option>
        <option value="shaded">Shaded</option>
      </select>
          </div>
    </div>

        <!-- Settlements Tab -->
        <div id="settlements-tab" class="tab-content">
          <div class="row">
            <label>Burgs Count:</label>
            <input id="burgsCountInput" value="25" type="range" min="0" max="50" step="1" oninput="burgsCountOutput.value = burgsCountInput.valueAsNumber; __state.generateBurgs && __state.generateBurgs();">
<output id="burgsCountOutput">25</output>
          </div>

    <div class="row">
            <label>Burg Spacing (px):</label>
            <input id="burgSpacingInput" value="12" type="range" min="8" max="20" step="1" oninput="burgSpacingOutput.value = burgSpacingInput.valueAsNumber; __state.generateBurgs && __state.generateBurgs();">
            <output id="burgSpacingOutput">12</output>
          </div>

          <div class="row">
            <label>River Weight:</label>
            <input id="riverWeightInput" value="0.4" type="range" min="0" max="1" step="0.1" oninput="riverWeightOutput.value = riverWeightInput.valueAsNumber; __state.generateBurgs && __state.generateBurgs();">
            <output id="riverWeightOutput">0.4</output>
          </div>

          <div class="row">
            <label>Coast Weight:</label>
            <input id="coastWeightInput" value="0.3" type="range" min="0" max="1" step="0.1" oninput="coastWeightOutput.value = coastWeightInput.valueAsNumber; __state.generateBurgs && __state.generateBurgs();">
            <output id="coastWeightOutput">0.3</output>
          </div>

          <div class="row">
            <label>Flatness Weight:</label>
            <input id="flatnessWeightInput" value="0.2" type="range" min="0" max="1" step="0.1" oninput="flatnessWeightOutput.value = flatnessWeightInput.valueAsNumber; __state.generateBurgs && __state.generateBurgs();">
            <output id="flatnessWeightOutput">0.2</output>
          </div>

          <div class="row">
            <label>Fertility Weight:</label>
            <input id="fertilityWeightInput" value="0.1" type="range" min="0" max="1" step="0.1" oninput="fertilityWeightOutput.value = fertilityWeightInput.valueAsNumber; __state.generateBurgs && __state.generateBurgs();">
            <output id="fertilityWeightOutput">0.1</output>
          </div>
        </div>

        <!-- Routes Tab -->
        <div id="routes-tab" class="tab-content">
          <div class="row">
            <label>Road Density (Primary):</label>
            <input id="roadDensityInput" value="0.6" type="range" min="0" max="1" step="0.05" oninput="roadDensityOutput.value = roadDensityInput.valueAsNumber; debouncedComputeRoutes();">
            <output id="roadDensityOutput">0.6</output>
          </div>

          <div class="row">
            <label>Trail Density (Local):</label>
            <input id="trailDensityInput" value="0.5" type="range" min="0" max="1" step="0.05" oninput="trailDensityOutput.value = trailDensityInput.valueAsNumber; debouncedComputeRoutes();">
            <output id="trailDensityOutput">0.5</output>
          </div>

          <div class="row">
            <label>Slope Penalty:</label>
            <input id="slopePenaltyInput" value="1.2" type="range" min="0" max="3" step="0.1" oninput="slopePenaltyOutput.value = slopePenaltyInput.valueAsNumber; debouncedComputeRoutes();">
            <output id="slopePenaltyOutput">1.2</output>
          </div>

          <div class="row">
            <label>River Crossing Penalty:</label>
            <input id="riverPenaltyInput" value="1.0" type="range" min="0" max="3" step="0.1" oninput="riverPenaltyOutput.value = riverPenaltyInput.valueAsNumber; debouncedComputeRoutes();">
            <output id="riverPenaltyOutput">1.0</output>
          </div>

          <div class="row">
            <label>Roads:</label>
            <input id="roadsOnInput" type="checkbox" checked onchange="toggleRoutes('roads', this.checked);">
            <span style="margin-left: 8px;">Enable primary roads</span>
          </div>

          <div class="row">
            <label>Trails:</label>
            <input id="trailsOnInput" type="checkbox" checked onchange="toggleRoutes('trails', this.checked);">
            <span style="margin-left: 8px;">Enable local trails</span>
          </div>

          <div class="row">
            <label>Sea Routes:</label>
            <input id="seaRoutesOnInput" type="checkbox" checked onchange="toggleRoutes('searoutes', this.checked);">
            <span style="margin-left: 8px;">Enable sea routes</span>
          </div>
        </div>
      </div>
    </div>
  </div>

  <details class="tests">
    <summary>Show Tests</summary>
    <button id="runTests">Run Tests</button>
    <ol id="testResults"></ol>
  </details>

  <!-- libs -->
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <!-- D3 v7 (uses d3.pointer and d3-delaunay for Voronoi) -->
  <script src="https://d3js.org/d3.v7.min.js"></script>

  <script>
    // Map size management function
    function setMapSize(w, h) {
      const svg = d3.select('#map');
      svg.attr('width', w).attr('height', h).attr('viewBox', `0 0 ${w} ${h}`);
      const canvas = document.getElementById('canvas');
      if (canvas) { canvas.width = w; canvas.height = h; }
    }

    // Debug flag for performance
    const DEBUG = false;

    // === utils/heap: MinHeap for A* open set ===
    class MinHeap {
      constructor(scoreFn){ this._s=[]; this._f=scoreFn; }
      push(x){ const a=this._s, f=this._f; a.push(x); let i=a.length-1;
        while(i>0){ const p=(i-1)>>1; if(f(a[i])>=f(a[p])) break; [a[i],a[p]]=[a[p],a[i]]; i=p; } }
      pop(){ const a=this._s, f=this._f; if(a.length===1) return a.pop();
        const top=a[0]; a[0]=a.pop(); let i=0;
        for(;;){ const l=i*2+1, r=l+1; let m=i;
          if(l<a.length && f(a[l])<f(a[m])) m=l;
          if(r<a.length && f(a[r])<f(a[m])) m=r;
          if(m===i) break; [a[i],a[m]]=[a[m],a[i]]; i=m; }
        return top; }
      get size(){ return this._s.length; }
      clear(){ this._s.length=0; }
    }

    // === utils/throttle ===
    function rafThrottle(fn) {
      let tick=0, lastArgs=null;
      return (...args)=>{ lastArgs=args; if (tick) return; tick=1; requestAnimationFrame(()=>{ tick=0; fn(...lastArgs); }); };
    }

    // === utils/svg-path helpers ===
    function polylineToPathD(points) {
      if (!points || points.length===0) return '';
      let d = `M${points[0].x},${points[0].y}`;
      for (let i=1;i<points.length;i++) d += `L${points[i].x},${points[i].y}`;
      return d;
    }

    // Merge unordered segments into polylines: segments = [{a:{x,y}, b:{x,y}}...]
    function segmentsToPolylines(segments) {
      // Simple O(n) chain stitch using hash of endpoints
      const key = p => `${p.x.toFixed(4)},${p.y.toFixed(4)}`;
      const startMap=new Map(), endMap=new Map();
      for (const s of segments) {
        const A={x:s.a.x,y:s.a.y}, B={x:s.b.x,y:s.b.y};
        startMap.set(key(A), (startMap.get(key(A))||[]).concat({A,B}));
        endMap.set(key(B), (endMap.get(key(B))||[]).concat({A,B}));
      }
      const used=new Set(); const polylines=[];
      for (const [_, arr] of startMap) {
        for (const seg of arr) {
          const sig = `${seg.A.x},${seg.A.y}->${seg.B.x},${seg.B.y}`;
          if (used.has(sig)) continue;
          used.add(sig);
          const chain=[seg.A, seg.B];

          // extend forward
          for(;;){
            const tail = chain[chain.length-1];
            const nextArr = startMap.get(key(tail));
            let found=false;
            if (nextArr) for (const n of nextArr) {
              const nsig = `${n.A.x},${n.A.y}->${n.B.x},${n.B.y}`;
              if (used.has(nsig)) continue;
              if (n.A.x===tail.x && n.A.y===tail.y) {
                chain.push(n.B); used.add(nsig); found=true; break;
              }
            }
            if (!found) break;
          }

          // extend backward
          for(;;){
            const head = chain[0];
            const prevArr = endMap.get(key(head));
            let found=false;
            if (prevArr) for (const p of prevArr) {
              const psig = `${p.A.x},${p.A.y}->${p.B.x},${p.B.y}`;
              if (used.has(psig)) continue;
              if (p.B.x===head.x && p.B.y===head.y) {
                chain.unshift(p.A); used.add(psig); found=true; break;
              }
            }
            if (!found) break;
          }
          polylines.push(chain);
        }
      }
      return polylines;
    }

    // === graph cache ===
    const GraphCache = {
      land: null, // {nodesCount, edges, neighbors, edgeCost}
      sea:  null,
      invalidate(type){ if (!type || type==='land') this.land=null; if (!type || type==='sea') this.sea=null; }
    };

    // Call this inside buildLandGraph after you compute nodes & edges
    function finalizeLandGraph(nodesCount, edges) {
      // edges: [{u:int, v:int, w:number}]
      const neighbors = new Array(nodesCount); for (let i=0;i<nodesCount;i++) neighbors[i]=[];
      const edgeCost = new Map(); // `${u}:${v}` -> w
      for (const e of edges){ neighbors[e.u].push(e.v); neighbors[e.v].push(e.u); edgeCost.set(`${e.u}:${e.v}`, e.w); edgeCost.set(`${e.v}:${e.u}`, e.w); }
      GraphCache.land = { nodesCount, edges, neighbors, edgeCost };
    }

    function finalizeSeaGraph(nodesCount, edges, xy) {
      const neighbors = new Array(nodesCount); for (let i=0;i<nodesCount;i++) neighbors[i]=[];
      const edgeCost = new Map();
      for (const e of edges){ neighbors[e.u].push(e.v); neighbors[e.v].push(e.u); edgeCost.set(`${e.u}:${e.v}`, e.w); edgeCost.set(`${e.v}:${e.u}`, e.w); }
      GraphCache.sea = { nodesCount, edges, neighbors, edgeCost, xy };
    }

    // === SeaRouter with cache ===
    const SeaRouter = {
      _cache: new Map(), // key: portNodeId -> {dist: Float64Array, prev: Int32Array}
      clear(){ this._cache.clear(); },
      ensureFor(portNodeId){
        const G = GraphCache.sea; if (!G) throw new Error('Sea graph missing');
        if (this._cache.has(portNodeId)) return this._cache.get(portNodeId);

        const N = G.nodesCount, neighbors=G.neighbors, cost=(u,v)=>G.edgeCost.get(`${u}:${v}`) ?? 1;
        const dist=new Float64Array(N); dist.fill(1e20); dist[portNodeId]=0;
        const prev=new Int32Array(N); prev.fill(-1);
        const open = new MinHeap(i=>dist[i]); open.push(portNodeId);

        while(open.size){
          const u=open.pop();
          for (const v of neighbors[u]) {
            const alt = dist[u] + cost(u,v);
            if (alt < dist[v]) { dist[v]=alt; prev[v]=u; open.push(v); }
          }
        }
        const pack = {dist, prev};
        this._cache.set(portNodeId, pack);
        return pack;
      },
      
      // Early-exit variant that stops when all target ports are reached
      ensureForToTargets(portNodeId, goalNodeIds) {
        const G = GraphCache.sea; if (!G) throw new Error('Sea graph missing');
        const goalSet = new Set(goalNodeIds);
        const N = G.nodesCount, neighbors=G.neighbors, cost=(u,v)=>G.edgeCost.get(`${u}:${v}`) ?? 1;

        const dist=new Float64Array(N); dist.fill(1e20); dist[portNodeId]=0;
        const prev=new Int32Array(N); prev.fill(-1);
        const open = new MinHeap(i=>dist[i]); open.push(portNodeId);

        let remaining = goalSet.size;
        while (open.size && remaining > 0) {
          const u = open.pop();
          if (goalSet.has(u)) { goalSet.delete(u); remaining--; if (remaining === 0) break; }
          const du = dist[u];
          for (const v of neighbors[u]) {
            const alt = du + cost(u,v);
            if (alt < dist[v]) { dist[v]=alt; prev[v]=u; open.push(v); }
          }
        }
        return {dist, prev};
      }
    };

    // Returns nearest sea node within maxPx, else -1
    function snapPortToSeaNode(x, y, maxPx = 16) {
      const G = GraphCache.sea; if (!G || !G.xy) throw new Error('Sea graph missing coords');
      let best = -1, bestD2 = maxPx*maxPx;
      for (let i=0;i<G.xy.length;i++) {
        const pt = G.xy[i]; if (!pt) continue; // Skip null entries
        const dx = pt[0]-x, dy = pt[1]-y, d2 = dx*dx+dy*dy;
        if (d2 < bestD2) { best=i; bestD2=d2; }
      }
      return best;
    }

    // Label connected components once (linear time)
    function labelSeaComponents() {
      const G = GraphCache.sea; if (!G) return null;
      const comp = new Int32Array(G.nodesCount); comp.fill(-1);
      let id = 0;
      for (let s=0;s<G.nodesCount;s++){
        if (comp[s] !== -1) continue;
        const q=[s]; comp[s]=id;
        for(let qi=0; qi<q.length; qi++){
          const u=q[qi];
          for(const v of G.neighbors[u]) if (comp[v]===-1){ comp[v]=id; q.push(v); }
        }
        id++;
      }
      return comp;
    }

    // Returns Float32Array len=cellsCount with distance (in cells) to nearest water cell
    function computeDistanceToWater(isWater, width, height) {
      const N = width*height;
      const INF = 1e9;
      const dist = new Float32Array(N); for (let i=0;i<N;i++) dist[i]=INF;
      const q = [];

      // multi-source with all water cells
      for (let i=0;i<N;i++) if (isWater[i]) { dist[i]=0; q.push(i); }

      let qi=0;
      const neighborsIdx = (idx) => {
        const x = idx%width, y=(idx/width|0);
        const out=[];
        if (x>0) out.push(idx-1);
        if (x<width-1) out.push(idx+1);
        if (y>0) out.push(idx-width);
        if (y<height-1) out.push(idx+width);
        return out;
      };

      while (qi<q.length){
        const u=q[qi++];
        const du=dist[u]+1;
        for (const v of neighborsIdx(u)) if (du<dist[v]) { dist[v]=du; q.push(v); }
      }
      return dist;
    }

    function drawPathsFromSegments(svgLayer, segments, className) {
      if (!segments || !segments.length) return;
      const polylines = segmentsToPolylines(segments);
      const frag = document.createDocumentFragment();
      for (const poly of polylines) {
        const d = polylineToPathD(poly);
        if (!d) continue;
        const p = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        p.setAttribute('class', className);
        p.setAttribute('d', d);
        frag.appendChild(p);
      }
      svgLayer.textContent=''; // clear layer
      svgLayer.appendChild(frag);
    }

    function resetGenerationState() {
      // Clear SVG layers (roads/trails/sea/coastlines etc.)
      const ids = ['roadsLayer','trailsLayer','seaRoutesLayer','coastlinesLayer','burgsLayer'];
      for (const id of ids) { const n = document.getElementById(id); if (n) n.textContent=''; }
      // Invalidate graphs & caches
      GraphCache.invalidate();
      SeaRouter.clear();
      // Any per-run arrays (burgs, roads, trails, usage…) should be re-created here
    }

    // Debounce function for UI updates
    const rafDebounce = (fn) => {
      let r = 0; 
      return (...a) => { 
        cancelAnimationFrame(r); 
        r = requestAnimationFrame(() => fn(...a)); 
      }; 
    };

    // Heavy debounced recolor for expensive operations
    const heavyDebounce = (fn, delay = 150) => {
      let timeout = 0; 
      return (...a) => { 
        clearTimeout(timeout); 
        timeout = setTimeout(() => fn(...a), delay); 
      }; 
    };

    // Route computation debouncing and single-flight logic
    let routeRunToken = 0;
    let isRouting = false;
    let pendingRoutes = false;
    
    // Heavier debounce for sliders on phones
    const isCoarse = window.matchMedia('(pointer: coarse)').matches;
    const HEAVY_DELAY = isCoarse ? 400 : 200;

    const debouncedComputeRoutes = heavyDebounce(() => {
      // Invalidate route caches when route settings change
      GraphCache.invalidate('land');
      if (window.__state.computeRoutes) {
        window.__state.computeRoutes();
      }
    }, HEAVY_DELAY);

    // Cached DOM elements for performance
    const DOM = {
      seaLevelInput: document.getElementById('seaLevelInput'),
      seaRoutesOnInput: document.getElementById('seaRoutesOnInput'),
      sizeInput: document.getElementById('sizeInput')
    };

    // Canvas-based terrain rendering for performance
    const TerrainCanvas = (() => {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      let terrainDirty = true;
      
      return {
        canvas,
        ctx,
        setDirty: () => { terrainDirty = true; },
        isDirty: () => terrainDirty,
        markClean: () => { terrainDirty = false; }
      };
    })();

    // Precipitation caching
    let PRECIP = null;
    function recomputePrecip() { 
      PRECIP = computePrecipArray(); 
    }

    // Set up precipitation recomputation on climate changes
    ['rainInput', 'windBelts'].forEach(id => {
      const element = document.getElementById(id);
      if (element) {
        element.addEventListener('input', rafDebounce(recomputePrecip));
      }
    });

    // Set up terrain dirty flag triggers
    ['seaLevelInput', 'talusInput', 'thermalStrengthInput', 'smoothAlphaInput'].forEach(id => {
      const element = document.getElementById(id);
      if (element) {
        element.addEventListener('input', () => TerrainCanvas.setDirty());
      }
    });

    // Set up debounced recolor for heavy sliders
    const heavySliders = ['seaLevelInput', 'riverDensityInput', 'riverWidthInput', 'minLakeSizeInput', 'minLakeDepthInput'];
    heavySliders.forEach(id => {
      const element = document.getElementById(id);
      if (element) {
        element.addEventListener('input', heavyDebounce(() => {
          // Invalidate caches when sea level changes
          if (id === 'seaLevelInput') {
            GraphCache.invalidate();
            SeaRouter.clear();
          }
          RegenerationFlags.setNeedsRecolor();
          if (window.__state) {
            // ensure the water mask + coastlines match the new sea level
            if (typeof window.drawCoastlines === 'function') window.drawCoastlines();
            if (typeof window.__state.recolor === 'function') window.__state.recolor();
          }
        }, HEAVY_DELAY));
      }
    });

    // Set up regeneration flags for seed-only changes
    const seedOnlySliders = ['highInput', 'radiusInput', 'sharpnessInput', 'smallCountInput'];
    seedOnlySliders.forEach(id => {
      const element = document.getElementById(id);
      if (element) {
        element.addEventListener('input', () => {
          RegenerationFlags.setNeedsRegenerate();
        });
      }
    });

    // Centralized route layer management
    const RouteLayers = (() => {
      const svg = d3.select('svg');
      let root = d3.select('#routes');
      if (root.empty()) {
        // Routes are now created in the zoomRoot, so just get the existing one
        root = d3.select('#routes');
      }
      const g = {
        root,
        roads: root.select('.roads'),
        trails: root.select('.trails'),
        sea: root.select('.searoutes')
      };
      return g;
    })();

    // Route building optimization
    function pathFromPolylines(lines) {
      // lines: Array<Array<[x,y]>>
      let d = '';
      for (const L of lines) {
        if (!L.length) continue;
        d += `M${L[0][0]},${L[0][1]}`;
        for (let i = 1; i < L.length; i++) d += `L${L[i][0]},${L[i][1]}`;
      }
      return d;
    }
    
    /**
     * Draw lines with instrumentation for debugging
     * @param {string} selector - CSS selector for the target group
     * @param {Array} lines - Array of polylines
     */
    function drawLines(selector, lines) {
      const d = pathFromPolylines(lines);
      const sel = d3.select(selector);
      sel.selectAll('path').data([0]).join('path').attr('d', d);

      // Quick instrumentation
      const segs = lines.reduce((a, L) => a + Math.max(0, L.length - 1), 0);
      const len = lines.reduce((a, L) => a + L.reduce((s, [x, y], i) => s + (i ? Math.hypot(x - L[i - 1][0], y - L[i - 1][1]) : 0), 0), 0);
      console.log(selector, { polylines: lines.length, segments: segs, totalLength: len.toFixed(1) });
    }

    // SVG Path simplification using Ramer-Douglas-Peucker algorithm
    function simplifyPath(points, tolerance = 0.2) {
      if (points.length <= 2) return points;
      
      function perpendicularDistance(point, lineStart, lineEnd) {
        const [x, y] = point;
        const [x1, y1] = lineStart;
        const [x2, y2] = lineEnd;
        
        const A = x - x1;
        const B = y - y1;
        const C = x2 - x1;
        const D = y2 - y1;
        
        const dot = A * C + B * D;
        const lenSq = C * C + D * D;
        let param = -1;
        
        if (lenSq !== 0) param = dot / lenSq;
        
        let xx, yy;
        if (param < 0) {
          xx = x1;
          yy = y1;
        } else if (param > 1) {
          xx = x2;
          yy = y2;
        } else {
          xx = x1 + param * C;
          yy = y1 + param * D;
        }
        
        const dx = x - xx;
        const dy = y - yy;
        return Math.sqrt(dx * dx + dy * dy);
      }
      
      function douglasPeucker(points, start, end, tolerance, result) {
        if (end <= start + 1) return;
        
        let maxDistance = 0;
        let index = start;
        
        for (let i = start + 1; i < end; i++) {
          const distance = perpendicularDistance(points[i], points[start], points[end]);
          if (distance > maxDistance) {
            index = i;
            maxDistance = distance;
          }
        }
        
        if (maxDistance > tolerance) {
          douglasPeucker(points, start, index, tolerance, result);
          result.push(points[index]);
          douglasPeucker(points, index, end, tolerance, result);
        }
      }
      
      const result = [points[0]];
      douglasPeucker(points, 0, points.length - 1, tolerance, result);
      result.push(points[points.length - 1]);
      
      return result;
    }
    
    /**
     * Adaptive path simplification based on map size
     * @param {Array} lines - Array of polylines
     * @param {number} width - Map width
     * @param {number} height - Map height
     * @returns {Array} Simplified polylines
     */
    function adaptiveSimplify(lines, width, height) {
      const tol = Math.max(0.2, Math.min(1.5, Math.sqrt(width * height) / 1800));
      return lines.map(L => simplifyPath(L, tol));
    }

    function adaptiveSimplifySea(lines, w, h) {
      const tol = Math.max(0.1, Math.min(0.5, Math.sqrt(w*h)/50000)); // Extremely gentle simplification to preserve curves
      return lines.map(L => {
        const simplified = simplifyPath(L, tol);
        // Ensure we keep at least 3 points for any meaningful curve
        return simplified.length < 3 ? L : simplified;
      });
    }

    // Dirty flags for incremental updates
    const RouteDirty = {
      burgs: true,
      landGraph: true,
      sea: true
    };

    // Regeneration flags for seed-only changes
    const RegenerationFlags = {
      needsRegenerate: false,
      needsRecolor: false,
      
      setNeedsRegenerate() {
        this.needsRegenerate = true;
        this.needsRecolor = true;
      },
      
      setNeedsRecolor() {
        this.needsRecolor = true;
      },
      
      clear() {
        this.needsRegenerate = false;
        this.needsRecolor = false;
      }
    };

    // Progress management system
    const ProgressManager = {
      overlay: null,
      fill: null,
      text: null,
      detail: null,
      isVisible: false,
      lastUpdate: 0,
      updateThrottle: 100, // Only update every 100ms
      _throttledUpdate: null, // Will hold throttled version
      
      init() {
        this.overlay = document.getElementById('progressOverlay');
        this.fill = document.getElementById('progressFill');
        this.text = document.getElementById('progressText');
        this.detail = document.getElementById('progressDetail');
        
        // Create throttled version of update that preserves 'this' context
        this._throttledUpdate = rafThrottle((percent, text, detail) => {
          this._update(percent, text, detail);
        });
        
        // Debug logging
        console.log('ProgressManager.init() called');
        console.log('overlay:', this.overlay);
        console.log('fill:', this.fill);
        console.log('text:', this.text);
        console.log('detail:', this.detail);
      },
      
      show() {
        console.log('ProgressManager.show() called');
        if (this.overlay) {
          this.overlay.style.display = 'flex';
          this.isVisible = true;
          console.log('Progress overlay shown');
          
          // Force a repaint to ensure visibility
          this.overlay.offsetHeight;
        } else {
          console.log('Progress overlay not found!');
        }
      },
      
      hide() {
        console.log('ProgressManager.hide() called');
        if (this.overlay) {
          this.overlay.style.display = 'none';
          this.isVisible = false;
          console.log('Progress overlay hidden');
        }
      },
      
      update(percent, text, detail = '') {
        // Use throttled version if available, otherwise direct update
        if (this._throttledUpdate) {
          this._throttledUpdate(percent, text, detail);
        } else {
          this._update(percent, text, detail);
        }
      },
      
      _update(percent, text, detail = '') {
        // Throttle updates to reduce spam, but allow final completion updates
        const now = Date.now();
        const isFinalUpdate = percent >= 100;
        if (!isFinalUpdate && now - this.lastUpdate < this.updateThrottle) {
          return;
        }
        this.lastUpdate = now;
        
        // Ensure overlay is visible before updating
        if (!this.isVisible) {
          this.show();
        }
        
        if (this.fill) {
          this.fill.style.width = `${Math.min(100, Math.max(0, percent))}%`;
        }
        if (this.text) {
          this.text.textContent = text;
        }
        if (this.detail) {
          this.detail.textContent = detail;
        }
        
        if (DEBUG) {
          console.log(`Progress update: ${percent}% - ${text}`);
        }
        
        // Force a repaint to ensure updates are visible
        if (this.overlay) {
          this.overlay.offsetHeight;
        }
      },
      
      setPhase(phase, percent) {
        const phases = {
          'init': { text: 'Initializing map generation...', percent: 5 },
          'voronoi': { text: 'Building Voronoi diagram...', percent: 15 },
          'terrain': { text: 'Generating terrain...', percent: 30 },
          'erosion': { text: 'Applying erosion...', percent: 45 },
          'rivers': { text: 'Computing rivers...', percent: 60 },
          'coastlines': { text: 'Drawing coastlines...', percent: 70 },
          'burgs': { text: 'Placing settlements...', percent: 80 },
          'routes': { text: 'Building routes...', percent: 90 },
          'final': { text: 'Finalizing...', percent: 95 }
        };
        
        const phaseInfo = phases[phase] || { text: phase, percent: percent || 50 };
        this.update(phaseInfo.percent, phaseInfo.text);
      }
    };

  (function () {
    'use strict';

      // Initialize progress manager after DOM is ready
      document.addEventListener('DOMContentLoaded', () => {
        ProgressManager.init();
        
        // Register service worker for offline functionality
        if ('serviceWorker' in navigator) {
          navigator.serviceWorker.register('/sw.js')
            .then(registration => {
              console.log('ServiceWorker registration successful');
            })
            .catch(err => {
              console.log('ServiceWorker registration failed: ', err);
            });
        }
      });
      
      // Also try to init immediately in case DOM is already loaded
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
          ProgressManager.init();
        });
      } else {
        ProgressManager.init();
      }
      
      // Register service worker immediately if DOM is ready
      if (document.readyState !== 'loading' && 'serviceWorker' in navigator) {
        navigator.serviceWorker.register('/sw.js')
          .then(registration => {
            console.log('ServiceWorker registration successful');
          })
          .catch(err => {
            console.log('ServiceWorker registration failed: ', err);
          });
      }

    // Define constants up-front so they're available when generate() first runs
    const WATER_COLOR = d3.interpolateBlues(0.55); // single water color (less busy)

    // Expose generate() globally for the button
    window.generate = generate;
    
    /**
     * Fast toggle for route visibility without recomputation
     * @param {string} routeType - Type of route ('roads', 'trails', 'searoutes')
     * @param {boolean} visible - Whether to show or hide
     */
    function toggleRoutes(routeType, visible) {
      const selector = `#routes .${routeType}`;
      const group = d3.select(selector);
      if (group.size() > 0) {
        group.style('display', visible ? null : 'none');
      }
      
      // Only recompute if density/slope settings changed
      // For now, just do fast toggle - can be enhanced later
    }

    // State we expose for tests/debugging
    window.__state = { cells: null, delaunay: null, voronoi: null, svg: null, add: null, recolor: null, autoSeed: null, drawCoastlines: null, applyBorder: null, borderPx: 0, generate: generate, burgs: [] };

    // Export functions (will be defined later)
    window.saveSVG = null;
    window.savePNG = null;

    // Burg data model and generation constants
    const BURG_TYPES = {
      hamlet: { radius: 1.5, population: 100 },
      town: { radius: 2.5, population: 1000 },
      city: { radius: 3.5, population: 10000 },
      capital: { radius: 4.5, population: 50000 },
      port: { radius: 2.5, population: 2000 }
    };

    // Simple name generation (placeholder - can be enhanced with culture-based names)
    const BURG_NAMES = [
      'Riverton', 'Harborview', 'Stonebridge', 'Greenfield', 'Ironforge',
      'Silverport', 'Goldcrest', 'Blackwood', 'Whitecliff', 'Redhaven',
      'Bluewater', 'Fairview', 'Highland', 'Lowland', 'Midtown',
      'Northport', 'Southgate', 'Eastside', 'Westend', 'Central'
    ];

    // initialize outputs to match inputs
    sizeOutput.value = sizeInput.valueAsNumber;
    highOutput.value = highInput.valueAsNumber;
    radiusOutput.value = radiusInput.valueAsNumber;
    sharpnessOutput.value = sharpnessInput.valueAsNumber;
    seaLevelOutput.value = seaLevelInput.valueAsNumber;
    smallCountOutput.value = smallCountInput.valueAsNumber;
    borderPctOutput.value = borderPctInput.valueAsNumber;
    minLakeSizeOutput.value = minLakeSizeInput.valueAsNumber;
    minLakeDepthOutput.value = minLakeDepthInput.valueAsNumber;
    baseTempOutput.value = baseTempInput.valueAsNumber;
    precipScaleOutput.value = precipScaleInput.valueAsNumber;
    riverWidthOutput.value = riverWidthInput.valueAsNumber;
    talusOutput.value = talusInput.valueAsNumber;
    thermalStrengthOutput.value = thermalStrengthInput.valueAsNumber;
    smoothAlphaOutput.value = smoothAlphaInput.valueAsNumber;
    burgsCountOutput.value = burgsCountInput.valueAsNumber;
    burgSpacingOutput.value = burgSpacingInput.valueAsNumber;
    riverWeightOutput.value = riverWeightInput.valueAsNumber;
    coastWeightOutput.value = coastWeightInput.valueAsNumber;
    flatnessWeightOutput.value = flatnessWeightInput.valueAsNumber;
    fertilityWeightOutput.value = fertilityWeightInput.valueAsNumber;
    roadDensityOutput.value = roadDensityInput.valueAsNumber;
    trailDensityOutput.value = trailDensityInput.valueAsNumber;
    slopePenaltyOutput.value = slopePenaltyInput.valueAsNumber;
    riverPenaltyOutput.value = riverPenaltyInput.valueAsNumber;

    generate();

    function resetForNewRun() {
      const svg = d3.select('svg');
      // remove visual layers that will be rebuilt
      svg.select('.mapCells').remove();
      svg.select('.coastline').remove();
      svg.select('.rivers').remove();
      svg.select('#routes').remove();
      svg.select('#burgs').remove();
      svg.select('rect.ocean').remove();
      svg.select('defs #landClip').remove();

      // invalidate all per-run caches that can poison the next run
      if (window.__state) {
        delete window.__state.isWater;
        delete window.__state.landPaths;
        delete window.__state.unifiedLandPaths;
        delete window.__state.riverPolys;
        delete window.__state.ports;
        delete window.__state.roadUsage;
        delete window.__state.isLake;
      }
    }

    function generate() {
      resetGenerationState();
      resetForNewRun();
      
      // Always generate a new random seed when button is pressed
      // Only use input value if user has explicitly set it (not auto-generated)
      document.getElementById('seedInput').value = '';
      
      // Ensure progress manager is initialized
      if (!ProgressManager.overlay) {
        ProgressManager.init();
      }
      
      // Show progress overlay
      ProgressManager.show();
      ProgressManager.setPhase('init');
      
      d3.select('.mapCells').remove();
      d3.select('.coastline').remove();
      d3.select('#burgs').remove();
      d3.select('#routes').remove();
      
      // Clear burgs from state
      window.__state.burgs = [];

      const svg = d3.select('svg');
      
      // Create zoomable wrapper group
      const zoomRoot = svg.append('g').attr('id', 'zoomRoot');
      
      // Solid ocean backdrop to eliminate water seam artifacts (anti-aliasing between polygons)
      zoomRoot.select('rect.ocean').remove();
      zoomRoot.append('rect')
        .attr('class','ocean')
        .attr('x',0).attr('y',0)
        .attr('width', +svg.attr('width'))
        .attr('height', +svg.attr('height'))
        .attr('fill', WATER_COLOR);
      const mapCells = zoomRoot.append('g')
        .attr('class', 'mapCells');
      const riversShade = zoomRoot.append('g').attr('class', 'riversShade');
      const riversG = zoomRoot.append('g').attr('class', 'rivers');
      const coastG = zoomRoot.append('g').attr('class', 'coastline');
      const routesG = zoomRoot.append('g').attr('id', 'routes');
      // Burgs go outside zoomRoot so they can be counter-scaled independently
      const burgsG = svg.append('g').attr('id', 'burgs');
      const roadsG = routesG.append('g').attr('class', 'roads');
      const trailsG = routesG.append('g').attr('class', 'trails');
      const seaG = routesG.append('g').attr('class', 'searoutes');
      
      // Create defs for clip paths
      const defs = svg.append('defs');

      const width = +svg.attr('width');
      const height = +svg.attr('height');
      const n = sizeInput.valueAsNumber;

      // Keep the current zoom transform so we can position burgs after (re)draws
      window.currentTransform = d3.zoomIdentity;

      // Throttled for smoothness
      window.updateBurgPositions = rafThrottle((t = window.currentTransform) => {
        window.currentTransform = t;
        
        // Update burg groups with transform
        const burgGroups = burgsG.selectAll('g.burg');
        burgGroups.attr('transform', d => `translate(${t.applyX(d.x)},${t.applyY(d.y)})`);
        
        if (DEBUG && burgGroups.size() > 0) {
          console.log(`Updated ${burgGroups.size()} burg positions with transform:`, t);
        }
          
        // Update any standalone burg circles (if they exist)
        burgsG.selectAll('circle.burg')
          .attr('cx', d => t.applyX(d.x))
          .attr('cy', d => t.applyY(d.y));
      });

      // Add D3 zoom and pan functionality
      // Improve touchpad scroll feel a bit:
      const wheelDelta = (event) =>
        -event.deltaY * (event.deltaMode === 1 ? 0.05 : 0.002); // lines vs pixels

      const zoom = d3.zoom()
        .scaleExtent([0.5, 24])                    // min/max zoom
        .wheelDelta(wheelDelta)
        .translateExtent([[0, 0], [width, height]])// keep map roughly in view
        .extent([[0, 0], [width, height]])
        .on('zoom', (event) => {
          zoomRoot.attr('transform', event.transform);   // map (land/sea/routes) zooms
          window.updateBurgPositions(event.transform);          // burgs reproject to screen coords
        });

      svg.call(zoom).call(zoom.transform, d3.zoomIdentity); // initial

      // Double-tap zoom for one-hand use on mobile
      let lastTap = 0;
      svg.on('touchend', function(event) {
        const currentTime = new Date().getTime();
        const tapLength = currentTime - lastTap;
        if (tapLength < 500 && tapLength > 0) {
          // Double tap detected
          event.preventDefault();
          const point = d3.pointer(event, svg.node());
          const currentTransform = d3.zoomTransform(svg.node());
          const newScale = currentTransform.k * 2;
          const newTransform = d3.zoomIdentity
            .translate(point[0], point[1])
            .scale(newScale)
            .translate(-point[0], -point[1]);
          
          svg.transition().duration(300).call(zoom.transform, newTransform);
        }
        lastTap = currentTime;
      });

      // Optional helper functions for zoom control
      window.resetZoom = function() {
        svg.transition().duration(300).call(zoom.transform, d3.zoomIdentity);
      };

      window.zoomToBBox = function(bbox, pad = 24) {
        const cx = bbox.x + bbox.width/2, cy = bbox.y + bbox.height/2;
        const k = Math.min(
          width / (bbox.width + 2*pad),
          height / (bbox.height + 2*pad)
        );
        svg.transition().duration(400).call(
          zoom.transform,
          d3.zoomIdentity.translate(width/2, height/2).scale(k).translate(-cx, -cy)
        );
      };

      // Get the world seed for reproducible generation
      const seedInput = document.getElementById('seedInput').value;
      console.log('Seed input value:', seedInput, 'type:', typeof seedInput);
      // Always generate a new random seed unless user has explicitly set one
      const worldSeed = seedInput ? +seedInput : Math.floor(Math.random() * 999999) + 1;
      console.log('Generated world seed:', worldSeed);
      
      // Update the seed input to show the current seed (if it was random)
      if (!seedInput) {
        document.getElementById('seedInput').value = worldSeed;
        console.log('Updated seed input to:', worldSeed);
      }
      const rand = mulberry32(worldSeed);
      
      // initial random points
      let sites = d3.range(n).map(() => [rand() * width, rand() * height]);

      // One Lloyd relaxation step for nicer spacing
      ({ sites } = relaxOnce(sites, width, height));

      // Build Delaunay + Voronoi structures
      ProgressManager.setPhase('voronoi');
      const delaunay = d3.Delaunay.from(sites);
      const voronoi = delaunay.voronoi([0, 0, width, height]);

      // Build cell objects with neighbors
      const cells = d3.range(n).map((i) => ({
        index: i,
        poly: voronoi.cellPolygon(i),
        neighbors: Array.from(delaunay.neighbors(i)),
        high: 0,
        used: 0
      }));

      // Precompute polygon centroids for border mask filtering
      cells.forEach(c => { const ct = d3.polygonCentroid(c.poly); c.cx = ct[0]; c.cy = ct[1]; });

      // Palette (kept for future tweaks)
      const interp = { water: (t) => d3.interpolateBlues(t) };

      // Land color ramp: dark green lowlands → light green → tan → white peaks
      function landColor(t) {
        // t in [0,1], already normalized above sea level
        t = Math.max(0, Math.min(1, t));
        if (t < 0.35) {
          const u = t / 0.35; // 0..1
          return d3.interpolateYlGn(1.0 - 0.7 * u); // darker coastal greens (reversed)
        } else if (t < 0.7) {
          const u = (t - 0.35) / 0.35; // 0..1
          return d3.interpolateYlOrBr(0.25 + 0.75 * u); // foothills to tan
        } else if (t < 0.9) {
          const u = (t - 0.7) / 0.2; // 0..1
          return d3.interpolateOranges(0.4 + 0.6 * u); // warm rocky highlands
        } else {
          const u = (t - 0.9) / 0.1; // 0..1
          return d3.interpolateRgb('#e9ecef', '#ffffff')(u); // light grey → white snowcap
        }
      }

      // Draw polygons - use canvas for large maps, SVG for smaller ones
      const isCoarse = window.matchMedia('(pointer: coarse)').matches;
      const useCanvas = isCoarse ? cells.length > 4000 : cells.length > 8000;
      
      if (useCanvas) {
        // Canvas-based rendering for large maps
        // Scale the backing store by DPR so it isn't blurry on phones
        const dpr = Math.min(2, window.devicePixelRatio || 1); // cap to 2 for perf
        TerrainCanvas.canvas.width = width * dpr;
        TerrainCanvas.canvas.height = height * dpr;
        TerrainCanvas.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        TerrainCanvas.ctx.fillStyle = '#000';
        
        cells.forEach(cell => {
          if (cell.poly.length > 2) {
            TerrainCanvas.ctx.beginPath();
            TerrainCanvas.ctx.moveTo(cell.poly[0][0], cell.poly[0][1]);
            for (let i = 1; i < cell.poly.length; i++) {
              TerrainCanvas.ctx.lineTo(cell.poly[i][0], cell.poly[i][1]);
            }
            TerrainCanvas.ctx.closePath();
            TerrainCanvas.ctx.fill();
          }
        });
        
        // Add canvas as image to SVG
        const dataURL = TerrainCanvas.canvas.toDataURL();
        mapCells.append('image')
          .attr('href', dataURL)
          .attr('width', width)
          .attr('height', height)
          .attr('x', 0)
          .attr('y', 0);
      } else {
        // SVG-based rendering for smaller maps
      mapCells.selectAll('path.mapCell')
        .data(cells)
        .enter()
        .append('path')
        .attr('class', 'mapCell')
        .attr('id', d => d.index)
        .attr('d', d => 'M' + d.poly.map(p => p.join(',')).join('L') + 'Z')
        .attr('fill', '#000')
        .attr('fill-rule', 'nonzero');
      }

      // Keep shared state for tests and other functions
      window.__state.cells = cells;
      window.__state.delaunay = delaunay;
      window.__state.voronoi = voronoi;
      window.__state.svg = svg;
      window.__state.width = width;
      window.__state.height = height;
      window.__state.add = add;
      window.__state.recolor = rafDebounce(recolor);
      window.__state.autoSeed = autoSeed;
      window.__state.drawCoastlines = drawCoastlines;
      window.__state.applyBorder = applyBorderMask;
      window.__state.computeRivers = computeRivers;
      window.__state.generateBurgs = generateBurgs;
      window.__state.renderBurgs = renderBurgs;
      window.__state.computeRoutes = computeRoutes;

          // Initialize reusable typed arrays for performance
    window.__state.tmp = {
      dist: new Int32Array(cells.length),
      down: new Int32Array(cells.length),
      flux: new Float32Array(cells.length),
    };

    // Typed array pool for reuse across runs
    const ArrayPool = {
      float32: [],
      int32: [],
      uint32: [],
      
      getFloat32(size) {
        const pool = this.float32.filter(arr => arr.length >= size);
        if (pool.length > 0) {
          const arr = pool.pop();
          arr.fill(0);
          return arr;
        }
        return new Float32Array(size);
      },
      
      getInt32(size) {
        const pool = this.int32.filter(arr => arr.length >= size);
        if (pool.length > 0) {
          const arr = pool.pop();
          arr.fill(0);
          return arr;
        }
        return new Int32Array(size);
      },
      
      getUint32(size) {
        const pool = this.uint32.filter(arr => arr.length >= size);
        if (pool.length > 0) {
          const arr = pool.pop();
          arr.fill(0);
          return arr;
        }
        return new Uint32Array(size);
      },
      
      returnFloat32(arr) {
        this.float32.push(arr);
      },
      
      returnInt32(arr) {
        this.int32.push(arr);
      },
      
      returnUint32(arr) {
        this.uint32.push(arr);
      }
    };

      // --- Template System ---
      const templates = {
        volcanicIsland: {
          name: "Volcanic Island",
          description: "Big conically elevated island",
          steps: [
            {op: "mountain", at: "center", high: 0.9, radius: 0.94, sharpness: 0.18},
            {op: "add", value: 0.07},
            {op: "multiply", factor: 1.1},
            {op: "hills", count: 5, distribution: 0.40, high: 0.25, radius: 0.985, sharpness: 0.10},
            {op: "hills", count: 2, distribution: 0.15, high: 0.35, radius: 0.98, sharpness: 0.12}
          ]
        },

        highIsland: {
          name: "High Island",
          description: "Big and high island with complicated heightmap and landform",
          steps: [
            {op: "mountain", at: "center", high: 0.85, radius: 0.94, sharpness: 0.18},
            {op: "add", value: 0.08},
            {op: "multiply", factor: 0.9},
            {op: "ranges", count: 4, high: 0.18, radius: 0.986},
            {op: "hills", count: 12, distribution: 0.25, high: 0.20, radius: 0.985, sharpness: 0.10},
            {op: "troughs", count: 3, depth: -0.12, radius: 0.989},
            {op: "multiplyLand", factor: 0.75},
            {op: "hills", count: 3, distribution: 0.15, high: 0.26, radius: 0.984, sharpness: 0.12}
          ]
        },

        lowIsland: {
          name: "Low Island",
          description: "As above, but not elevated",
          steps: [
            {op: "mountain", at: "center", high: 0.62, radius: 0.945, sharpness: 0.16},
            {op: "add", value: 0.05},
            {op: "smooth", passes: 1},
            {op: "hills", count: 4, distribution: 0.40, high: 0.18, radius: 0.986, sharpness: 0.10},
            {op: "hills", count: 12, distribution: 0.20, high: 0.16, radius: 0.987, sharpness: 0.10},
            {op: "troughs", count: 3, depth: -0.09, radius: 0.99},
            {op: "multiplyLand", factor: 0.55}
          ]
        },

        continents: {
          name: "Continents",
          description: "Two or more islands separated by strait",
          steps: [
            {op: "mountain", at: "center", high: 0.80, radius: 0.955, sharpness: 0.16},
            {op: "hills", count: 24, distribution: 0.25, high: 0.19, radius: 0.986, sharpness: 0.10},
            {op: "ranges", count: 2, high: 0.21, radius: 0.987},
            {op: "hills", count: 3, distribution: 0.10, high: 0.24, radius: 0.985, sharpness: 0.12},
            {op: "multiplyLand", factor: 0.80},
            {op: "strait", width: 5, xNorm: 0.5, y1Norm: 0.2, y2Norm: 0.8},
            {op: "smooth", passes: 1},
            {op: "pits", count: 5, depth: -0.16, radius: 0.986},
            {op: "troughs", count: 3, depth: -0.10, radius: 0.99},
            {op: "multiplyLand", factor: 0.85},
            {op: "add", value: 0.02}
          ]
        },

        archipelago: {
          name: "Archipelago",
          description: "A lot of small islands",
          steps: [
            {op: "mountain", at: "center", high: 0.78, radius: 0.95, sharpness: 0.16},
            {op: "addLand", value: -0.02},
            {op: "hills", count: 15, distribution: 0.15, high: 0.14, radius: 0.986, sharpness: 0.11},
            {op: "troughs", count: 2, depth: -0.08, radius: 0.992},
            {op: "pits", count: 8, depth: -0.12, radius: 0.989},
            {op: "addLand", value: -0.05},
            {op: "multiplyLand", factor: 0.92}
          ]
        }
      };

      // Mulberry32 seeded random number generator
      function mulberry32(seed) {
        return function() {
          seed = seed + 0x6D2B79F5 | 0;
          let t = Math.imul(seed ^ seed >>> 15, 1 | seed);
          t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
          return ((t ^ t >>> 14) >>> 0) / 4294967296;
        };
      }

      // Simple hash function for template seeding
      function hash(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
          const char = str.charCodeAt(i);
          hash = ((hash << 5) - hash) + char;
          hash = hash & hash; // Convert to 32bit integer
        }
        return hash;
      }

      // Auto-generate: center island + N small hills
      ProgressManager.setPhase('terrain');
      autoSeed(worldSeed);
      // Apply the water-border mask (keeps edges water)
      applyBorderMask();
      
      // Erosion passes: smooth jaggy ridges and improve drainage
      ProgressManager.setPhase('erosion');
      const talus = +document.getElementById('talusInput').value || 0.02;
      const thermalStrength = +document.getElementById('thermalStrengthInput').value || 0.5;
      const smoothAlpha = +document.getElementById('smoothAlphaInput').value || 0.2;
      thermalErode(talus, thermalStrength, 2);
      smoothLand(smoothAlpha);
      
      // Mark terrain as dirty for canvas rendering
      TerrainCanvas.setDirty();
      
      // initial recolor according to current UI (also draws coastlines)
      ProgressManager.setPhase('rivers');
      recolor();
      
      // Hide progress overlay when complete
      ProgressManager.setPhase('final');
      setTimeout(() => {
        ProgressManager.hide();
      }, 1000); // Increased delay to 1 second so you can see the completion

      function relaxOnce(pts, w, h) {
        const dly = d3.Delaunay.from(pts);
        const vor = dly.voronoi([0, 0, w, h]);
        const relaxed = pts.map((_, i) => d3.polygonCentroid(vor.cellPolygon(i)));
        return { sites: relaxed };
      }

      function addWithOpts(start, type, opts, rand = Math.random) {
        // temporarily override sliders
        const prev = {
          high: +highInput.value,
          rad: +radiusInput.value,
          sharp: +sharpnessInput.value
        };
        if (opts && typeof opts.high === 'number') { highInput.value = opts.high; highOutput.value = opts.high; }
        if (opts && typeof opts.radius === 'number') { radiusInput.value = opts.radius; radiusOutput.value = opts.radius; }
        if (opts && typeof opts.sharpness === 'number') { sharpnessInput.value = opts.sharpness; sharpnessOutput.value = opts.sharpness; }
        add(start, type, rand);
        // restore sliders
        highInput.value = prev.high; highOutput.value = prev.high;
        radiusInput.value = prev.rad; radiusOutput.value = prev.rad;
        sharpnessInput.value = prev.sharp; sharpnessOutput.value = prev.sharp;
      }

      function pickInteriorCell(marginPx, rand = Math.random) {
        // choose a cell whose centroid is at least marginPx from any edge
        const interior = cells.filter(c => Math.min(c.cx, c.cy, width - c.cx, height - c.cy) >= marginPx);
        if (interior.length === 0) return Math.floor(rand() * cells.length);
        const idx = Math.floor(rand() * interior.length);
        return interior[idx].index;
      }

      // --- Template Executor ---
      function applyTemplate(templateKey, uiVals, seed) {
        console.debug('Templates keys:', Object.keys(templates));
        const tpl = templates[templateKey];
        if (!tpl) {
          console.error(`Template '${templateKey}' not found`);
          return;
        }
        
        const rand = mulberry32(seed ^ hash(templateKey));
        const ctx = new Map(); // for named picks {as:"center"} → cell index
        const debugOps = document.getElementById('debugOpsInput')?.checked || false;
        
        // Calculate margin pixels for template operations
        const pct = (uiVals.borderPct || 8) / 100;
        const marginPx = Math.max(2, pct * Math.min(width, height));
        
        // Clear debug overlays if they exist
        if (debugOps) {
          d3.selectAll('.debug-op').remove();
        }
        
        const resolveCell = (spec) => {
          if (typeof spec === "string" && spec.startsWith("$")) return ctx.get(spec.slice(1));
          if (spec?.norm) return delaunay.find(spec.x * width, spec.y * height);
          // "where" selectors:
          const marginPx = Math.max(2, (uiVals.borderPct/100) * Math.min(width, height));
          if (spec?.type === "interior") return pickInteriorCell(marginPx, rand);
          if (spec?.type === "interiorEdgeBiased") return pickInteriorCell(Math.max(2, 0.5*marginPx), rand);
          if (spec?.type === "interiorPair") return [pickInteriorCell(marginPx, rand), pickInteriorCell(marginPx, rand)];
          return Math.floor(rand()*cells.length);
        };

        const doStep = (step) => {
          switch (step.op) {
            case "mountain": {
              const idx = pickInteriorCell(marginPx, rand);
              addWithOpts(idx, 'island', {high: step.high, radius: step.radius, sharpness: step.sharpness}, rand);
              if (debugOps) {
                const cell = cells[idx];
                svg.append('circle')
                  .attr('class', 'debug-op')
                  .attr('cx', cell.cx)
                  .attr('cy', cell.cy)
                  .attr('r', 8)
                  .attr('fill', 'red')
                  .attr('stroke', 'white')
                  .attr('stroke-width', 2);
              }
              break;
            }
            case "hills": {
              for (let i = 0; i < step.count; i++) {
                const idx = pickInteriorCell(marginPx * step.distribution, rand);
                addWithOpts(idx, 'hill', {high: step.high, radius: step.radius, sharpness: step.sharpness}, rand);
                if (debugOps) {
                  const cell = cells[idx];
                  svg.append('circle')
                    .attr('class', 'debug-op')
                    .attr('cx', cell.cx)
                    .attr('cy', cell.cy)
                    .attr('r', 4)
                    .attr('fill', 'green')
                    .attr('stroke', 'white')
                    .attr('stroke-width', 1);
                }
              }
              break;
            }
            case "ranges": {
              for (let i = 0; i < step.count; i++) {
                const a = pickInteriorCell(marginPx, rand);
                const b = pickInteriorCell(marginPx, rand);
                addMountainRange(a, b, step.high, step.radius);
                if (debugOps) {
                  const cellA = cells[a];
                  const cellB = cells[b];
                  svg.append('line')
                    .attr('class', 'debug-op')
                    .attr('x1', cellA.cx)
                    .attr('y1', cellA.cy)
                    .attr('x2', cellB.cx)
                    .attr('y2', cellB.cy)
                    .attr('stroke', 'orange')
                    .attr('stroke-width', 2)
                    .attr('stroke-dasharray', '5,5');
                }
              }
              break;
            }
            case "pits": {
              for (let i = 0; i < step.count; i++) {
                const idx = pickInteriorCell(marginPx, rand);
                addPit(idx, step.depth, step.radius);
                if (debugOps) {
                  const cell = cells[idx];
                  svg.append('circle')
                    .attr('class', 'debug-op')
                    .attr('cx', cell.cx)
                    .attr('cy', cell.cy)
                    .attr('r', 6)
                    .attr('fill', 'purple')
                    .attr('stroke', 'white')
                    .attr('stroke-width', 1);
                }
              }
              break;
            }
            case "troughs": {
              for (let i = 0; i < step.count; i++) {
                const a = pickInteriorCell(marginPx, rand);
                const b = pickInteriorCell(marginPx, rand);
                addTrough(a, b, step.depth, step.radius);
                if (debugOps) {
                  const cellA = cells[a];
                  const cellB = cells[b];
                  svg.append('line')
                    .attr('class', 'debug-op')
                    .attr('x1', cellA.cx)
                    .attr('y1', cellA.cy)
                    .attr('x2', cellB.cx)
                    .attr('y2', cellB.cy)
                    .attr('stroke', 'brown')
                    .attr('stroke-width', 3)
                    .attr('stroke-dasharray', '3,3');
                }
              }
              break;
            }
            case "strait": {
              addStrait(step.xNorm*width, step.y1Norm*height, step.y2Norm*height, step.width, rand);
              if (debugOps) {
                svg.append('line')
                  .attr('class', 'debug-op')
                  .attr('x1', step.xNorm*width)
                  .attr('y1', step.y1Norm*height)
                  .attr('x2', step.xNorm*width)
                  .attr('y2', step.y2Norm*height)
                  .attr('stroke', 'cyan')
                  .attr('stroke-width', step.width)
                  .attr('stroke-dasharray', '2,2');
              }
              break;
            }
            case "add": {
              // Add value to all cells
              cells.forEach(c => { c.high = Math.min(1, Math.max(0, c.high + step.value)); });
              break;
            }
            case "addLand": {
              // Add value only to land cells (above sea level)
              const sea = +document.getElementById('seaLevelInput').value;
              cells.forEach(c => { 
                if (c.high > sea) {
                  c.high = Math.min(1, Math.max(0, c.high + step.value)); 
                }
              });
              break;
            }
            case "multiply": {
              // Multiply all cells by factor
              cells.forEach(c => { c.high = Math.min(1, Math.max(0, c.high * step.factor)); });
              break;
            }
            case "multiplyLand": {
              // Multiply only land cells by factor
              const sea = +document.getElementById('seaLevelInput').value;
              cells.forEach(c => { 
                if (c.high > sea) {
                  c.high = Math.min(1, Math.max(0, c.high * step.factor)); 
                }
              });
              break;
            }
            case "smooth": {
              for (let i=0; i<(step.passes||1); i++) smoothMap();
              break;
            }
            // Legacy operations for backward compatibility
            case "pickCell": {
              const idx = resolveCell(step.where);
              ctx.set(step.as, idx);
              break;
            }
            case "addBump": {
              const idx = resolveCell(step.at);
              addWithOpts(idx, step.kind, {high:step.high, radius:step.radius, sharpness:step.sharpness}, rand);
              break;
            }
            case "addBumpAt": {
              const idx = resolveCell(step.where);
              addWithOpts(idx, step.kind, {high:step.high, radius:step.radius, sharpness:step.sharpness}, rand);
              break;
            }
            case "addRange": {
              const a = resolveCell(step.from);
              const b = resolveCell(step.to);
              addMountainRange(a, b, step.max, step.radius);
              break;
            }
            case "addPit": {
              const idx = resolveCell(step.at);
              addPit(idx, step.depth, step.radius);
              break;
            }
            case "addPitAt": {
              const idx = resolveCell(step.where);
              addPit(idx, step.depth, step.radius);
              break;
            }
            case "addTroughBetween": {
              const [a, b] = resolveCell(step.where);
              addTrough(a, b, step.depth, step.radius);
              break;
            }
            case "addStrait": {
              addStrait(step.xNorm*width, step.y1Norm*height, step.y2Norm*height, step.width, rand);
              break;
            }
            case "scaleLand": {
              cells.forEach(c => { if (c.high > step.low) c.high = step.low + (c.high - step.low) * step.factor; });
              break;
            }
            case "biasAll": {
              cells.forEach(c => { c.high = Math.min(1, Math.max(0, c.high + step.add)); });
              break;
            }
            case "repeat": {
              const times = typeof step.times === "function" ? step.times(uiVals) : step.times;
              for (let i=0; i<times; i++) doStep(step.step);
              break;
            }
          }
        };

        tpl.steps.forEach(doStep);
      }

      function autoSeed(providedSeed = null) {
        const tplKey = document.getElementById('worldType').value;
        const seedInput = document.getElementById('seedInput').value;
        // Use provided seed if available, otherwise use input or generate random
        const worldSeed = providedSeed || (seedInput ? +seedInput : Math.floor(Math.random() * 999999) + 1);
        
        // Update the seed input to show the current seed (if it was random)
        if (!seedInput && !providedSeed) {
          document.getElementById('seedInput').value = worldSeed;
        }
        const uiVals = {
          smallCount: +smallCountInput.value,
          borderPct: +borderPctInput.value
        };
        
        // Clear the heightmap first
        cells.forEach(c => c.high = 0);
        
        // Apply the selected template
        applyTemplate(tplKey, uiVals, worldSeed);
        
        // Redraw everything
        if (window.__state.recolor) {
          window.__state.recolor();
        }
      }
      

      
      function addMountainRange(startIdx, endIdx, maxHeight, radius) {
        const start = cells[startIdx];
        const end = cells[endIdx];
        const steps = 12;
        
        for (let i = 0; i <= steps; i++) {
          const t = i / steps;
          const x = start.cx + (end.cx - start.cx) * t;
          const y = start.cy + (end.cy - start.cy) * t;
          const targetIdx = delaunay.find(x, y);
          addWithOpts(targetIdx, 'hill', { high: maxHeight * (1 - Math.abs(t - 0.5) * 0.4), radius: radius, sharpness: 0.15 });
        }
      }
      
      function addStrait(centerX, startY, endY, width, rand = Math.random) {
        const steps = 20;
        for (let i = 0; i <= steps; i++) {
          const t = i / steps;
          const y = startY + (endY - startY) * t;
          const x = centerX + (rand() - 0.5) * width * 20; // Add some randomness
          const targetIdx = delaunay.find(x, y);
          if (targetIdx >= 0 && targetIdx < cells.length) {
            cells[targetIdx].high = Math.max(0.05, cells[targetIdx].high - 0.4);
          }
        }
      }
      
      function addPit(centerIdx, depth, radius) {
        const center = cells[centerIdx];
        const queue = [];
        cells[centerIdx].high = Math.max(0.05, cells[centerIdx].high - depth);
        queue.push(centerIdx);
        
        for (let i = 0; i < queue.length && depth > 0.01; i++) {
          depth = depth * radius;
          cells[queue[i]].neighbors.forEach((e) => {
            if (!cells[e].used) {
              cells[e].high = Math.max(0.05, cells[e].high - depth);
              cells[e].used = 1;
              queue.push(e);
            }
          });
        }
        cells.forEach(c => c.used = 0);
      }
      
      function addTrough(startIdx, endIdx, depth, radius) {
        const start = cells[startIdx];
        const end = cells[endIdx];
        const steps = 8;
        
        for (let i = 0; i <= steps; i++) {
          const t = i / steps;
          const x = start.cx + (end.cx - start.cx) * t;
          const y = start.cy + (end.cy - start.cy) * t;
          const targetIdx = delaunay.find(x, y);
          if (targetIdx >= 0 && targetIdx < cells.length) {
            cells[targetIdx].high = Math.max(0.05, cells[targetIdx].high - depth);
          }
        }
      }
      
      function smoothMap() {
        const smoothed = new Float32Array(cells.length);
        cells.forEach((c, i) => {
          let sum = c.high;
          let count = 1;
          c.neighbors.forEach(nb => {
            sum += cells[nb].high;
            count++;
          });
          smoothed[i] = sum / count;
        });
        cells.forEach((c, i) => {
          c.high = smoothed[i];
        });
      }

      // Erosion functions for terrain smoothing
      function isLand(i) {
        return cells[i].high > 0.1; // Sea level threshold
      }

      function thermalErode(talus = 0.02, k = 0.5, iters = 2) {
        const n = cells.length;
        for (let t = 0; t < iters; t++) {
          const delta = new Float32Array(n);
          for (let i = 0; i < n; i++) {
            const hi = cells[i].high;
            if (!isLand(i)) continue;
            for (const j of cells[i].neighbors) {
              const d = hi - cells[j].high - talus;
              if (d > 0) {
                const m = k * d * 0.5;
                delta[i] -= m;
                delta[j] += m;
              }
            }
          }
          for (let i = 0; i < n; i++) {
            cells[i].high = Math.max(0, cells[i].high + delta[i]);
          }
        }
      }

      function smoothLand(alpha = 0.2) {
        const n = cells.length;
        const out = new Float32Array(n);
        for (let i = 0; i < n; i++) {
          if (!isLand(i)) {
            out[i] = cells[i].high;
            continue;
          }
          let s = 0;
          for (const j of cells[i].neighbors) {
            s += cells[j].high;
          }
          out[i] = (1 - alpha) * cells[i].high + alpha * (s / cells[i].neighbors.length);
        }
        cells.forEach((c, i) => {
          c.high = out[i];
        });
      }

      // Expose autoSeed to window for tests
      window.autoSeed = autoSeed;

      function add(start, type, rand = Math.random) {
        // get options from sliders
        let high = +highInput.value;
        const radius = +radiusInput.value;
        const sharpness = +sharpnessInput.value;
        const queue = [];

        cells[start].high += high;
        cells[start].used = 1;
        queue.push(start);

        for (let i = 0; i < queue.length && high > 0.01; i++) {
          if (type === 'island') {
            high = cells[queue[i]].high * radius;
          } else {
            high = high * radius;
          }
          cells[queue[i]].neighbors.forEach((e) => {
            if (!cells[e].used) {
              let mod = rand() * sharpness + 1.1 - sharpness;
              if (sharpness === 0) mod = 1;
              cells[e].high += high * mod;
              if (cells[e].high > 1) cells[e].high = 1;
              cells[e].used = 1;
              queue.push(e);
            }
          });
        }
        // reset used flags
        cells.forEach(c => c.used = 0);
      }

      function applyBorderMask() {
        const pct = (+borderPctInput.value) / 100;
        const marginPx = Math.max(2, pct * Math.min(width, height));
        window.__state.borderPx = marginPx;
        // Smoothstep helper
        const clamp01 = (v) => v < 0 ? 0 : v > 1 ? 1 : v;
        const smooth = (v) => { v = clamp01(v); return v * v * (3 - 2 * v); };
        cells.forEach(c => {
          const distEdge = Math.min(c.cx, c.cy, width - c.cx, height - c.cy);
          const mask = smooth(distEdge / marginPx);
          c.high *= mask; // damp heights near the border to guarantee water frame
        });
      }

      // --- Lakes & basins (depression detection + spill level) ---
      function computeLakes(sea) {
        const N = cells.length;
        const isLake = new Uint8Array(N);
        const lakeId = new Int32Array(N); lakeId.fill(-1);
        const downSteep = new Int32Array(N); downSteep.fill(-1);
        const up = Array.from({length: N}, () => []);
        const landIdxs = [];
        for (let i = 0; i < N; i++) {
          if (cells[i].high >= sea) {
            landIdxs.push(i);
            let bestH = cells[i].high, best = -1;
            const nbs = cells[i].neighbors;
            for (let k = 0; k < nbs.length; k++) {
              const nb = nbs[k];
              const hh = cells[nb].high;
              if (hh < bestH) { bestH = hh; best = nb; }
            }
            if (best !== -1) { downSteep[i] = best; up[best].push(i); }
          }
        }
        const visited = new Uint8Array(N);
        const lakes = [];
        for (let sIdx = 0; sIdx < landIdxs.length; sIdx++) {
          const s = landIdxs[sIdx];
          if (visited[s] || downSteep[s] !== -1) continue; // only sinks
          // collect basin by traversing upstream graph
          const basin = []; const stack = [s]; visited[s] = 1; const basinSet = new Set();
          while (stack.length) {
            const v = stack.pop();
            basin.push(v); basinSet.add(v);
            const ups = up[v] || [];
            for (let t = 0; t < ups.length; t++) { const u = ups[t]; if (!visited[u]) { visited[u] = 1; stack.push(u); } }
          }
          // compute spill (lowest outside neighbor)
          let spill = Infinity; let outlet = -1;
          for (let bi = 0; bi < basin.length; bi++) {
            const b = basin[bi];
            const nbs = cells[b].neighbors;
            for (let k = 0; k < nbs.length; k++) {
              const nb = nbs[k];
              if (!basinSet.has(nb)) {
                const hnb = cells[nb].high;
                if (hnb < spill) { spill = hnb; outlet = nb; }
              }
            }
          }
          if (spill > sea && spill < Infinity) {
            let lakeCells = 0; const id = lakes.length;
            let maxDepth = 0;
            
            // Count cells that would be underwater and find max depth
            for (let bi = 0; bi < basin.length; bi++) {
              const b = basin[bi];
              if (cells[b].high < spill) { 
                lakeCells++; 
                const depth = spill - cells[b].high;
                maxDepth = Math.max(maxDepth, depth);
              }
            }
            
            // Only create lakes that are significant in size and depth
            const minLakeCells = +document.getElementById('minLakeSizeInput').value || 3;
            const minLakeDepth = +document.getElementById('minLakeDepthInput').value || 0.05;
            
            if (lakeCells >= minLakeCells && maxDepth >= minLakeDepth) {
              for (let bi = 0; bi < basin.length; bi++) {
                const b = basin[bi];
                if (cells[b].high < spill) { isLake[b] = 1; lakeId[b] = id; }
              }
              lakes.push({ id, level: spill, outlet, size: lakeCells, depth: maxDepth });
            }
          }
        }
        const isWater = cells.map((c, i) => (c.high < sea) || (isLake[i] === 1));
        window.__state.isLake = isLake;
        window.__state.lakeId = lakeId;
        window.__state.lakes = lakes;
        window.__state.isWater = isWater;
        return { isLake, lakeId, lakes, isWater };
      }

      function recolor() {
        const sea = +document.getElementById('seaLevelInput').value;
        const renderMode = document.getElementById('renderMode').value;
        const shadingMode = document.getElementById('shadingMode').value;
        
        // recompute lakes with current sea level and expose water mask
        computeLakes(sea);
        const isWater = window.__state.isWater || [];
        
        // Compute distance-to-water field for burg placement optimization
        const width = +svg.attr('width');
        const height = +svg.attr('height');
        window.__state.distToWater = computeDistanceToWater(isWater, width, height);
        
        // Compute climate and biomes if needed
        if (renderMode === 'biomes' || renderMode === 'hybrid') {
          computeClimate(sea);
        }
        
        // Compute shading if enabled
        const shades = shadingMode === 'shaded' ? computeShading(cells, sea) : null;
        
        // Check if we're using canvas rendering
        const isCoarse = window.matchMedia('(pointer: coarse)').matches;
        const useCanvas = isCoarse ? cells.length > 4000 : cells.length > 8000;
        
        if (useCanvas && TerrainCanvas.isDirty()) {
          // Re-render canvas for large maps
          TerrainCanvas.canvas.width = width;
          TerrainCanvas.canvas.height = height;
          
          cells.forEach(cell => {
            if (isWater[cell.index]) {
              // Skip water cells - they're handled by ocean backdrop
              return;
            }
            
            let baseColor;
            if (renderMode === 'biomes' || renderMode === 'hybrid') {
              baseColor = getBiomeColor(cell.biome, cell.high, sea);
            } else {
              const tl = (cell.high - sea) / Math.max(1 - sea, 0.0001);
              const tt = Math.max(0, Math.min(1, tl));
              baseColor = landColor(tt);
            }
            
            if (shadingMode === 'shaded' && shades) {
              baseColor = shadeColor(baseColor, shades[cell.index]);
            }
            
            // Draw cell on canvas
            TerrainCanvas.ctx.fillStyle = baseColor;
            if (cell.poly.length > 2) {
              TerrainCanvas.ctx.beginPath();
              TerrainCanvas.ctx.moveTo(cell.poly[0][0], cell.poly[0][1]);
              for (let i = 1; i < cell.poly.length; i++) {
                TerrainCanvas.ctx.lineTo(cell.poly[i][0], cell.poly[i][1]);
              }
              TerrainCanvas.ctx.closePath();
              TerrainCanvas.ctx.fill();
            }
          });
          
          // Update canvas image in SVG
          const dataURL = TerrainCanvas.canvas.toDataURL();
          mapCells.select('image').attr('href', dataURL);
          TerrainCanvas.markClean();
        } else if (!useCanvas) {
          // SVG-based rendering for smaller maps
          // Only render individual cells if we don't have unified land paths
          if (!window.__state.landPaths || window.__state.landPaths.length === 0) {
            mapCells.selectAll('path.mapCell')
              .attr('fill', d => {
                if (isWater[d.index]) {
                  return 'none';
                } else {
                  let baseColor;
                  if (renderMode === 'biomes' || renderMode === 'hybrid') {
                    baseColor = getBiomeColor(d.biome, d.high, sea);
                  } else {
                    const tl = (d.high - sea) / Math.max(1 - sea, 0.0001);
                    const tt = Math.max(0, Math.min(1, tl));
                    baseColor = landColor(tt);
                  }
                  
                  if (shadingMode === 'shaded' && shades) {
                    return shadeColor(baseColor, shades[d.index]);
                  } else {
                    return baseColor;
                  }
                }
              })
              .style('fill', d => {
                if (isWater[d.index]) {
                  return 'none';
                } else {
                  let baseColor;
                  if (renderMode === 'biomes' || renderMode === 'hybrid') {
                    baseColor = getBiomeColor(d.biome, d.high, sea);
                  } else {
                    const tl = (d.high - sea) / Math.max(1 - sea, 0.0001);
                    const tt = Math.max(0, Math.min(1, tl));
                    baseColor = landColor(tt);
                  }
                  
                  if (shadingMode === 'shaded' && shades) {
                    return shadeColor(baseColor, shades[d.index]);
                  } else {
                    return baseColor;
                  }
                }
              });
          }
        }

        // Update unified land paths if they exist
        if (window.__state.landPaths && window.__state.landPaths.length > 0) {
          window.__state.landPaths.forEach(lp => {
            lp.path.attr('fill', 'none'); // don't paint over the heightmap
          });
        }
        
        // Update progress for each phase with detailed progress
        ProgressManager.setPhase('rivers');
        ProgressManager.update(60, 'Computing rivers...', 'Building river network...');
        
        // Small delay to ensure progress is visible
        setTimeout(() => {
        computeRivers();
          
          ProgressManager.setPhase('coastlines');
          ProgressManager.update(70, 'Drawing coastlines...', 'Processing coastline edges...');
          
          setTimeout(() => {
        drawCoastlines();
            
            ProgressManager.setPhase('burgs');
            ProgressManager.update(80, 'Placing settlements...', 'Scoring and placing burgs...');
            
            setTimeout(() => {
              generateBurgs();
              
              ProgressManager.setPhase('routes');
              ProgressManager.update(90, 'Building routes...', 'Computing road and sea networks...');
              
              setTimeout(() => {
                // Use debounced route computation to prevent double execution
                debouncedComputeRoutes();
              }, 100);
            }, 100);
          }, 100);
        }, 100);
        
        // Update the biome legend
        updateBiomeLegend();
      }

      // --- Shaded Relief and Hypsometric Tinting ---
      function estimateNormal(i, cells, H) {
        // simple gradient from neighbors
        let dx = 0, dy = 0;
        const ci = cells[i];
        for (const j of ci.neighbors) {
          const cj = cells[j];
          const dh = H[j] - H[i];
          dx += dh * (cj.cx - ci.cx);
          dy += dh * (cj.cy - ci.cy);
        }
        // normal pointing "up": N ≈ normalize([-dx, -dy, scale])
        const scale = 1.0; // simplified scale
        let nx = -dx, ny = -dy, nz = scale;
        const len = Math.hypot(nx, ny, nz);
        return [nx / len, ny / len, nz / len];
      }

      function shadeColor(color, shade) {
        let r, g, b;
        
        if (color.startsWith('rgb(')) {
          // Parse rgb(r, g, b) format
          const rgbMatch = color.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
          if (rgbMatch) {
            r = parseInt(rgbMatch[1]);
            g = parseInt(rgbMatch[2]);
            b = parseInt(rgbMatch[3]);
          } else {
            return color; // fallback if parsing fails
          }
        } else if (color.startsWith('#')) {
          // Parse hex format
          const hex = color.replace('#', '');
          r = parseInt(hex.substr(0, 2), 16);
          g = parseInt(hex.substr(2, 2), 16);
          b = parseInt(hex.substr(4, 2), 16);
        } else {
          return color; // fallback for unknown formats
        }
        
        const shadedR = Math.round(r * shade);
        const shadedG = Math.round(g * shade);
        const shadedB = Math.round(b * shade);
        
        return `rgb(${shadedR}, ${shadedG}, ${shadedB})`;
      }

      function computeShading(cells, sea) {
        const lightDir = [-0.5, -0.5, 1]; // Light direction
        const lightLen = Math.hypot(lightDir[0], lightDir[1], lightDir[2]);
        const normalizedLight = lightDir.map(v => v / lightLen);
        
        const H = cells.map(c => c.high);
        const shades = new Float32Array(cells.length);
        
        for (let i = 0; i < cells.length; i++) {
          if (cells[i].high >= sea) {
            // Only shade land cells
            const normal = estimateNormal(i, cells, H);
            const dot = normal[0] * normalizedLight[0] + 
                       normal[1] * normalizedLight[1] + 
                       normal[2] * normalizedLight[2];
            shades[i] = Math.max(0.25, dot); // 0.25 = ambient
          } else {
            shades[i] = 1.0; // No shading for water
          }
        }
        
        return shades;
      }

      // --- Export Functions ---
      function getUsedIds(svg) {
        const used = new Set();
        const ATTRS = [
          'fill', 'stroke', 'filter', 'clip-path', 'mask',
          'marker-start', 'marker-mid', 'marker-end', 'href', 'xlink:href'
        ];
        svg.querySelectorAll('*').forEach(el => {
          for (const a of ATTRS) {
            const v = el.getAttribute(a);
            if (!v) continue;
            // url(#id) or href="#id"
            const m1 = v.match(/url\(#([^)]+)\)/);
            if (m1) used.add(m1[1]);
            const m2 = v.match(/^#(.+)/);
            if (m2) used.add(m2[1]);
          }
        });
        return used;
      }

      function pruneDefs(defs, used) {
        defs.querySelectorAll('[id]').forEach(node => {
          if (!used.has(node.id)) node.remove();
        });
      }

      function ensureBackgroundOcean(svg, color) {
        // Remove any prior injected bg
        svg.querySelector('#_export_bg')?.remove();

        const vb = svg.viewBox && svg.viewBox.baseVal;
        const w = svg.getAttribute('width') || (vb ? vb.width : null);
        const h = svg.getAttribute('height') || (vb ? vb.height : null);
        if (!w || !h) return; // set width/height/viewBox upstream as you already do

        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        rect.setAttribute('id', '_export_bg');
        rect.setAttribute('x', '0');
        rect.setAttribute('y', '0');
        rect.setAttribute('width', w);
        rect.setAttribute('height', h);
        rect.setAttribute('fill', color);

        // Insert behind everything, but after <defs> if present
        const firstRenderable = [...svg.childNodes].find(n => n.nodeType === 1 && n.tagName !== 'defs');
        if (firstRenderable) svg.insertBefore(rect, firstRenderable);
        else svg.appendChild(rect);
      }

      function inlineSvgStyles(svg, preservePatterns = false) {
        const all = svg.querySelectorAll('*');

        for (const el of all) {
          const cs = getComputedStyle(el);

          const setPaint = (prop, attr) => {
            // Never overwrite explicit fill/stroke attributes that are already set
            if ((attr === 'fill' || attr === 'stroke') && el.hasAttribute(attr)) {
              return;
            }
            
            let v = cs[prop];

            // Preserve patterns for SVG export
            if (preservePatterns && v && v.startsWith('url(')) {
              el.setAttribute(attr, v);
              return;
            }

            // Normalize transparent cases
            if (!v || v === 'none') {
              el.setAttribute(attr, 'none');
              return;
            }
            if (v.startsWith('rgba(')) {
              const [, r, g, b, a] = v.match(/rgba?\((\d+),\s*(\d+),\s*(\d+),\s*([.\d]+)\)/) || [];
              if (!r) { el.setAttribute(attr, 'none'); return; }
              if (+a === 0) { el.setAttribute(attr, 'none'); return; } // **important**
              el.setAttribute(attr, `rgb(${r}, ${g}, ${b})`);
              el.setAttribute(attr + '-opacity', a);
              return;
            }
            if (v.startsWith('rgb(')) {
              el.setAttribute(attr, v);
              return;
            }

            // Handle keywords like 'none'
            if (v === 'transparent' || v === 'currentcolor') {
              el.setAttribute(attr, 'none');
            } else {
              // last resort
              el.setAttribute(attr, v);
            }
          };

          setPaint('fill', 'fill');
          setPaint('stroke', 'stroke');

          // Stroke details
          const sw = cs.strokeWidth; if (sw) el.setAttribute('stroke-width', sw);
          const slc = cs.strokeLinecap; if (slc) el.setAttribute('stroke-linecap', slc);
          const slj = cs.strokeLinejoin; if (slj) el.setAttribute('stroke-linejoin', slj);
          const sda = cs.strokeDasharray; if (sda && sda !== 'none') el.setAttribute('stroke-dasharray', sda);
          const sdo = cs.strokeDashoffset; if (sdo && sdo !== '0px') el.setAttribute('stroke-dashoffset', sdo);
          
          // Special handling for river elements to ensure they're visible
          if (el.classList && (el.classList.contains('rivers') || el.classList.contains('riversShade'))) {
            // Ensure river paths have proper stroke attributes
            if (!el.hasAttribute('stroke') && !el.style.stroke) {
              if (el.classList.contains('rivers')) {
                el.setAttribute('stroke', '#4D83AE');
              } else if (el.classList.contains('riversShade')) {
                el.setAttribute('stroke', 'rgba(0,0,0,0.35)');
              }
            }
            // Ensure river paths have stroke-width if not set
            if (!el.hasAttribute('stroke-width') && !el.style.strokeWidth) {
              el.setAttribute('stroke-width', '1');
            }
          }
          
          // Special handling for coastline elements to ensure they're visible
          if (el.classList && el.classList.contains('coast')) {
            // Ensure coastline paths have proper stroke attributes
            if (!el.hasAttribute('stroke') && !el.style.stroke) {
              el.setAttribute('stroke', '#111');
            }
            // Ensure coastline paths have stroke-width if not set
            if (!el.hasAttribute('stroke-width') && !el.style.strokeWidth) {
              el.setAttribute('stroke-width', '0.6px');
            }
            // Ensure coastline paths have stroke-linejoin if not set
            if (!el.hasAttribute('stroke-linejoin') && !el.style.strokeLinejoin) {
              el.setAttribute('stroke-linejoin', 'round');
            }
          }
          
          // Special handling for burg elements to ensure they're visible
          if (el.classList && el.classList.contains('burg')) {
            // Burg groups don't need special handling, but their children do
          }
          
          // Special handling for burg circles
          if (el.tagName === 'circle' && el.parentElement && el.parentElement.classList && el.parentElement.classList.contains('burg')) {
            // Ensure burg circles have proper attributes
            if (!el.hasAttribute('fill') && !el.style.fill) {
              el.setAttribute('fill', '#ff0000');
            }
            if (!el.hasAttribute('stroke') && !el.style.stroke) {
              el.setAttribute('stroke', '#fff');
            }
            if (!el.hasAttribute('stroke-width') && !el.style.strokeWidth) {
              el.setAttribute('stroke-width', '0.6');
            }
            if (!el.hasAttribute('paint-order') && !el.style.paintOrder) {
              el.setAttribute('paint-order', 'stroke fill');
            }
            if (!el.hasAttribute('vector-effect') && !el.style.vectorEffect) {
              el.setAttribute('vector-effect', 'non-scaling-stroke');
            }
          }
          
          // Special handling for burg port rectangles
          if (el.tagName === 'rect' && el.parentElement && el.parentElement.classList && el.parentElement.classList.contains('burg')) {
            // Ensure port rectangles have proper attributes
            if (!el.hasAttribute('fill') && !el.style.fill) {
              el.setAttribute('fill', '#4D83AE');
            }
            if (!el.hasAttribute('stroke') && !el.style.stroke) {
              el.setAttribute('stroke', '#fff');
            }
            if (!el.hasAttribute('stroke-width') && !el.style.strokeWidth) {
              el.setAttribute('stroke-width', '0.3');
            }
            if (!el.hasAttribute('paint-order') && !el.style.paintOrder) {
              el.setAttribute('paint-order', 'stroke fill');
            }
            if (!el.hasAttribute('vector-effect') && !el.style.vectorEffect) {
              el.setAttribute('vector-effect', 'non-scaling-stroke');
            }
          }
          
          // Special handling for route paths
          if (el.tagName === 'path' && el.parentElement && el.parentElement.parentElement && el.parentElement.parentElement.id === 'routes') {
            const routeType = el.parentElement.className.baseVal;
            
            if (routeType === 'roads') {
              if (!el.hasAttribute('stroke') && !el.style.stroke) {
                el.setAttribute('stroke', '#6b4e16');
              }
              if (!el.hasAttribute('stroke-width') && !el.style.strokeWidth) {
                el.setAttribute('stroke-width', '1.2px');
              }
            } else if (routeType === 'trails') {
              if (!el.hasAttribute('stroke') && !el.style.stroke) {
                el.setAttribute('stroke', '#9b7b3a');
              }
              if (!el.hasAttribute('stroke-width') && !el.style.strokeWidth) {
                el.setAttribute('stroke-width', '0.8px');
              }
              if (!el.hasAttribute('stroke-dasharray') && !el.style.strokeDasharray) {
                el.setAttribute('stroke-dasharray', '3 3');
              }
            } else if (routeType === 'searoutes') {
              if (!el.hasAttribute('stroke') && !el.style.stroke) {
                el.setAttribute('stroke', '#ffffff');
              }
              if (!el.hasAttribute('stroke-width') && !el.style.strokeWidth) {
                el.setAttribute('stroke-width', '1.0px');
              }
              if (!el.hasAttribute('stroke-dasharray') && !el.style.strokeDasharray) {
                el.setAttribute('stroke-dasharray', '6 3');
              }
              if (!el.hasAttribute('opacity') && !el.style.opacity) {
                el.setAttribute('opacity', '0.9');
              }
            }
            
            // Common route attributes
            if (!el.hasAttribute('fill') && !el.style.fill) {
              el.setAttribute('fill', 'none');
            }
            if (!el.hasAttribute('stroke-linecap') && !el.style.strokeLinecap) {
              el.setAttribute('stroke-linecap', 'round');
            }
            if (!el.hasAttribute('stroke-linejoin') && !el.style.strokeLinejoin) {
              el.setAttribute('stroke-linejoin', 'round');
            }
            if (!el.hasAttribute('vector-effect') && !el.style.vectorEffect) {
              el.setAttribute('vector-effect', 'non-scaling-stroke');
            }
          }

          // Opacities (element-level)
          const op = cs.opacity; if (op && op !== '1') el.setAttribute('opacity', op);

          // Text extras
          const fw = cs.fontWeight; if (fw) el.setAttribute('font-weight', fw);
          const fs = cs.fontSize; if (fs) el.setAttribute('font-size', fs);
          const ff = cs.fontFamily; if (ff) el.setAttribute('font-family', ff);

          const po = cs.paintOrder; if (po && po !== 'normal') el.setAttribute('paint-order', po);
        }
      }

      function saveSVG(svgNode, filename = 'map.svg') {
        // Ensure the map is properly colored before export
        if (window.__state.recolor) {
          window.__state.recolor();
        }
        
        // Debug: Check if rivers exist before export
        const originalRivers = svgNode.querySelectorAll('g.rivers path, g.riversShade path');
        console.log(`Original rivers before export: ${originalRivers.length} paths`);
        if (originalRivers.length === 0) {
          console.log('No rivers found! Computing rivers...');
          if (window.__state.computeRoutes) {
            window.__state.computeRoutes();
          }
        }
        
        // Debug: Check if coastlines exist before export
        const originalCoastlines = svgNode.querySelectorAll('g.coastline path.coast');
        console.log(`Original coastlines before export: ${originalCoastlines.length} paths`);
        if (originalCoastlines.length === 0) {
          console.log('No coastlines found! Computing coastlines...');
          if (window.__state.drawCoastlines) {
            window.__state.drawCoastlines();
            // Check again after computing
            const newCoastlines = svgNode.querySelectorAll('g.coastline path.coast');
            console.log(`Coastlines after computing: ${newCoastlines.length} paths`);
          }
        }
        
        // Debug: Check if burgs exist before export
        const originalBurgs = svgNode.querySelectorAll('#burgs g.burg');
        console.log(`Original burgs before export: ${originalBurgs.length} burgs`);
        if (originalBurgs.length === 0) {
          console.log('No burgs found! Computing burgs...');
          if (window.__state.generateBurgs) {
            window.__state.generateBurgs();
            // Check again after computing
            const newBurgs = svgNode.querySelectorAll('#burgs g.burg');
            console.log(`Burgs after computing: ${newBurgs.length} burgs`);
          }
        }
        
        // Debug: Check if routes exist before export
        const originalRoutes = svgNode.querySelectorAll('#routes path');
        console.log(`Original routes before export: ${originalRoutes.length} routes`);
        if (originalRoutes.length === 0) {
          console.log('No routes found! Computing routes...');
          if (window.__state.computeRoutes) {
            window.__state.computeRoutes();
            // Check again after computing
            const newRoutes = svgNode.querySelectorAll('#routes path');
            console.log(`Routes after computing: ${newRoutes.length} routes`);
          }
        }
        
        const clone = svgNode.cloneNode(true);
        
        // Ensure ocean background is properly set
        const oceanRect = clone.querySelector('rect.ocean');
        if (oceanRect) {
          oceanRect.setAttribute('fill', WATER_COLOR);
          oceanRect.setAttribute('style', `fill: ${WATER_COLOR}`);
          console.log(`Ocean rect found and styled with color: ${WATER_COLOR}`);
        } else {
          console.log('No ocean rect found in clone!');
        }
        
        // Inline computed styles to ensure colors are preserved in export (preserve patterns)
        inlineSvgStyles(clone, true);
        
        // Prune unused defs but keep referenced ones
        const defs = clone.querySelector('defs');
        if (defs) {
          const usedIds = getUsedIds(clone);
          pruneDefs(defs, usedIds);
        }
        
        // Debug: Check what fills we have after inlining
        const allCells = clone.querySelectorAll('path.mapCell');
        let blackCells = 0, coloredCells = 0, noneCells = 0;
        allCells.forEach(cell => {
          const fill = cell.getAttribute('fill');
          if (fill === '#000' || fill === 'black') blackCells++;
          else if (fill === 'none') noneCells++;
          else coloredCells++;
        });
        console.log(`Export debug after inlining - Black: ${blackCells}, Colored: ${coloredCells}, None: ${noneCells}`);
        
        // Debug: Check SVG structure
        console.log('SVG clone structure:', clone.innerHTML.substring(0, 500) + '...');
        console.log('Ocean rect in clone:', clone.querySelector('rect.ocean')?.outerHTML);
        
        // Debug: Check river elements
        const riverGroups = clone.querySelectorAll('g.rivers, g.riversShade');
        console.log(`Found ${riverGroups.length} river groups in clone:`, riverGroups);
        riverGroups.forEach((group, i) => {
          const paths = group.querySelectorAll('path');
          console.log(`River group ${i} (${group.className.baseVal}): ${paths.length} paths`);
          if (paths.length > 0) {
            console.log('Sample river path:', paths[0].outerHTML);
          }
        });
        
        // Debug: Check coastline elements
        const coastlineGroups = clone.querySelectorAll('g.coastline');
        console.log(`Found ${coastlineGroups.length} coastline groups in clone:`, coastlineGroups);
        coastlineGroups.forEach((group, i) => {
          const paths = group.querySelectorAll('path.coast');
          console.log(`Coastline group ${i} (${group.className.baseVal}): ${paths.length} paths`);
          if (paths.length > 0) {
            console.log('Sample coastline path:', paths[0].outerHTML);
          }
        });
        
        // Debug: Check burg elements
        const burgGroups = clone.querySelectorAll('#burgs');
        console.log(`Found ${burgGroups.length} burg groups in clone:`, burgGroups);
        burgGroups.forEach((group, i) => {
          const burgs = group.querySelectorAll('g.burg');
          console.log(`Burg group ${i}: ${burgs.length} burgs`);
          if (burgs.length > 0) {
            console.log('Sample burg:', burgs[0].outerHTML);
          }
        });
        
        // Debug: Check route elements
        const routeGroups = clone.querySelectorAll('#routes');
        console.log(`Found ${routeGroups.length} route groups in clone:`, routeGroups);
        routeGroups.forEach((group, i) => {
          const roads = group.querySelectorAll('.roads path');
          const trails = group.querySelectorAll('.trails path');
          const seaRoutes = group.querySelectorAll('.searoutes path');
          console.log(`Route group ${i}: ${roads.length} roads, ${trails.length} trails, ${seaRoutes.length} sea routes`);
          if (roads.length > 0) {
            console.log('Sample road:', roads[0].outerHTML);
          }
        });
        
        // ensure inline styles/fonts if needed
        const svgText = new XMLSerializer().serializeToString(clone);
        const blob = new Blob([svgText], {type: 'image/svg+xml;charset=utf-8'});
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = filename;
        a.click();
        URL.revokeObjectURL(a.href);
      }

      async function savePNG(svgNode, w, h, filename = 'map.png') {
        // Ensure the map is properly colored before export
        if (window.__state.recolor) {
          window.__state.recolor();
        }
        
        // Debug: Check if coastlines exist before export
        const originalCoastlines = svgNode.querySelectorAll('g.coastline path.coast');
        console.log(`Original coastlines before PNG export: ${originalCoastlines.length} paths`);
        if (originalCoastlines.length === 0) {
          console.log('No coastlines found! Computing coastlines...');
          if (window.__state.drawCoastlines) {
            window.__state.drawCoastlines();
            // Check again after computing
            const newCoastlines = svgNode.querySelectorAll('g.coastline path.coast');
            console.log(`Coastlines after computing: ${newCoastlines.length} paths`);
          }
        }
        
        // Debug: Check if burgs exist before export
        const originalBurgs = svgNode.querySelectorAll('#burgs g.burg');
        console.log(`Original burgs before PNG export: ${originalBurgs.length} burgs`);
        if (originalBurgs.length === 0) {
          console.log('No burgs found! Computing burgs...');
          if (window.__state.generateBurgs) {
            window.__state.generateBurgs();
            // Check again after computing
            const newBurgs = svgNode.querySelectorAll('#burgs g.burg');
            console.log(`Burgs after computing: ${newBurgs.length} burgs`);
          }
        }
        
        // Debug: Check if routes exist before export
        const originalRoutes = svgNode.querySelectorAll('#routes path');
        console.log(`Original routes before PNG export: ${originalRoutes.length} routes`);
        if (originalRoutes.length === 0) {
          console.log('No routes found! Computing routes...');
          if (window.__state.computeRoutes) {
            window.__state.computeRoutes();
            // Check again after computing
            const newRoutes = svgNode.querySelectorAll('#routes path');
            console.log(`Routes after computing: ${newRoutes.length} routes`);
          }
        }
        
        // Create a clone and prepare for canvas rasterization
        const clone = svgNode.cloneNode(true);
        
        // Add namespaces and explicit size for canvas rendering
        clone.setAttribute("xmlns", "http://www.w3.org/2000/svg");
        clone.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink");
        clone.setAttribute("width", `${w}`);
        clone.setAttribute("height", `${h}`);
        if (!clone.getAttribute("viewBox")) {
          clone.setAttribute("viewBox", `0 0 ${w} ${h}`);
        }
        
        // Inline computed styles to ensure colors are preserved in export (raster-safe)
        inlineSvgStyles(clone, false);
        
        // Remove problematic attributes that can break canvas rendering (restrict to render tree)
        clone.querySelectorAll(':not(defs) [filter]').forEach(n => n.removeAttribute('filter'));
        clone.querySelectorAll('[mask]').forEach(n => n.removeAttribute('mask'));
        clone.querySelectorAll('[mix-blend-mode],[style*="mix-blend-mode"]').forEach(n => {
          n.style.mixBlendMode = '';
        });
        
        // Handle any paint servers (url references) by forcing solid fills
        clone.querySelectorAll('[fill^="url("], [stroke^="url("]').forEach(el => {
          const paint = getComputedStyle(el).fill;
          el.setAttribute('fill', paint && paint !== 'none' ? paint : WATER_COLOR);
        });
        
        // Add solid background ocean for raster-safe export
        const oceanEl = clone.querySelector('#oceanBase, .ocean, [data-layer="ocean"]');
        let oceanColor = WATER_COLOR;
        if (oceanEl) {
          const f = getComputedStyle(oceanEl).fill;
          if (f && f.startsWith('rgb(')) oceanColor = f;
        }
        ensureBackgroundOcean(clone, oceanColor);
        
        // Remove unused defs if nothing references them
        if (!clone.querySelector('[fill^="url("],[stroke^="url("],[filter],[mask]')) {
          const defs = clone.querySelector('defs');
          if (defs) defs.remove();
        }
        
        const svgText = new XMLSerializer().serializeToString(clone);
        const svgUrl = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svgText);
        const img = new Image();
        img.crossOrigin = 'anonymous';
        
        await new Promise(resolve => {
          img.onload = resolve;
          img.src = svgUrl;
        });
        
        const canvas = document.createElement('canvas');
        canvas.width = w;
        canvas.height = h;
        const ctx = canvas.getContext('2d');
        
        // Draw the SVG image (background is already included in SVG)
        ctx.drawImage(img, 0, 0, w, h);
        
        canvas.toBlob(blob => {
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = filename;
          
          // iOS-friendly export: open in new tab if download is blocked
          try {
            a.click();
          } catch (e) {
            // Fallback for iOS: open data URL in new tab
            const dataURL = canvas.toDataURL('image/png');
            const newWindow = window.open();
            if (newWindow) {
              newWindow.document.write(`<img src="${dataURL}" alt="Map Export" style="max-width: 100%; height: auto;">`);
              newWindow.document.title = filename;
            }
          }
          
          URL.revokeObjectURL(a.href);
        }, 'image/png');
      }

      // Expose export functions globally
      window.saveSVG = saveSVG;
      window.savePNG = savePNG;

      // --- Climate and Biome System ---
      function computeClimate(sea) {
        const baseTempF = +document.getElementById('baseTempInput').value;
        const baseTempC = (baseTempF - 32) * 5/9; // Convert F to C
        const maxElevation_m = 2000; // meters
        const lapseRate = 6.5; // °C per 1000m
        
        // Compute temperature and precipitation for each cell
        cells.forEach(c => {
          // Temperature based on elevation
          const elevRatio = Math.max(0, c.high - sea) / (1 - sea);
          const elevation_m = elevRatio * maxElevation_m;
          c.temp = baseTempC - (elevation_m * lapseRate / 1000);
          
          // Precipitation (reuse existing model)
          c.precip = 0; // Will be set by computePrecipArray
        });
        
        // Get precipitation values and scale them
        const precipArray = computePrecipArray();
        const precipScale = +document.getElementById('precipScaleInput').value || 0.5;
        cells.forEach((c, i) => {
          c.precip = precipArray[i] * precipScale;
        });
        
        // Classify biomes
        cells.forEach(c => {
          c.biome = classifyBiome(c, sea);
        });
        
        // Debug: Log temperature and precipitation ranges
        const landCells = cells.filter(c => c.high >= sea);
        if (landCells.length > 0) {
          const temps = landCells.map(c => c.temp);
          const precips = landCells.map(c => c.precip);
          const minTempC = Math.min(...temps);
          const maxTempC = Math.max(...temps);
          const minTempF = minTempC * 9/5 + 32;
          const maxTempF = maxTempC * 9/5 + 32;
          const minPrecip = Math.min(...precips);
          const maxPrecip = Math.max(...precips);
          console.log(`Temperature range: ${minTempF.toFixed(1)}°F to ${maxTempF.toFixed(1)}°F (${minTempC.toFixed(1)}°C to ${maxTempC.toFixed(1)}°C)`);
          console.log(`Precipitation range: ${minPrecip.toFixed(3)} to ${maxPrecip.toFixed(3)}`);
        }
      }
      
      function classifyBiome(cell, seaLevel) {
        if (cell.high < seaLevel) return 'Ocean';
        
        const T = cell.temp;
        const P = cell.precip;
        
        // Adjust thresholds based on typical precipitation ranges
        if (T < -5) {
          return P > 0.3 ? 'Tundra' : 'Polar Desert';
        }
        if (T < 5) {
          return P > 0.6 ? 'Boreal Forest' : (P > 0.3 ? 'Cold Grassland' : 'Cold Desert');
        }
        if (T < 18) {
          if (P < 0.3) return 'Temperate Desert';
          if (P < 0.6) return 'Grassland';
          if (P < 1.2) return 'Temperate Forest';
          return 'Rainforest';
        }
        // T >= 18 (tropical)
        if (P < 0.3) return 'Hot Desert';
        if (P < 0.6) return 'Savanna';
        if (P < 1.0) return 'Tropical Seasonal Forest';
        return 'Tropical Rainforest';
      }
      
      function getBiomeColor(biome, elevation, seaLevel) {
        const biomeColors = {
          'Ocean': '#4D83AE',
          'Tundra': '#E8F4F8',
          'Polar Desert': '#F0F8FF',
          'Boreal Forest': '#2E5A27',
          'Cold Grassland': '#8FBC8F',
          'Cold Desert': '#F5DEB3',
          'Temperate Desert': '#DEB887',
          'Grassland': '#90EE90',
          'Temperate Forest': '#228B22',
          'Rainforest': '#006400',
          'Hot Desert': '#F4A460',
          'Savanna': '#F0E68C',
          'Tropical Seasonal Forest': '#32CD32',
          'Tropical Rainforest': '#228B22'
        };
        
        // For hybrid mode, blend with elevation
        const renderMode = document.getElementById('renderMode').value;
        if (renderMode === 'hybrid' && elevation > seaLevel + 0.3) {
          // Fade to white for high elevations
          const t = Math.min(1, (elevation - seaLevel - 0.3) / 0.4);
          return d3.interpolateRgb(biomeColors[biome] || '#228B22', '#ffffff')(t);
        }
        
        return biomeColors[biome] || '#228B22';
      }
      
      function updateBiomeLegend() {
        const renderMode = document.getElementById('renderMode').value;
        const legend = document.getElementById('biomeLegend');
        const legendItems = document.getElementById('legendItems');
        
        if (renderMode === 'biomes' || renderMode === 'hybrid') {
          const biomeColors = {
            'Ocean': '#4D83AE',
            'Tundra': '#E8F4F8',
            'Polar Desert': '#F0F8FF',
            'Boreal Forest': '#2E5A27',
            'Cold Grassland': '#8FBC8F',
            'Cold Desert': '#F5DEB3',
            'Temperate Desert': '#DEB887',
            'Grassland': '#90EE90',
            'Temperate Forest': '#228B22',
            'Rainforest': '#006400',
            'Hot Desert': '#F4A460',
            'Savanna': '#F0E68C',
            'Tropical Seasonal Forest': '#32CD32',
            'Tropical Rainforest': '#228B22'
          };
          
          // Group biomes by temperature category
          const biomeGroups = {
            'Cold Biomes': ['Tundra', 'Polar Desert', 'Boreal Forest', 'Cold Grassland', 'Cold Desert'],
            'Temperate Biomes': ['Temperate Desert', 'Grassland', 'Temperate Forest', 'Rainforest'],
            'Tropical Biomes': ['Hot Desert', 'Savanna', 'Tropical Seasonal Forest', 'Tropical Rainforest'],
            'Water': ['Ocean']
          };
          
          let legendHTML = '';
          
          Object.entries(biomeGroups).forEach(([groupName, biomes]) => {
            legendHTML += `<div style="margin-bottom: 8px;"><strong>${groupName}</strong></div>`;
            biomes.forEach(biome => {
              const color = biomeColors[biome];
              legendHTML += `
                <div style="display: flex; align-items: center; margin-bottom: 2px;">
                  <div style="width: 16px; height: 12px; background-color: ${color}; border: 1px solid #666; margin-right: 8px;"></div>
                  <span>${biome}</span>
                </div>
              `;
            });
            legendHTML += '<br>';
          });
          
          if (renderMode === 'hybrid') {
            legendHTML += `
              <div style="margin-top: 8px; font-style: italic; font-size: 11px;">
                Note: High elevations fade to white in hybrid mode
              </div>
            `;
          }
          
          legendItems.innerHTML = legendHTML;
          legend.style.display = 'block';
        } else {
          legend.style.display = 'none';
        }
      }

      // --- Rivers & precipitation (Azgaar-inspired) ---
      function windVecForLat(latDeg) {
        // return unit vector [ux, uy] in screen coords (x right, y down)
        if (Math.abs(latDeg) < 30) return [1, 0];   // easterlies → 
        if (Math.abs(latDeg) < 60) return [-1, 0];  // westerlies ←
        return [1, 0];                              // polar easterlies →
      }

      function windField(cells, H) {
        const U = Array(cells.length);
        for (let i = 0; i < cells.length; i++) {
          const lat = 90 - 180 * (cells[i].cy / height); // 0..1 → 90..-90
          U[i] = windVecForLat(lat);
        }
        return U;
      }

      function windVecs() {
        const mode = document.getElementById('windBelts').value;
        if (mode === 'hadley') {
          // Use wind field for each cell
          return windField(cells, cells.map(c => c.high));
        } else {
          // Random wind (original behavior)
          const pick = () => [[1,0],[-1,0],[0,1],[0,-1]][Math.floor(Math.random()*4)];
          return [pick()];
        }
      }

      function computePrecipArray() {
        const windMode = document.getElementById('windBelts').value;
        const intensity = +document.getElementById('rainInput').value; // 0..2
        const base = 0.4 * intensity + 0.1; // baseline drizzle
        const P = new Float32Array(cells.length);
        for (let i = 0; i < cells.length; i++) P[i] = base;
        
        if (windMode === 'hadley') {
          // Use wind field with orographic effects
          const U = windField(cells, cells.map(c => c.high));
          for (let i = 0; i < cells.length; i++) {
            const ci = cells[i];
            const [wx, wy] = U[i]; // Wind vector for this cell
            const nbs = ci.neighbors;
            for (let k = 0; k < nbs.length; k++) {
              const j = nbs[k];
              const vx = ci.cx - cells[j].cx;
              const vy = ci.cy - cells[j].cy;
              const dot = vx * wx + vy * wy; // >0 means wind approaches cell i from neighbor j
              const dh = ci.high - cells[j].high; // upslope from j -> i adds rain
              if (dot > 0 && dh > 0) {
                // Upslope: orographic bonus
                P[i] += intensity * dh * (dot / Math.hypot(vx, vy)) * 0.3;
              } else if (dot > 0 && dh < 0) {
                // Lee side: rain shadow
                P[i] -= intensity * (-dh) * (dot / Math.hypot(vx, vy)) * 0.15;
              }
            }
          }
        } else {
          // Original random wind system
          const winds = windVecs();
          const norm = (x,y) => { const L = Math.hypot(x,y)||1; return [x/L, y/L]; };
          winds.forEach(w => {
            const [wx, wy] = norm(w[0], w[1]);
            for (let i = 0; i < cells.length; i++) {
              const ci = cells[i];
              const nbs = ci.neighbors;
              for (let k = 0; k < nbs.length; k++) {
                const j = nbs[k];
                const vx = ci.cx - cells[j].cx;
                const vy = ci.cy - cells[j].cy;
                const dot = vx*wx + vy*wy; // >0 means wind approaches cell i from neighbor j
                const dh = ci.high - cells[j].high; // upslope from j -> i adds rain
                if (dot > 0 && dh > 0) P[i] += intensity * dh * (dot/Math.hypot(vx,vy)) * 0.6;
                else if (dot > 0 && dh < 0) P[i] += intensity * dh * 0.15; // leeward drying
              }
            }
          });
        }
        // smooth precipitation a bit (2 iterations)
        for (let it = 0; it < 2; it++) {
          const N = new Float32Array(cells.length);
          for (let i = 0; i < cells.length; i++) {
            let sum = P[i], cnt = 1;
            const nbs = cells[i].neighbors;
            for (let k = 0; k < nbs.length; k++) { sum += P[nbs[k]]; cnt++; }
            N[i] = sum / cnt;
          }
          P.set(N);
        }
        // Store precipitation array for tests
        window.__state.precipArray = P;
        return P;
      }

      function computeRivers() {
        riversShade.selectAll('path').remove();
        riversG.selectAll('path').remove();
        const sea = +document.getElementById('seaLevelInput').value;
        const landIdxs = [];
        for (let i = 0; i < cells.length; i++) if (cells[i].high >= sea) landIdxs.push(i);
        if (!landIdxs.length) { window.__state.riverStats = { majors:0, confluences:0, majorsDrawn:0, majorsReachedSea:0, avgMainLength:0 }; return; }

        // Update progress during river computation
        ProgressManager.update(62, 'Computing rivers...', 'Building distance field...');

        // Use cached typed arrays
        const {dist, down, flux} = window.__state.tmp;
        dist.fill(1e9); down.fill(-1); flux.fill(0);

        // Distance-to-coast field (toward sea only)
        const INF = 1e9;
        const bfsQueue = [];
        for (let i = 0; i < cells.length; i++) if (cells[i].high < sea) { dist[i] = 0; bfsQueue.push(i); }
        for (let qi = 0; qi < bfsQueue.length; qi++) {
          const v = bfsQueue[qi];
          const dv = dist[v] + 1;
          const nbs = cells[v].neighbors;
          for (let k = 0; k < nbs.length; k++) { const nb = nbs[k]; if (dist[nb] > dv) { dist[nb] = dv; bfsQueue.push(nb); } }
        }

        // Flow directions
        landIdxs.forEach(i => {
          let best = -1, bestH = Infinity;
          const di = dist[i];
          const nbs = cells[i].neighbors;
          for (let k = 0; k < nbs.length; k++) {
            const nb = nbs[k];
            if (dist[nb] < di && cells[nb].high <= bestH) { bestH = cells[nb].high; best = nb; }
          }
          if (best === -1) {
            for (let k = 0; k < nbs.length; k++) {
              const nb = nbs[k];
              if (cells[nb].high < cells[i].high && cells[nb].high < bestH) { bestH = cells[nb].high; best = nb; }
            }
          }
          if (best === -1) {
            let bestD = Infinity; bestH = Infinity;
            for (let k = 0; k < nbs.length; k++) {
              const nb = nbs[k]; const dd = dist[nb]; const hh = cells[nb].high;
              if (dd < bestD || (dd === bestD && hh < bestH)) { bestD = dd; bestH = hh; best = nb; }
            }
          }
          down[i] = best;
        });

        // Sort by elevation (top-down)
        const orderByElev = landIdxs.slice().sort((a,b) => cells[b].high - cells[a].high);

        // Precipitation-driven flux
        const precip = PRECIP || computePrecipArray();
        for (const i of orderByElev) flux[i] = Math.max(0, precip[i]);
        for (const i of orderByElev) { const j = down[i]; if (j !== -1) flux[j] += flux[i]; }

        // Helpers
        const valsAll = landIdxs.map(i => flux[i]).sort((a,b)=>a-b);
        const maxF = valsAll.length ? valsAll[valsAll.length-1] : 1;
        const up = Array.from({length: cells.length}, () => []);
        landIdxs.forEach(i => { const j = down[i]; if (j !== -1 && cells[j].high >= sea) up[j].push(i); });
        const countConfluences = (thr) => up.reduce((acc,arr,idx)=> acc + ((cells[idx].high>=sea && arr.filter(a=>flux[a]>=thr).length>=2)?1:0), 0);

        const curve = d3.curveCatmullRom.alpha(0.6);
        const pathOpen = d3.line().x(d=>d[0]).y(d=>d[1]).curve(curve);
        function lengthOf(pts){ let L=0; for (let i=1;i<pts.length;i++){ const dx=pts[i][0]-pts[i-1][0], dy=pts[i][1]-pts[i-1][1]; L+=Math.hypot(dx,dy);} return L; }

        // Polygonal river rendering based on Azgaar's technique
        function createPolygonalRiver(segments, flux, isMain) {
          const riverStyle = document.getElementById('riverStyle').value;
          if (riverStyle === 'lines') return false;
          
          const widening = +document.getElementById('riverWidthInput').value || 200;
          const maxWidth = isMain ? 4.2 : 2.2;
          
          segments.forEach(seg => {
            if (seg.length < 2) return;
            
            // Calculate total length manually
            let totalLength = 0;
            for (let i = 1; i < seg.length; i++) {
              const dx = seg[i][0] - seg[i-1][0];
              const dy = seg[i][1] - seg[i-1][1];
              totalLength += Math.hypot(dx, dy);
            }
            
            if (totalLength < 10) return; // Skip very short segments
            
            const riverPointsLeft = [], riverPointsRight = [];
            
            // Sample points along the river path
            const numSamples = Math.max(10, Math.floor(totalLength / 5));
            for (let i = 0; i <= numSamples; i++) {
              const t = i / numSamples;
              
              // Find position along the path
              let currentLength = 0;
              let targetLength = t * totalLength;
              let point = seg[0];
              
              for (let j = 1; j < seg.length; j++) {
                const dx = seg[j][0] - seg[j-1][0];
                const dy = seg[j][1] - seg[j-1][1];
                const segLength = Math.hypot(dx, dy);
                
                if (currentLength + segLength >= targetLength) {
                  const localT = (targetLength - currentLength) / segLength;
                  point = [
                    seg[j-1][0] + dx * localT,
                    seg[j-1][1] + dy * localT
                  ];
                  break;
                }
                currentLength += segLength;
                if (j === seg.length - 1) point = seg[j];
              }
              
              // Calculate tangent direction
              let tangent = [1, 0]; // default
              if (i > 0 && i < numSamples) {
                const prevT = (i - 1) / numSamples;
                const nextT = (i + 1) / numSamples;
                let prevPoint = seg[0], nextPoint = seg[0];
                
                // Find previous and next points
                currentLength = 0;
                let prevTarget = prevT * totalLength, nextTarget = nextT * totalLength;
                
                for (let j = 1; j < seg.length; j++) {
                  const dx = seg[j][0] - seg[j-1][0];
                  const dy = seg[j][1] - seg[j-1][1];
                  const segLength = Math.hypot(dx, dy);
                  
                  if (currentLength + segLength >= prevTarget && prevPoint === seg[0]) {
                    const localT = (prevTarget - currentLength) / segLength;
                    prevPoint = [
                      seg[j-1][0] + dx * localT,
                      seg[j-1][1] + dy * localT
                    ];
                  }
                  
                  if (currentLength + segLength >= nextTarget && nextPoint === seg[0]) {
                    const localT = (nextTarget - currentLength) / segLength;
                    nextPoint = [
                      seg[j-1][0] + dx * localT,
                      seg[j-1][1] + dy * localT
                    ];
                  }
                  
                  currentLength += segLength;
                  if (j === seg.length - 1) {
                    if (prevPoint === seg[0]) prevPoint = seg[j];
                    if (nextPoint === seg[0]) nextPoint = seg[j];
                  }
                }
                
                const tx = nextPoint[0] - prevPoint[0];
                const ty = nextPoint[1] - prevPoint[1];
                const length = Math.hypot(tx, ty);
                if (length > 0) {
                  tangent = [tx / length, ty / length];
                }
              }
              
              // Calculate offset using hyperbolic tangent with widening parameter
              const offset = Math.atan(t * 3) * (flux / maxF) * maxWidth * (widening / 200);
              
              // Create offset points
              const xLeft = point[0] + -tangent[1] * offset;
              const yLeft = point[1] + tangent[0] * offset;
              riverPointsLeft.push([xLeft, yLeft]);
              
              const xRight = point[0] + tangent[1] * offset;
              const yRight = point[1] + -tangent[0] * offset;
              riverPointsRight.unshift([xRight, yRight]);
            }
            
            if (riverPointsLeft.length < 2) return;
            
            // Create the river polygon
            const riverPolygon = [...riverPointsLeft, ...riverPointsRight];
            
            // Draw the polygon
            const polygonPath = 'M' + riverPolygon.map(p => p.join(',')).join('L') + 'Z';
            
            riversShade.append('path')
              .attr('class', 'riversShade ' + (isMain ? 'main' : 'trib'))
              .attr('d', polygonPath)
              .attr('fill', 'rgba(0,0,0,0.3)');
              
            riversG.append('path')
              .attr('class', 'rivers ' + (isMain ? 'main' : 'trib'))
              .attr('d', polygonPath)
              .attr('fill', '#4D83AE');
          });
          
          return true; // Indicate polygonal rendering was used
        }

        // Chain builder with lake-aware jumps
        function chainFrom(s, stopSet) {
          const segments = [];
          let edges = [];
          let current = s;
          let pts = [[cells[current].cx, cells[current].cy]];
          let steps = 0; let reachedSea = false;
          const visitedLakes = new Set();
          while (steps++ < 4000) {
            const j = down[current]; if (j === -1) break;
            const ekey = current + ">" + j; if (stopSet && stopSet.has(ekey)) break;
            const isSea = cells[j].high < sea;
            const isLake = (window.__state.isLake && window.__state.isLake[j] === 1);
            if (isSea || isLake) {
              const mid = [(cells[current].cx + cells[j].cx)/2, (cells[current].cy + cells[j].cy)/2];
              pts.push(mid);
              segments.push(pts);
              edges.push(ekey);
              if (isSea) { reachedSea = true; break; }
              
              // Handle lake outlet
              const lid = window.__state.lakeId ? window.__state.lakeId[j] : -1;
              if (visitedLakes.has(lid)) break; // avoid loops
              visitedLakes.add(lid);
              
              const lake = (window.__state.lakes || [])[lid];
              if (!lake) break; // no lake data
              
              const outlet = lake.outlet;
              if (outlet === -1 || outlet === undefined) break; // endorheic lake
              
              // Verify outlet is valid and leads to ocean
              if (outlet < 0 || outlet >= cells.length) break; // invalid outlet
              
              // Check if outlet leads to ocean or another lake
              const outletCell = cells[outlet];
              if (!outletCell) break; // invalid outlet cell
              
              // If outlet is also a lake, we might have a chain of lakes
              const outletIsLake = window.__state.isLake && window.__state.isLake[outlet] === 1;
              if (outletIsLake) {
                // For now, break to avoid complex lake chains
                // In the future, we could trace through multiple lakes
                break;
              }
              
              // Continue from outlet
              current = outlet;
              pts = [[cells[current].cx, cells[current].cy]]; // start new segment from outlet
              continue;
            } else {
              pts.push([cells[j].cx, cells[j].cy]);
              edges.push(ekey);
              current = j;
            }
          }
          const totalLen = segments.reduce((acc, p) => acc + lengthOf(p), 0);
          return { segments, edges, reachedSea, len: totalLen };
        }

        // Calibrate to ~5–15 mains
        let q = +document.getElementById('riverDensityInput').value; // 0.70..0.99 base
        let thrMain = d3.quantile(valsAll, q) || (maxF * 0.6);
        const sourcesCount = (thr) => {
          const good = new Set(landIdxs.filter(i=>flux[i]>=thr));
          let cnt = 0; good.forEach(i => { const hasUp = up[i].some(u=>good.has(u)); if (!hasUp) cnt++; });
          return cnt;
        };
        let majors = sourcesCount(thrMain);
        let guard = 0;
        while ((majors < 5 || majors > 15) && guard++ < 18) {
          if (majors < 5) { q = Math.max(0.70, q - 0.03); } else { q = Math.min(0.99, q + 0.02); }
          thrMain = d3.quantile(valsAll, q) || thrMain * (majors < 5 ? 0.8 : 1.2);
          majors = sourcesCount(thrMain);
        }

        const thrTrib = Math.max(d3.quantile(valsAll, Math.max(0.70, q - 0.10)) || thrMain*0.7, thrMain*0.5);
        const widthMain = d3.scaleSqrt().domain([Math.max(1e-6, thrMain), Math.max(1e-6, maxF)]).range([1.2, 4.2]);
        const widthTrib = d3.scaleSqrt().domain([Math.max(1e-6, thrTrib), Math.max(1e-6, maxF)]).range([0.45, 2.2]);

        const visitedMain = new Set();
        let majorsDrawn = 0, majorsReachedSea = 0; let totalMainLen = 0;

        const mainStarts = landIdxs.filter(i => flux[i] >= thrMain).sort((a,b)=>flux[b]-flux[a]);
        for (const s of mainStarts) {
          const j0 = down[s]; if (j0 !== -1 && visitedMain.has(s+">"+j0)) continue;
          const chain = chainFrom(s, visitedMain);
          if (!chain.segments.length) continue;
          if (chain.len < 60) continue;
          
          // Try polygonal rendering first
          const usedPolygonal = createPolygonalRiver(chain.segments, flux[s], true);
          if (!usedPolygonal) {
            // Fall back to line rendering
            chain.segments.forEach(seg => {
              riversShade.append('path').attr('class','riversShade main').attr('d', pathOpen(seg)).attr('stroke-width', Math.max(0.3, widthMain(flux[s])*0.4));
              riversG.append('path').attr('class','rivers main').attr('d', pathOpen(seg)).attr('stroke-width', widthMain(flux[s]));
            });
          }
          chain.edges.forEach(k => visitedMain.add(k));
          majorsDrawn++; totalMainLen += chain.len; if (chain.reachedSea) majorsReachedSea++;
        }

        const tribStarts = landIdxs.filter(i => flux[i] >= thrTrib).sort((a,b)=>flux[b]-flux[a]);
        for (const s of tribStarts) {
          const j0 = down[s]; if (j0 !== -1 && visitedMain.has(s+">"+j0)) continue;
          const chain = chainFrom(s, visitedMain);
          if (!chain.segments.length || chain.len < 30) continue;
          
          // Try polygonal rendering first
          const usedPolygonal = createPolygonalRiver(chain.segments, flux[s], false);
          if (!usedPolygonal) {
            // Fall back to line rendering
            chain.segments.forEach(seg => {
              riversShade.append('path').attr('class','riversShade trib').attr('d', pathOpen(seg)).attr('stroke-width', Math.max(0.2, widthTrib(flux[s])*0.35));
              riversG.append('path').attr('class','rivers trib').attr('d', pathOpen(seg)).attr('stroke-width', widthTrib(flux[s]));
            });
          }
        }

        const confl = countConfluences(thrTrib);
        const avgMainLength = majorsDrawn ? (totalMainLen / majorsDrawn) : 0;
        window.__state.riverStats = { majors, confluences: confl, thrMain, thrTrib, majorsDrawn, majorsReachedSea, avgMainLength };
        
        // Debug: Log lake information
        const lakes = window.__state.lakes || [];
        if (lakes.length > 0) {
          console.log(`Found ${lakes.length} lakes:`);
          lakes.forEach((lake, i) => {
            const outletValid = lake.outlet >= 0 && lake.outlet < cells.length;
            const outletIsLake = outletValid && window.__state.isLake && window.__state.isLake[lake.outlet] === 1;
            const outletIsOcean = outletValid && cells[lake.outlet].high < sea;
            console.log(`  Lake ${i}: size=${lake.size}, depth=${lake.depth.toFixed(3)}, outlet=${lake.outlet} (valid:${outletValid}, isLake:${outletIsLake}, isOcean:${outletIsOcean})`);
          });
        }
      }

      // --- Chaikin Smoothing (Safe, Inside Original) ---
      function chaikin(points, iters = 2) {
        let pts = points.slice();
        for (let k = 0; k < iters; k++) {
          const out = [];
          for (let i = 0; i < pts.length; i++) {
            const a = pts[i], b = pts[(i+1)%pts.length];
            const Q = [0.75*a[0] + 0.25*b[0], 0.75*a[1] + 0.25*b[1]];
            const R = [0.25*a[0] + 0.75*b[0], 0.25*a[1] + 0.75*b[1]];
            out.push(Q, R);
          }
          pts = out;
        }
        return pts;
      }

      // --- Path Data Helpers ---
      function ringToPathD(ring) {
        return "M" + ring.map(p => p.join(",")).join("L") + "Z";
      }

      function islandToPathD(outer, holes=[]) {
        // outer then holes; evenodd fill will subtract the holes
        return ringToPathD(outer) + holes.map(ringToPathD).join("");
      }

      // --- Land Mask and Underlay Helper ---
      function ensureLandUnderlay(svg, zoomRoot, width, height) {
        const defs = svg.select('defs');

        // Prefer unified land paths; fall back to landPaths if needed
        const unifiedPaths = window.__state.unifiedLandPaths || [];
        const landPaths = window.__state.landPaths || [];

        if (!unifiedPaths.length && !landPaths.length) return;

        // Build a single SVG 'd' string for all land rings
        let landD = '';
        
        if (unifiedPaths.length > 0) {
          // Use unified paths (arrays of points)
          landD = unifiedPaths
            .map(poly => 'M' + poly.map(p => p.join(',')).join('L') + 'Z')
            .join('');
        } else if (landPaths.length > 0) {
          // Use land paths (objects with path properties)
          landD = landPaths
            .map(lp => lp.path.attr('d'))
            .join('');
        }

        if (!landD) return;

        // --- Land mask (white = land, black = sea) ---
        defs.select('#landMask').remove();
        const landMask = defs.append('mask')
          .attr('id', 'landMask')
          .attr('maskContentUnits', 'userSpaceOnUse');

        landMask.append('rect')
          .attr('width', width).attr('height', height)
          .attr('fill', 'black');

        landMask.append('path')
          .attr('d', landD)
          .attr('fill', 'white');

        // --- Land underlay (fills hairline gaps inland) ---
        zoomRoot.select('rect.land-underlay').remove();
        zoomRoot.insert('rect', '.mapCells') // under polygons, above ocean
          .attr('class', 'land-underlay')
          .attr('x', 0).attr('y', 0)
          .attr('width', width).attr('height', height)
          .attr('fill', typeof landColor === 'function' ? landColor(0.0) : '#8fbf7a')
          .attr('mask', 'url(#landMask)');

        // --- Optional: land-side coastline seam stroke (clips stroke to land only) ---
        defs.select('#landClip').remove();
        defs.append('clipPath').attr('id', 'landClip')
          .append('path').attr('d', landD);

        if (window.__state.coastD) {
          zoomRoot.select('path.coast-seam').remove();
          zoomRoot.append('path')
            .attr('class', 'coast-seam')
            .attr('d', window.__state.coastD)
            .attr('clip-path', 'url(#landClip)')
            .attr('stroke', typeof landColor === 'function' ? landColor(0.0) : '#8fbf7a')
            .attr('stroke-width', 1.2)
            .attr('fill', 'none')
            .attr('vector-effect', 'non-scaling-stroke');
        }
      }

      // Compute average color for an island based on its cells
      function computeIslandColor(loop, renderMode, sea, cells) {
        if (renderMode === 'biomes' || renderMode === 'hybrid') {
          return '#90EE90'; // Light green for biomes
        }
        
        // For height map, compute average elevation of cells within the island
        // Find cells that are within this island's boundary
        const islandCells = [];
        
        // Simple approach: find cells whose center is within the island polygon
        cells.forEach(cell => {
          if (cell.high >= sea) { // Only consider land cells
            // Check if cell center is inside the island polygon
            if (pointInPolygon([cell.cx, cell.cy], loop)) {
              islandCells.push(cell);
            }
          }
        });
        
        if (islandCells.length === 0) {
          // Fallback: use a representative lowland color
          return landColor(0.2);
        }
        
        // Compute average elevation of island cells
        const avgElevation = islandCells.reduce((sum, cell) => sum + cell.high, 0) / islandCells.length;
        const normalizedElevation = (avgElevation - sea) / Math.max(1 - sea, 0.0001);
        const clampedElevation = Math.max(0, Math.min(1, normalizedElevation));
        
        return landColor(clampedElevation);
      }
      
      // Point-in-polygon test using ray casting algorithm
      function pointInPolygon(point, polygon) {
        const [x, y] = point;
        let inside = false;
        
        for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
          const [xi, yi] = polygon[i];
          const [xj, yj] = polygon[j];
          
          if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
            inside = !inside;
          }
        }
        
        return inside;
      }

      // --- Coastline builder (Azgaar-style: boundary between land and water) --- (Azgaar-style: boundary between land and water) --- (Azgaar-style: boundary between land and water) ---
      function drawCoastlines() {
        coastG.selectAll('path.coast').remove();
        mapCells.selectAll('path.land-fill').remove();
        
        // ✨ always recompute based on the *current* cells & sea level
        const sea = +document.getElementById('seaLevelInput').value;
        const cells = window.__state.cells;
        
        // if you have a computeLakes() that also marks lakes, call it here;
        // otherwise this simple mask is fine:
        const isWaterArr = cells.map(c => c.high < sea);
        
        // update cache for other systems (rivers, burg scoring, routes)
        window.__state.isWater = isWaterArr;
        
        // ❌ invalidate any previously unified paths so recolor can't reuse them
        window.__state.unifiedLandPaths = null;
        window.__state.landPaths = null;
        
        const isLand = cells.map((c,i) => !isWaterArr[i]);
        
        console.log(`Drawing coastlines - Sea level: ${sea}, Land cells: ${isLand.filter(l => l).length}, Water cells: ${isWaterArr.filter(w => w).length}`);
        
        // Update progress during coastline computation
        ProgressManager.update(72, 'Drawing coastlines...', 'Finding coastline edges...');

        // Build undirected edge map from Voronoi cell polygons
        const edgeMap = new Map(); // key -> {a,b,cells:Set}
        const keyOfPoint = (p) => `${p[0].toFixed(3)},${p[1].toFixed(3)}`;
        const edgeKey = (a,b) => {
          const qa = keyOfPoint(a), qb = keyOfPoint(b);
          return qa < qb ? `${qa}|${qb}` : `${qb}|${qa}`;
        };

        cells.forEach((c) => {
          const poly = c.poly;
          for (let i = 0; i < poly.length - 1; i++) { // last equals first
            const a = poly[i], b = poly[i + 1];
            const k = edgeKey(a, b);
            let e = edgeMap.get(k);
            if (!e) { e = { a, b, cells: new Set() }; edgeMap.set(k, e); }
            e.cells.add(c.index);
          }
        });

        // Filter edges where sides differ (land vs water OR hull)
        const coastEdges = [];
        edgeMap.forEach((e) => {
          const arr = Array.from(e.cells);
          const c0 = arr[0];
          const c1 = arr[1] !== undefined ? arr[1] : null; // null => hull
          const land0 = c0 != null ? isLand[c0] : false;
          const land1 = c1 != null ? isLand[c1] : false;
          if (land0 !== land1) coastEdges.push(e); // coastline segment
        });

        if (DEBUG) console.log(`Found ${coastEdges.length} coastline edges`);
        if (coastEdges.length === 0) return;

        // Chain edges into polylines by shared endpoints
        const pointToEdges = new Map(); // pointKey -> Set(edgeKey)
        coastEdges.forEach((e) => {
          const k = edgeKey(e.a, e.b);
          const ka = keyOfPoint(e.a), kb = keyOfPoint(e.b);
          if (!pointToEdges.has(ka)) pointToEdges.set(ka, new Set());
          if (!pointToEdges.has(kb)) pointToEdges.set(kb, new Set());
          pointToEdges.get(ka).add(k);
          pointToEdges.get(kb).add(k);
        });

        const edgesObj = new Map();
        coastEdges.forEach((e) => { edgesObj.set(edgeKey(e.a, e.b), { a: e.a, b: e.b, used: false }); });

        const chains = [];
        const takeNext = (ptKey) => {
          const set = pointToEdges.get(ptKey);
          if (!set) return null;
          for (const k of set) { const e = edgesObj.get(k); if (e && !e.used) return k; }
          return null;
        };

        edgesObj.forEach((seg) => {
          if (seg.used) return;
          seg.used = true;
          const startKey = keyOfPoint(seg.a), endKey = keyOfPoint(seg.b);
          const chain = [seg.a, seg.b];

          // extend forward from end
          let currKey = endKey;
          let prevKey = startKey;
          for (;;) {
            const nextKey = takeNext(currKey);
            if (!nextKey) break;
            const next = edgesObj.get(nextKey);
            next.used = true;
            const na = keyOfPoint(next.a), nb = keyOfPoint(next.b);
            const other = (na === currKey) ? nb : (nb === currKey ? na : null);
            if (!other || other === prevKey) break;
            chain.push(na === currKey ? next.b : next.a);
            prevKey = currKey; currKey = other;
          }

          // extend backward from start (prepend)
          currKey = startKey; prevKey = endKey;
          for (;;) {
            const nextKey = takeNext(currKey);
            if (!nextKey) break;
            const next = edgesObj.get(nextKey);
            next.used = true;
            const na = keyOfPoint(next.a), nb = keyOfPoint(next.b);
            const other = (na === currKey) ? nb : (nb === currKey ? na : null);
            if (!other || other === prevKey) break;
            chain.unshift(na === currKey ? next.b : next.a);
            prevKey = currKey; currKey = other;
          }

          chains.push(chain);
        });

        // Separate closed loops (islands) from open chains (peninsulas)
        const closedLoops = [];
        const openChains = [];
        
        chains.forEach((chain) => {
          const isClosed = (keyOfPoint(chain[0]) === keyOfPoint(chain[chain.length - 1]));
          if (isClosed && chain.length > 3) {
            closedLoops.push(chain);
          } else {
            openChains.push(chain);
          }
        });

        if (DEBUG) console.log(`Found ${closedLoops.length} closed loops (islands) and ${openChains.length} open chains`);

        // Create unified land paths for each island
        closedLoops.forEach((loop, islandIndex) => {
          // Smooth the loop with Chaikin
          const smoothedLoop = chaikin(loop, 2);
          
          // Create the path data for this island
          const pathD = islandToPathD(smoothedLoop);
          
          // Create the land fill path in mapCells group (behind everything)
          const landPath = mapCells.insert('path', ':first-child')
            .attr('class', 'land-fill')
            .attr('d', pathD)
            .attr('fill', 'none')          // was '#f0f0f0'
            .attr('stroke', 'none')
            .attr('fill-rule', 'evenodd');
          
          // Create the coastline stroke in coastG group (on top)
          const coastPath = coastG.append('path')
            .attr('class', 'coast')
            .attr('d', pathD)
            .attr('fill', 'none')
            .attr('stroke', '#111')
            .attr('stroke-width', '0.6px')
            .attr('stroke-linejoin', 'round');
          
          // Debug: ensure both paths use identical geometry
          if (DEBUG) console.log('Island', islandIndex, 'path data:', {
            landPathD: landPath.attr('d'),
            coastPathD: coastPath.attr('d'),
            match: landPath.attr('d') === coastPath.attr('d')
          });
          
          // Store reference for recolor function with island data
          if (!window.__state.landPaths) window.__state.landPaths = [];
          window.__state.landPaths.push({
            path: landPath,
            coast: coastPath,
            islandIndex: islandIndex,
            loop: loop // Store the original loop for color computation
          });
        });

        // Handle open chains (peninsulas) as simple strokes
        openChains.forEach((chain) => {
          // Simplify path based on map size
          const tolerance = Math.max(0.15, Math.min(0.3, cells.length / 50000));
          const simplifiedPts = simplifyPath(chain, tolerance);
          
          const lineOpen = d3.line().x(d => d[0]).y(d => d[1]).curve(d3.curveBasis);
          
          coastG.append('path')
            .attr('class', 'coast')
            .attr('d', lineOpen(simplifiedPts))
            .attr('fill', 'none')
            .attr('stroke', '#111')
            .attr('stroke-width', '0.6px')
            .attr('stroke-linejoin', 'round');
        });

        if (DEBUG) console.log(`Created ${closedLoops.length} unified land paths with coastlines`);
        
        // Land paths are now non-filled to preserve height map visibility
        // Coastline strokes remain in coastG group for smooth edges
        
        // Optional: Create clip path for crisper edges
        if (closedLoops.length > 0) {
          const cp = defs.select('#landClip').empty()
            ? defs.append('clipPath').attr('id', 'landClip').attr('clipPathUnits', 'userSpaceOnUse')
            : defs.select('#landClip').attr('clipPathUnits', 'userSpaceOnUse');

          cp.selectAll('path').remove();
          closedLoops.forEach(loop => {
            const d = islandToPathD(chaikin(loop, 2));
            cp.append('path').attr('d', d);
          });

          // Apply clipping to both render modes
          mapCells.select('image').attr('clip-path', 'url(#landClip)');         // canvas/raster mode
          mapCells.selectAll('path.mapCell').attr('clip-path', 'url(#landClip)'); // SVG cell mode
          
          // Build ocean mask (visible everywhere except land)
          const oceanMask = defs.select('#oceanMask').empty()
            ? defs.append('mask').attr('id', 'oceanMask').attr('maskUnits', 'userSpaceOnUse')
            : defs.select('#oceanMask').attr('maskUnits', 'userSpaceOnUse');
          
          oceanMask.selectAll('*').remove();
          oceanMask.append('rect')
            .attr('x', 0).attr('y', 0)
            .attr('width', window.__state.width)
            .attr('height', window.__state.height)
            .attr('fill', 'white');
          
          // punch land holes (black hides)
          closedLoops.forEach(loop => {
            const d = islandToPathD(chaikin(loop, 2));
            oceanMask.append('path').attr('d', d).attr('fill', 'black');
          });
          
          // Debug: log what we're clipping
          if (DEBUG) console.log('Applied clip path to:', {
            imageCount: mapCells.select('image').size(),
            cellPathCount: mapCells.selectAll('path.mapCell').size(),
            clipPathD: cp.select('path').attr('d'),
            oceanMaskCreated: !oceanMask.empty(),
            oceanMaskRect: oceanMask.select('rect').node()
          });
        }

        // Create unified land paths for masking and underlay
        if (closedLoops.length > 0) {
          window.__state.unifiedLandPaths = closedLoops.map(loop => {
            const smoothedLoop = chaikin(loop, 2);
            return smoothedLoop;
          });
        }

        // Save coastline path data for seam stroke
        if (closedLoops.length > 0) {
          const coastD = closedLoops.map(loop => {
            const smoothedLoop = chaikin(loop, 2);
            return islandToPathD(smoothedLoop);
          }).join('');
          window.__state.coastD = coastD;
        }

        // Build land mask & underlay so inland hairlines show land, not sea
        const svg = window.__state.svg;
        const zoomRoot = d3.select('#zoomRoot');
        const width = +svg.attr('width'), height = +svg.attr('height');
        ensureLandUnderlay(svg, zoomRoot, width, height);
      }
    }

    // --- Burgs (Settlements) System ---

    /**
     * Score a cell for capital placement (strategic locations)
     * @param {Object} cell - The cell to score
     * @param {Array} cells - All cells array
     * @param {number} sea - Sea level
     * @returns {number} Score between 0 and 1
     */
    function scoreCellForCapital(cell, cells, sea) {
      const riverWeight = +document.getElementById('riverWeightInput').value || 0.4;
      const coastWeight = +document.getElementById('coastWeightInput').value || 0.3;
      const flatnessWeight = +document.getElementById('flatnessWeightInput').value || 0.2;
      const fertilityWeight = +document.getElementById('fertilityWeightInput').value || 0.1;

      // Skip water cells
      if (cell.high < sea) return 0;
      
      // Skip very high peaks (too steep for settlements)
      if (cell.high > 0.8) return 0;

      let riverProximity = 0;
      let coastProximity = 0;
      let flatness = 0;
      let fertility = 1; // Default fertility
      let harborQuality = 0;

      // Calculate river proximity (check neighbors for rivers)
      let riverNeighbors = 0;
      cell.neighbors.forEach(nb => {
        const neighborCell = cells[nb];
        const isWater = neighborCell.high < sea;
        const isLake = window.__state.isLake && window.__state.isLake[nb] === 1;
        if (isWater && !isLake) {
          riverNeighbors++;
        }
      });
      riverProximity = Math.min(1, riverNeighbors / cell.neighbors.length * 3);

      // Calculate river proximity
      riverProximity = Math.min(1, riverNeighbors / cell.neighbors.length * 3);

      // Calculate coast proximity using distance-to-water field
      let minWaterDist = Infinity;
      let waterNeighbors = 0;
      
      // Use precomputed distance-to-water field if available
      if (window.__state.distToWater) {
        minWaterDist = window.__state.distToWater[cell.index];
        // Count water neighbors for harbor quality
        cell.neighbors.forEach(nb => {
          if (cells[nb].high < sea) {
            waterNeighbors++;
          }
        });
      } else {
        // Fallback to O(N²) scan
        for (let i = 0; i < cells.length; i++) {
          if (cells[i].high < sea) {
            const dist = Math.hypot(cell.cx - cells[i].cx, cell.cy - cells[i].cy);
            minWaterDist = Math.min(minWaterDist, dist);
            
            // Count water neighbors for harbor quality
            if (dist < 30) {
              waterNeighbors++;
            }
          }
        }
      }
      coastProximity = Math.max(0, 1 - minWaterDist / 100); // Prefer cells within 100px of coast
      
      // Harbor quality: prefer sheltered locations (exactly one ocean neighbor)
      if (waterNeighbors === 1) {
        harborQuality = 1.0; // Perfect harbor (cove/estuary)
      } else if (waterNeighbors === 2) {
        harborQuality = 0.7; // Good harbor
      } else if (waterNeighbors > 2) {
        harborQuality = 0.3; // Exposed coast
      }

      // Calculate flatness (inverse of slope)
      let maxSlope = 0;
      cell.neighbors.forEach(nb => {
        const slope = Math.abs(cell.high - cells[nb].high);
        maxSlope = Math.max(maxSlope, slope);
      });
      flatness = Math.max(0, 1 - maxSlope * 5); // Prefer flatter areas

      // Calculate fertility (use precipitation if available)
      if (window.__state.precipArray) {
        fertility = Math.min(1, window.__state.precipArray[cell.index] || 0.5);
      }

      // Combine scores with weights (capitals emphasize strategic locations)
      const score = riverWeight * riverProximity + 
                   coastWeight * (coastProximity * 0.6 + harborQuality * 0.4) + 
                   flatnessWeight * flatness + 
                   fertilityWeight * fertility;

      // Debug: Log some sample scores
      if (Math.random() < 0.01) { // Log 1% of cells for debugging
        if (DEBUG) console.log(`Cell ${cell.index} CAPITAL scores - River: ${riverProximity.toFixed(2)}, Coast: ${coastProximity.toFixed(2)}, Harbor: ${harborQuality.toFixed(2)}, Flat: ${flatness.toFixed(2)}, Fert: ${fertility.toFixed(2)}, Total: ${score.toFixed(2)}`);
      }

      return Math.max(0, Math.min(1, score));
    }

    /**
     * Score a cell for town placement (including road access bonus)
     * @param {Object} cell - The cell to score
     * @param {Array} cells - All cells array
     * @param {number} sea - Sea level
     * @param {Array} capitals - Array of capital burgs
     * @returns {number} Score between 0 and 1
     */
    function scoreCellForTown(cell, cells, sea, capitals) {
      const riverWeight = +document.getElementById('riverWeightInput').value || 0.4;
      const coastWeight = +document.getElementById('coastWeightInput').value || 0.3;
      const flatnessWeight = +document.getElementById('flatnessWeightInput').value || 0.2;
      const fertilityWeight = +document.getElementById('fertilityWeightInput').value || 0.1;
      const roadWeight = 0.3; // Bonus for road access

      // Skip water cells
      if (cell.high < sea) return 0;
      
      // Skip very high peaks (too steep for settlements)
      if (cell.high > 0.8) return 0;

      let riverProximity = 0;
      let coastProximity = 0;
      let flatness = 0;
      let fertility = 1; // Default fertility
      let roadAccess = 0;

      // Calculate river proximity (same as capitals)
      let riverNeighbors = 0;
      cell.neighbors.forEach(nb => {
        const neighborCell = cells[nb];
        const isWater = neighborCell.high < sea;
        const isLake = window.__state.isLake && window.__state.isLake[nb] === 1;
        if (isWater && !isLake) {
          riverNeighbors++;
        }
      });
      riverProximity = Math.min(1, riverNeighbors / cell.neighbors.length * 3);

      // Calculate coast proximity (simpler than capitals)
      let minWaterDist = Infinity;
      for (let i = 0; i < cells.length; i++) {
        if (cells[i].high < sea) {
          const dist = Math.hypot(cell.cx - cells[i].cx, cell.cy - cells[i].cy);
          minWaterDist = Math.min(minWaterDist, dist);
        }
      }
      coastProximity = Math.max(0, 1 - minWaterDist / 100);

      // Calculate flatness (same as capitals)
      let maxSlope = 0;
      cell.neighbors.forEach(nb => {
        const slope = Math.abs(cell.high - cells[nb].high);
        maxSlope = Math.max(maxSlope, slope);
      });
      flatness = Math.max(0, 1 - maxSlope * 5);

      // Calculate fertility (same as capitals)
      if (window.__state.precipArray) {
        fertility = Math.min(1, window.__state.precipArray[cell.index] || 0.5);
      }

      // Calculate road access bonus (distance to nearest capital road)
      let minRoadDist = Infinity;
      if (window.__state.capitalRoads && window.__state.capitalRoads.length > 0) {
        for (const road of window.__state.capitalRoads) {
          // Simple distance to road segment (could be improved with actual path distance)
          const dist = Math.hypot(cell.cx - road.x, cell.cy - road.y);
          minRoadDist = Math.min(minRoadDist, dist);
        }
        roadAccess = Math.max(0, 1 - minRoadDist / 200); // Bonus within 200px of roads
      }

      // Combine scores with weights (towns emphasize road access)
      const baseScore = riverWeight * riverProximity + 
                       coastWeight * coastProximity + 
                       flatnessWeight * flatness + 
                       fertilityWeight * fertility;
      
      const roadBonus = roadWeight * roadAccess;
      const score = baseScore + roadBonus;

      // Debug: Log some sample scores
      if (Math.random() < 0.01) { // Log 1% of cells for debugging
        if (DEBUG) console.log(`Cell ${cell.index} TOWN scores - River: ${riverProximity.toFixed(2)}, Coast: ${coastProximity.toFixed(2)}, Flat: ${flatness.toFixed(2)}, Fert: ${fertility.toFixed(2)}, Road: ${roadAccess.toFixed(2)}, Total: ${score.toFixed(2)}`);
      }

      return Math.max(0, Math.min(1, score));
    }

    /**
     * Poisson disk sampling for burg placement
     * @param {Array} candidates - Array of {cell, score} objects
     * @param {number} radiusPx - Minimum distance between burgs in pixels
     * @returns {Array} Spaced subset of candidates
     */
    function poissonSample(candidates, radiusPx) {
      const accepted = [];
      const rejected = [];
      
      // Sort by score (highest first)
      const sorted = candidates.sort((a, b) => b.score - a.score);
      
      for (const candidate of sorted) {
        let tooClose = false;
        
        // Check distance to all accepted burgs
        for (const acceptedBurg of accepted) {
          const dist = Math.hypot(
            candidate.cell.cx - acceptedBurg.cell.cx,
            candidate.cell.cy - acceptedBurg.cell.cy
          );
          if (dist < radiusPx) {
            tooClose = true;
            break;
          }
        }
        
        if (!tooClose) {
          accepted.push(candidate);
        } else {
          rejected.push(candidate);
        }
      }
      
      return accepted;
    }

    /**
     * Build roads between capitals (MST approach)
     * @param {Array} capitals - Array of capital burgs
     */
    function buildCapitalRoads(capitals) {
      if (capitals.length < 2) return;
      
      console.log(`Building capital road network for ${capitals.length} capitals`);
      
      // Create edges between all capital pairs
      const edges = [];
      for (let i = 0; i < capitals.length; i++) {
        for (let j = i + 1; j < capitals.length; j++) {
          const dist = Math.hypot(
            capitals[i].x - capitals[j].x,
            capitals[i].y - capitals[j].y
          );
          edges.push({
            a: i,
            b: j,
            cost: dist
          });
        }
      }
      
      // Sort edges by cost for Kruskal's algorithm
      edges.sort((a, b) => a.cost - b.cost);
      
      // Kruskal's algorithm for MST
      const parent = new Array(capitals.length).fill(0).map((_, i) => i);
      
      function find(x) {
        if (parent[x] !== x) {
          parent[x] = find(parent[x]);
        }
        return parent[x];
      }
      
      function union(x, y) {
        parent[find(x)] = find(y);
      }
      
      const mstEdges = [];
      for (const edge of edges) {
        if (find(edge.a) !== find(edge.b)) {
          union(edge.a, edge.b);
          mstEdges.push(edge);
        }
      }
      
      // Store capital roads for town scoring
      window.__state.capitalRoads = mstEdges.map(edge => ({
        x: (capitals[edge.a].x + capitals[edge.b].x) / 2,
        y: (capitals[edge.a].y + capitals[edge.b].y) / 2,
        a: edge.a,
        b: edge.b
      }));
      
      if (DEBUG) console.log(`Built ${mstEdges.length} capital roads`);
    }

    /**
     * Create a burg object from a cell
     * @param {Object} cell - The cell to place the burg on
     * @param {Array} cells - All cells array
     * @param {number} sea - Sea level
     * @param {number} index - Burg index
     * @param {string} type - Burg type ('capital', 'town', 'port')
     * @returns {Object} Burg object
     */
    function placeBurg(cell, cells, sea, index, type = 'town') {
      const id = index;
      
      // Determine if it's a port (near coast)
      let isPort = false;
      let minWaterDist = Infinity;
      for (let i = 0; i < cells.length; i++) {
        if (cells[i].high < sea) {
          const dist = Math.hypot(cell.cx - cells[i].cx, cell.cy - cells[i].cy);
          minWaterDist = Math.min(minWaterDist, dist);
        }
      }
      isPort = minWaterDist < 15; // Within 15px of water (more selective)
      
      // Debug: Log port detection for some burgs
      if (Math.random() < 0.1) { // Log 10% of burgs
        console.log(`Burg ${id} port detection: minWaterDist=${minWaterDist.toFixed(1)}px, isPort=${isPort}, type=${type}`);
      }

      // Determine if it's on a river
      let onRiver = false;
      cell.neighbors.forEach(nb => {
        const neighborCell = cells[nb];
        // Check if neighbor is water but not a lake
        const isWater = neighborCell.high < sea;
        const isLake = window.__state.isLake && window.__state.isLake[nb] === 1;
        if (isWater && !isLake) {
          onRiver = true;
        }
      });

      // Determine population based on type and features
      let population = 1000;
      
      if (type === 'capital') {
        population = 5000; // Capitals are larger
      } else if (isPort) {
        population = 2000; // Ports are prosperous
      } else if (onRiver) {
        population = 1500; // River towns are moderately prosperous
      }

      // Generate name
      const name = BURG_NAMES[id % BURG_NAMES.length] + (id > BURG_NAMES.length - 1 ? ` ${Math.floor(id / BURG_NAMES.length) + 1}` : '');

      return {
        id: id,
        x: cell.cx,
        y: cell.cy,
        cell: cell.index,
        cultureId: null, // Will be assigned in Regions phase
        countryId: null, // Will be assigned in Regions phase
        population: population,
        type: type,
        port: isPort,
        isSignificantPort: false, // Capitals are not significant ports (ports should be cities)
        onRiver: onRiver,
        name: name
      };
    }

    /**
     * Generate burgs using Azgaar's economic approach
     */
    function generateBurgs() {
      const totalCount = +document.getElementById('burgsCountInput').value || 25;
      const capitalCount = Math.max(2, Math.floor(totalCount * 0.12)); // 12% capitals
      const cityCount = Math.floor(totalCount * 0.28); // 28% cities/ports
      const villageCount = totalCount - capitalCount - cityCount; // 60% villages
      const sea = +document.getElementById('seaLevelInput').value;
      const cells = window.__state.cells;
      
      if (DEBUG) console.log(`Generating ${capitalCount} capitals + ${cityCount} cities + ${villageCount} villages using economic approach`);
      
      // Update progress during burg generation
      ProgressManager.update(82, 'Placing settlements...', 'Scoring land cells for capitals...');

      // Get land cells (use same logic as water detection)
      const isWater = window.__state.isWater || [];
      const landCells = cells.filter((c, i) => !isWater[i] && c.high <= 0.8);
      if (DEBUG) console.log(`Found ${landCells.length} land cells suitable for burgs`);
      
      if (landCells.length === 0) {
        console.log('No suitable land cells for burgs');
        window.__state.burgs = [];
        renderBurgs();
        return;
      }

      // === PHASE 1: Place Capitals (keep existing approach for now) ===
      ProgressManager.update(83, 'Placing settlements...', 'Placing capital cities...');
      
      // Score all land cells for capitals (emphasize strategic locations)
      const capitalCandidates = landCells.map(cell => ({
        cell: cell,
        score: scoreCellForCapital(cell, cells, sea)
      }));

      // Filter out low-scoring cells
      const goodCapitalCandidates = capitalCandidates.filter(c => c.score > 0.15);
      if (DEBUG) console.log(`Found ${goodCapitalCandidates.length} cells with good capital scores (>0.15)`);
      
      if (goodCapitalCandidates.length === 0) {
        console.log('No suitable cells found for capitals');
        window.__state.burgs = [];
        renderBurgs();
        return;
      }

      // Apply Poisson disk sampling for capitals
      const capitalSpacing = +document.getElementById('burgSpacingInput').value * 2 || 24;
      const spacedCapitals = poissonSample(goodCapitalCandidates, capitalSpacing);
      if (DEBUG) console.log(`After capital spacing, ${spacedCapitals.length} candidates remain`);
      
      // Take top N capitals by score
      const pickedCapitals = spacedCapitals.slice(0, capitalCount);
      if (DEBUG) console.log(`Selected ${pickedCapitals.length} capitals from candidates`);
      
      // Create capital burg objects
      const capitals = pickedCapitals.map((p, index) => placeBurg(p.cell, cells, sea, index, 'capital'));
      
      // === PHASE 2: Build Roads First (for economic scoring) ===
      ProgressManager.update(84, 'Placing settlements...', 'Building road network for economic scoring...');
      
      // Build land graph and roads between capitals
      const landGraph = buildLandGraph(cells, isWater);
      window.__state.landGraph = landGraph; // Store for later use
      
      // Build roads between capitals (this will be used for town scoring)
      buildCapitalRoads(capitals);
      
      // === PHASE 3: Place Cities (coastal/river focused) ===
      ProgressManager.update(85, 'Placing settlements...', 'Placing cities with coastal/river focus...');
      
      // Generate cities using coastal/river economic scoring
      const cities = generateCities(cells, capitals, cityCount, null);
      
      // === PHASE 4: Place Villages (inland/road focused) ===
      ProgressManager.update(86, 'Placing settlements...', 'Placing villages with inland/road focus...');
      
      // Generate villages using inland/road economic scoring
      const villages = generateVillages(cells, [...capitals, ...cities], villageCount, null);
      
      // === PHASE 5: Ensure Island Ports ===
      ProgressManager.update(87, 'Placing settlements...', 'Ensuring each island has ports...');
      
      // Combine all settlement types
      let allBurgs = [...capitals, ...cities, ...villages];
      
      // Ensure each island has at least one significant port
      allBurgs = ensureIslandPorts(cells, allBurgs, isWater);
      
      // === PHASE 6: Connect Capitals to Ports ===
      ProgressManager.update(88, 'Placing settlements...', 'Connecting capitals to ports...');
      
      // Connect non-port capitals to nearest ports
      connectCapitalsToPorts(allBurgs, cells, isWater);
      
      // === PHASE 7: Add Spur Roads to Settlements ===
      ProgressManager.update(89, 'Placing settlements...', 'Adding spur roads to settlements...');
      
      // Add spur roads to cities and villages that aren't on existing routes
      [...cities, ...villages].forEach(settlement => {
        ensureSpurToRoad(settlement, isRouteCell, nearestRouteCell, addSpurRoad);
      });
      
      // Store final burgs
      window.__state.burgs = allBurgs;
      
      if (DEBUG) console.log(`Generated ${capitals.length} capitals + ${cities.length} cities + ${villages.length} villages = ${window.__state.burgs.length} total burgs`);
      
      // Debug: Log sample burgs
      if (capitals.length > 0) {
        if (DEBUG) console.log('Sample capital:', capitals[0]);
      }
      if (cities.length > 0) {
        if (DEBUG) console.log('Sample city:', cities[0]);
      }
      if (villages.length > 0) {
        if (DEBUG) console.log('Sample village:', villages[0]);
      }
      
      // Render the burgs
      renderBurgs();
    }

    /**
     * Render burgs using D3 data-join
     */
    function renderBurgs() {
      const burgsG = d3.select('#burgs');
      if (DEBUG) console.log(`Rendering ${window.__state.burgs ? window.__state.burgs.length : 0} burgs`);
      
      // Clear existing burgs
      burgsG.selectAll('*').remove();
      
      if (!window.__state.burgs || window.__state.burgs.length === 0) {
        console.log('No burgs to render');
        return;
      }

      // Create burg symbols
      const burgs = burgsG.selectAll('g.burg')
        .data(window.__state.burgs, d => d.id)
        .enter()
        .append('g')
        .attr('class', 'burg')
        .attr('data-burg-id', d => d.id);

      // Add hit areas for easier tapping on mobile
      burgs.append('circle')
        .attr('class', 'burg-hit')
        .attr('cx', 0)
        .attr('cy', 0)
        .attr('r', 12)                      // tap halo
        .attr('fill', 'transparent')
        .style('pointer-events', 'all');    // ensure it catches taps

      // Add circles for burg symbols with different styles per type
      burgs.append('circle')
        .attr('cx', 0)
        .attr('cy', 0)
        .attr('r', d => {
          if (d.type === 'capital') return 5; // Capitals are largest
          if (d.type === 'city' && d.port) return 6; // Port cities are largest to accommodate anchors
          if (d.type === 'city') return 4; // Cities are large
          if (d.type === 'village') return 2.5; // Villages are smallest
          return 2.5; // Default size
        })
        .each(function(d) {
          // Debug: Log each burg's properties
          if (DEBUG) console.log(`Burg ${d.id}: type=${d.type}, port=${d.port}, x=${d.x}, y=${d.y}`);
          
          let color;
          if (d.type === 'capital') {
            color = '#ff0000'; // Red for capitals
          } else if (d.type === 'city' && d.port) {
            color = '#ffffff'; // White for port cities
          } else if (d.type === 'city') {
            color = '#0066cc'; // Blue for cities
          } else if (d.type === 'village') {
            color = '#ff6600'; // Orange for villages
          } else {
            color = '#ff6600'; // Orange for towns (fallback)
          }
          
                      if (DEBUG) console.log(`Burg ${d.id} assigned color: ${color}`);
          
          // Apply color directly
          d3.select(this)
            .style('fill', color)
            .attr('fill', color);
        })
        .attr('stroke', '#fff')
        .attr('stroke-width', d => {
          if (d.type === 'capital') return '1.2';
          if (d.type === 'city' && d.port) return '1.0';
          if (d.type === 'city') return '0.9';
          return '0.6'; // Villages and others
        })
        .attr('paint-order', 'stroke fill')
        .attr('vector-effect', 'non-scaling-stroke');

      // Add special symbols for capitals (star)
      burgs.filter(d => d.type === 'capital')
        .append('text')
        .attr('x', 0)
        .attr('y', 1)
        .attr('text-anchor', 'middle')
        .attr('dominant-baseline', 'middle')
        .attr('font-size', '7px')
        .attr('fill', '#fff')
        .attr('stroke', '#000')
        .attr('stroke-width', '0.5')
        .attr('paint-order', 'stroke fill')
        .attr('vector-effect', 'non-scaling-stroke')
        .style('pointer-events', 'all')    // ensure capital symbols are tappable
        .text('★');

      // Add port symbols for ports (anchor) - only cities can be ports
      burgs.filter(d => d.port && d.type === 'city')
        .append('text')
        .attr('x', 0)
        .attr('y', 1)
        .attr('text-anchor', 'middle')
        .attr('dominant-baseline', 'middle')
        .attr('font-size', '8px')
        .attr('fill', '#fff')
        .attr('stroke', '#000')
        .attr('stroke-width', '0.5')
        .attr('paint-order', 'stroke fill')
        .attr('vector-effect', 'non-scaling-stroke')
        .style('pointer-events', 'all')    // ensure port symbols are tappable
        .text('⚓');

      if (DEBUG) console.log(`Rendered ${window.__state.burgs.length} burgs`);
      
      // Debug: Log burg types and colors
      if (window.__state.burgs && window.__state.burgs.length > 0) {
        if (DEBUG) console.log('Burg types:', window.__state.burgs.map(b => ({ id: b.id, type: b.type, port: b.port, isPort: b.isPort, x: b.x, y: b.y })));
                  if (DEBUG) console.log('First few burgs:', window.__state.burgs.slice(0, 3));
        
        // Debug: Check what colors are actually applied to DOM elements
        const burgCircles = document.querySelectorAll('#burgs circle');
        if (DEBUG) console.log('Burg circles found:', burgCircles.length);
        if (burgCircles.length > 0) {
                      if (DEBUG) console.log('First circle fill:', burgCircles[0].getAttribute('fill'), burgCircles[0].style.fill);
        }
      }
      
      // Position burgs at current zoom level
      if (window.updateBurgPositions) {
        if (DEBUG) console.log('Calling updateBurgPositions after rendering burgs');
        window.updateBurgPositions(window.currentTransform);
      } else if (DEBUG) {
        console.warn('updateBurgPositions not available');
      }
    }

    // --- Azgaar-Style Economic Town Placement ---
    
    // Town placement weights (configurable)
    const TOWN_WEIGHTS = {
      wElev:  1.0,     // penalty for elevation
      wRiver: 0.18,    // bonus ~ river flux
      wHarbor: 0.8,    // bonus for sheltered coast
      wPath:  0.65,    // bonus for road usage (sqrt)
      wCross: 0.9,     // bonus for crossroads (deg-1)
      wNearRoad: 0.0,  // (optional) small penalty by distance to nearest road
      jitter: 0.05     // % noise of total score
    };

    // City weights - focused on coastal/river access and trade
    const CITY_WEIGHTS = {
      wElev:  0.8,     // less penalty for elevation (cities can be on hills)
      wRiver: 0.4,     // strong bonus for rivers (trade routes)
      wHarbor: 1.2,    // very strong bonus for harbors (trade)
      wCoast: 0.6,     // bonus for coastal access
      wPath:  0.4,     // moderate bonus for road usage
      wCross: 0.7,     // moderate bonus for crossroads
      wNearRoad: 0.0,  // no penalty for distance to roads
      jitter: 0.03     // less randomness for cities
    };

    // Village weights - focused on inland development and agriculture
    const VILLAGE_WEIGHTS = {
      wElev:  1.2,     // strong penalty for elevation (villages prefer flat land)
      wRiver: 0.15,    // moderate bonus for rivers (water source)
      wHarbor: 0.0,    // no bonus for harbors (inland)
      wCoast: 0.0,     // no bonus for coast (inland)
      wPath:  0.8,     // strong bonus for road usage (connectivity)
      wCross: 1.1,     // strong bonus for crossroads (trade)
      wFlat:  0.9,     // bonus for flat land (agriculture)
      wNearRoad: 0.1,  // small penalty for being far from roads
      jitter: 0.08     // more randomness for villages
    };

    /**
     * Build road usage data for economic scoring
     * @param {Object} routeData - Object containing routes and trails arrays
     * @param {Array} cells - All cells array
     */
    function buildRoadUsage(routeData, cells) {
      // Zero out road usage data
      for (const c of cells) { 
        c.path = 0; 
        c.cross = 0; 
      }
      
      // Count how many times each cell appears in any land route
      const touchBy = new Map(); // cellId -> Set(cellId neighbors touched by a route)
      
      const bump = (id, nextId) => {
        if (id == null) return;
        cells[id].path++;
        if (nextId != null) {
          let S = touchBy.get(id);
          if (!S) { S = new Set(); touchBy.set(id, S); }
          S.add(nextId);
        }
      };

      const visit = (segments) => {
        for (const seg of segments) {
          // seg should be an array of cell indices along the path (inclusive)
          for (let i = 0; i < seg.length; i++) {
            bump(seg[i], seg[i+1]);
            bump(seg[i], seg[i-1]);
          }
        }
      };

      visit(routeData.routes || []);
      visit(routeData.trails || []);

      // crossroads = number of *distinct* neighbors a route touches from this cell
      for (const [id, set] of touchBy.entries()) {
        cells[id].cross = set.size; // deg along route network
      }
      
      if (DEBUG) console.log(`Road usage built: ${cells.filter(c => c.path > 0).length} cells have road usage`);
    }

    /**
     * Calculate geographic score for a cell
     * @param {Object} c - Cell object
     * @returns {number} Geographic score
     */
    function geographicScore(c) {
      const elevP = Math.max(0, 1 - c.high);         // lowland best
      const riverB = Math.sqrt(Math.max(0, c.riverFlux || 0));
      const harborB = c.hasHarbor ? 1 : 0;
      return TOWN_WEIGHTS.wElev * elevP
           + TOWN_WEIGHTS.wRiver * riverB
           + TOWN_WEIGHTS.wHarbor * harborB;
    }

    /**
     * Calculate city geographic score (coastal/river focused)
     * @param {Object} c - Cell object
     * @param {Array} cells - All cells array
     * @param {Array} isWater - Water mask array
     * @returns {number} City geographic score
     */
    function cityGeographicScore(c, cells, isWater) {
      const elevP = Math.max(0, 1 - c.high);         // lowland preferred
      const riverB = Math.sqrt(Math.max(0, c.riverFlux || 0));
      const harborB = c.hasHarbor ? 1 : 0;
      
      // Calculate coastal access
      let coastB = 0;
      let minWaterDist = Infinity;
      for (let i = 0; i < cells.length; i++) {
        if (isWater[i]) {
          const dist = Math.hypot(c.cx - cells[i].cx, c.cy - cells[i].cy);
          minWaterDist = Math.min(minWaterDist, dist);
        }
      }
      if (minWaterDist < 50) { // Within 50px of water
        coastB = Math.max(0, 1 - (minWaterDist / 50));
      }
      
      return CITY_WEIGHTS.wElev * elevP
           + CITY_WEIGHTS.wRiver * riverB
           + CITY_WEIGHTS.wHarbor * harborB
           + CITY_WEIGHTS.wCoast * coastB;
    }

    /**
     * Calculate village geographic score (inland/agriculture focused)
     * @param {Object} c - Cell object
     * @param {Array} cells - All cells array
     * @param {Array} isWater - Water mask array
     * @returns {number} Village geographic score
     */
    function villageGeographicScore(c, cells, isWater) {
      const elevP = Math.max(0, 1 - c.high);         // flat land preferred
      const riverB = Math.sqrt(Math.max(0, c.riverFlux || 0));
      const flatB = Math.max(0, 1 - c.high);         // flat land bonus for agriculture
      
      // Calculate distance to nearest road for penalty
      let nearRoadDist = 0;
      if (VILLAGE_WEIGHTS.wNearRoad > 0) {
        // Simple distance calculation - could be optimized
        let minRoadDist = Infinity;
        for (let i = 0; i < cells.length; i++) {
          if ((cells[i].path || 0) > 0) {
            const dist = Math.hypot(c.cx - cells[i].cx, c.cy - cells[i].cy);
            minRoadDist = Math.min(minRoadDist, dist);
          }
        }
        nearRoadDist = minRoadDist < Infinity ? minRoadDist : 100; // Default penalty if no roads
      }
      
      return VILLAGE_WEIGHTS.wElev * elevP
           + VILLAGE_WEIGHTS.wRiver * riverB
           + VILLAGE_WEIGHTS.wFlat * flatB
           - VILLAGE_WEIGHTS.wNearRoad * nearRoadDist;
    }

    /**
     * Calculate economic score for a cell
     * @param {Object} c - Cell object
     * @param {number} nearestRoadDist - Distance to nearest road (optional)
     * @returns {number} Economic score
     */
    function economicScore(c, nearestRoadDist = 0) {
      const pathB = Math.sqrt(c.path || 0);
      const crossB = Math.max(0, (c.cross || 0) - 1);
      const nearRoadPenalty = (TOWN_WEIGHTS.wNearRoad > 0) ? (nearestRoadDist * TOWN_WEIGHTS.wNearRoad) : 0;
      return TOWN_WEIGHTS.wPath * pathB
           + TOWN_WEIGHTS.wCross * crossB
           - nearRoadPenalty;
    }

    /**
     * Calculate city economic score (trade focused)
     * @param {Object} c - Cell object
     * @returns {number} City economic score
     */
    function cityEconomicScore(c) {
      const pathB = Math.sqrt(c.path || 0);
      const crossB = Math.max(0, (c.cross || 0) - 1);
      return CITY_WEIGHTS.wPath * pathB
           + CITY_WEIGHTS.wCross * crossB;
    }

    /**
     * Calculate village economic score (connectivity focused)
     * @param {Object} c - Cell object
     * @returns {number} Village economic score
     */
    function villageEconomicScore(c) {
      const pathB = Math.sqrt(c.path || 0);
      const crossB = Math.max(0, (c.cross || 0) - 1);
      return VILLAGE_WEIGHTS.wPath * pathB
           + VILLAGE_WEIGHTS.wCross * crossB;
    }

    /**
     * Add random jitter to scores
     * @param {number} base - Base score
     * @returns {number} Score with jitter
     */
    function randomJitter(base) {
      const j = TOWN_WEIGHTS.jitter;
      return base * ((Math.random() * 2 * j) - j); // ±j%
    }

    /**
     * Add random jitter to city scores
     * @param {number} base - Base score
     * @returns {number} Score with jitter
     */
    function cityRandomJitter(base) {
      const j = CITY_WEIGHTS.jitter;
      return base * ((Math.random() * 2 * j) - j); // ±j%
    }

    /**
     * Add random jitter to village scores
     * @param {number} base - Base score
     * @returns {number} Score with jitter
     */
    function villageRandomJitter(base) {
      const j = VILLAGE_WEIGHTS.jitter;
      return base * ((Math.random() * 2 * j) - j); // ±j%
    }

    /**
     * Generate cities using coastal/river economic approach
     * @param {Array} cells - All cells array
     * @param {Array} capitals - Array of capital burgs
     * @param {number} targetCityCount - Number of cities to generate
     * @param {Function} nameFor - Name generation function
     * @returns {Array} Array of city burgs
     */
    function generateCities(cells, capitals, targetCityCount, nameFor) {
      const sea = +document.getElementById('seaLevelInput').value;
      const isWater = window.__state.isWater || [];
      
      // Mark capitals + neighbors as reserved
      const used = new Uint8Array(cells.length);
      for (const cap of capitals) {
        used[cap.cell] = 1;
        for (const n of cells[cap.cell].neighbors) used[n] = 1;
      }

      // Score all land cells for cities
      const scored = [];
      for (let i = 0; i < cells.length; i++) {
        const c = cells[i];
        if (isWater[i] || used[i]) continue;
        
        const geoScore = cityGeographicScore(c, cells, isWater);
        const econScore = cityEconomicScore(c);
        const base = geoScore + econScore;
        const score = base + cityRandomJitter(base);
        scored.push({i, score});
      }

      scored.sort((a, b) => b.score - a.score);

      const cities = [];
      for (const s of scored) {
        if (cities.length >= targetCityCount) break;
        if (used[s.i]) continue;
        const c = cells[s.i];
        if (isWater[s.i]) continue;

        // Place city (burg)
        const city = {
          cell: s.i,
          x: c.cx, 
          y: c.cy,
          type: "city",
          name: nameFor ? nameFor(c) : null,
          id: capitals.length + cities.length,
          population: 2000,
          port: false,
          onRiver: false
        };
        
        // Determine if it's a port (near coast)
        let minWaterDist = Infinity;
        for (let i = 0; i < cells.length; i++) {
          if (isWater[i]) {
            const dist = Math.hypot(c.cx - cells[i].cx, c.cy - cells[i].cy);
            minWaterDist = Math.min(minWaterDist, dist);
          }
        }
        city.port = minWaterDist < 25; // Within 25px of water
        
        // Cities can be ports (significant settlements)
        if (city.port) {
          city.isSignificantPort = true; // Mark as significant port
        }
        
        // Determine if it's on a river
        c.neighbors.forEach(nb => {
          const neighborCell = cells[nb];
          const isWaterNeighbor = isWater[nb];
          const isLake = window.__state.isLake && window.__state.isLake[nb] === 1;
          if (isWaterNeighbor && !isLake) {
            city.onRiver = true;
          }
        });

        // Generate name if not provided
        if (!city.name) {
          city.name = BURG_NAMES[city.id % BURG_NAMES.length] + 
                     (city.id > BURG_NAMES.length - 1 ? ` ${Math.floor(city.id / BURG_NAMES.length) + 1}` : '');
        }

        cities.push(city);

        // Block this cell + neighbors
        used[s.i] = 1;
        for (const n of c.neighbors) used[n] = 1;
      }

      console.log(`Generated ${cities.length} cities using coastal/river economic scoring`);
      return cities;
    }

    /**
     * Generate villages using inland/road economic approach
     * @param {Array} cells - All cells array
     * @param {Array} existingBurgs - Array of existing burgs (capitals + cities)
     * @param {number} targetVillageCount - Number of villages to generate
     * @param {Function} nameFor - Name generation function
     * @returns {Array} Array of village burgs
     */
    function generateVillages(cells, existingBurgs, targetVillageCount, nameFor) {
      const sea = +document.getElementById('seaLevelInput').value;
      const isWater = window.__state.isWater || [];
      
      // Mark existing burgs + neighbors as reserved
      const used = new Uint8Array(cells.length);
      for (const burg of existingBurgs) {
        used[burg.cell] = 1;
        for (const n of cells[burg.cell].neighbors) used[n] = 1;
      }

      // Score all land cells for villages
      const scored = [];
      for (let i = 0; i < cells.length; i++) {
        const c = cells[i];
        if (isWater[i] || used[i]) continue;
        
        const geoScore = villageGeographicScore(c, cells, isWater);
        const econScore = villageEconomicScore(c);
        const base = geoScore + econScore;
        const score = base + villageRandomJitter(base);
        scored.push({i, score});
      }

      scored.sort((a, b) => b.score - a.score);

      const villages = [];
      for (const s of scored) {
        if (villages.length >= targetVillageCount) break;
        if (used[s.i]) continue;
        const c = cells[s.i];
        if (isWater[s.i]) continue;

        // Place village (burg)
        const village = {
          cell: s.i,
          x: c.cx, 
          y: c.cy,
          type: "village",
          name: nameFor ? nameFor(c) : null,
          id: existingBurgs.length + villages.length,
          population: 500,
          port: false,
          onRiver: false
        };
        
        // Villages should not be ports (ports must be significant settlements)
        village.port = false; // Villages cannot be ports
        village.isSignificantPort = false;
        
        // Determine if it's on a river
        c.neighbors.forEach(nb => {
          const neighborCell = cells[nb];
          const isWaterNeighbor = isWater[nb];
          const isLake = window.__state.isLake && window.__state.isLake[nb] === 1;
          if (isWaterNeighbor && !isLake) {
            village.onRiver = true;
          }
        });

        // Generate name if not provided
        if (!village.name) {
          village.name = BURG_NAMES[village.id % BURG_NAMES.length] + 
                        (village.id > BURG_NAMES.length - 1 ? ` ${Math.floor(village.id / BURG_NAMES.length) + 1}` : '');
        }

        villages.push(village);

        // Block this cell + neighbors
        used[s.i] = 1;
        for (const n of c.neighbors) used[n] = 1;
      }

      console.log(`Generated ${villages.length} villages using inland/road economic scoring`);
      return villages;
    }

    /**
     * Ensure each island has at least one significant port
     * @param {Array} cells - All cells array
     * @param {Array} allBurgs - Array of all burgs (capitals + cities + villages)
     * @param {Array} isWater - Water mask array
     * @returns {Array} Updated burgs array with port assignments
     */
    function ensureIslandPorts(cells, allBurgs, isWater) {
      // Group burgs by island (connected land components)
      const islandGroups = findConnectedComponents(allBurgs, cells, isWater);
      
      for (let islandIndex = 0; islandIndex < islandGroups.length; islandIndex++) {
        const islandBurgs = islandGroups[islandIndex];
        const ports = islandBurgs.filter(burg => burg.isSignificantPort);
        
        if (ports.length === 0) {
          // No ports on this island - find best candidate
          console.log(`Island ${islandIndex} has no ports, finding best candidate...`);
          
          let bestPortCandidate = null;
          let bestPortScore = -1;
          
          for (const burg of islandBurgs) {
            if (burg.type !== 'city') continue; // Only cities can be ports
            
            // Calculate port suitability score
            let portScore = 0;
            
            // Cities are the only port candidates
            portScore += 10;
            
            // Check coastal proximity
            let minWaterDist = Infinity;
            for (let i = 0; i < cells.length; i++) {
              if (isWater[i]) {
                const dist = Math.hypot(burg.x - cells[i].cx, burg.y - cells[i].cy);
                minWaterDist = Math.min(minWaterDist, dist);
              }
            }
            
            if (minWaterDist < 50) { // Within 50px of water
              portScore += Math.max(0, 20 - minWaterDist); // Closer = better
            }
            
            if (portScore > bestPortScore) {
              bestPortScore = portScore;
              bestPortCandidate = burg;
            }
          }
          
          if (bestPortCandidate) {
            bestPortCandidate.port = true;
            bestPortCandidate.isSignificantPort = true;
            console.log(`Promoted ${bestPortCandidate.type} ${bestPortCandidate.id} to port on island ${islandIndex}`);
          } else {
            console.log(`No suitable port candidate found on island ${islandIndex}`);
          }
        }
      }
      
      return allBurgs;
    }

    /**
     * Connect capitals to nearest ports with primary roads
     * @param {Array} allBurgs - Array of all burgs
     * @param {Array} cells - All cells array
     * @param {Array} isWater - Water mask array
     */
    function connectCapitalsToPorts(allBurgs, cells, isWater) {
      const capitals = allBurgs.filter(burg => burg.type === 'capital');
      const ports = allBurgs.filter(burg => burg.isSignificantPort);
      
      if (ports.length === 0) {
        console.log('No ports found, skipping capital-to-port connections');
        return;
      }
      
      // Group burgs by island for regional connections
      const islandGroups = findConnectedComponents(allBurgs, cells, isWater);
      
      for (const capital of capitals) {
        // Capitals are never significant ports, so always connect them
        
        // Find capital's island
        let capitalIsland = null;
        for (let i = 0; i < islandGroups.length; i++) {
          if (islandGroups[i].some(burg => burg.id === capital.id)) {
            capitalIsland = i;
            break;
          }
        }
        
        if (capitalIsland === null) continue;
        
        // Find nearest port on same island
        const islandPorts = islandGroups[capitalIsland].filter(burg => burg.isSignificantPort);
        
        if (islandPorts.length === 0) {
          console.log(`No ports on capital ${capital.id}'s island, skipping connection`);
          continue;
        }
        
        // Find closest port
        let nearestPort = null;
        let minDist = Infinity;
        
        for (const port of islandPorts) {
          const dist = Math.hypot(capital.x - port.x, capital.y - port.y);
          if (dist < minDist) {
            minDist = dist;
            nearestPort = port;
          }
        }
        
        if (nearestPort) {
          console.log(`Connecting capital ${capital.id} to port ${nearestPort.id} (distance: ${minDist.toFixed(1)}px)`);
          
          // Build road from capital to port
          const landGraph = window.__state.landGraph;
          if (landGraph) {
            const pathCells = shortestPath(capital.cell, nearestPort.cell, landGraph, new Set(), new Set());
            if (pathCells && pathCells.length > 0) {
              // Add as primary road (thicker line)
              addPrimaryRoad(pathCells, {kind: "capital-to-port"});
            }
          }
        }
      }
    }

    /**
     * Add a primary road (thicker than regular roads)
     * @param {Array} pathCells - Array of cell indices forming the path
     * @param {Object} options - Road options
     */
    function addPrimaryRoad(pathCells, options = {}) {
      const roadsG = d3.select('#routes .roads');
      if (roadsG.empty()) return;
      
      // Create primary road path
      const pathCoords = pathCells.map(cellId => {
        const cell = window.__state.cells[cellId];
        return [cell.cx, cell.cy];
      });
      
      const line = d3.line()
        .x(d => d[0])
        .y(d => d[1])
        .curve(d3.curveBasis);
      
      roadsG.append('path')
        .attr('class', 'primary-road')
        .attr('d', line(pathCoords))
        .attr('stroke', '#8B4513') // Brown color for primary roads
        .attr('stroke-width', '3px') // Thicker than regular roads
        .attr('fill', 'none')
        .attr('stroke-linecap', 'round')
        .attr('stroke-linejoin', 'round')
        .attr('vector-effect', 'non-scaling-stroke');
    }

    /**
     * Generate towns using Azgaar's economic approach
     * @param {Array} cells - All cells array
     * @param {Array} capitals - Array of capital burgs
     * @param {number} targetTownCount - Number of towns to generate
     * @param {Function} nameFor - Name generation function
     * @returns {Array} Array of town burgs
     */
    function generateTowns(cells, capitals, targetTownCount, nameFor) {
      const sea = +document.getElementById('seaLevelInput').value;
      const isWater = window.__state.isWater || [];
      
      // Mark capitals + neighbors as reserved
      const used = new Uint8Array(cells.length);
      for (const cap of capitals) {
        used[cap.cell] = 1;
        for (const n of cells[cap.cell].neighbors) used[n] = 1;
      }

      // Score all land cells
      const scored = [];
      for (let i = 0; i < cells.length; i++) {
        const c = cells[i];
        if (isWater[i] || used[i]) continue;
        
        const base = (c.geoScore ?? geographicScore(c)) + economicScore(c, 0);
        const score = base + randomJitter(base);
        scored.push({i, score});
      }

      scored.sort((a, b) => b.score - a.score);

      const towns = [];
      for (const s of scored) {
        if (towns.length >= targetTownCount) break;
        if (used[s.i]) continue;
        const c = cells[s.i];
        if (isWater[s.i]) continue;

        // Place town (burg)
        const town = {
          cell: s.i,
          x: c.cx, 
          y: c.cy,
          type: "town",
          name: nameFor ? nameFor(c) : null,
          id: capitals.length + towns.length,
          population: 1000,
          port: false,
          onRiver: false
        };
        
        // Determine if it's a port (near coast)
        let minWaterDist = Infinity;
        for (let i = 0; i < cells.length; i++) {
          if (isWater[i]) {
            const dist = Math.hypot(c.cx - cells[i].cx, c.cy - cells[i].cy);
            minWaterDist = Math.min(minWaterDist, dist);
          }
        }
        town.port = minWaterDist < 15; // Within 15px of water
        
        // Determine if it's on a river
        c.neighbors.forEach(nb => {
          const neighborCell = cells[nb];
          const isWaterNeighbor = isWater[nb];
          const isLake = window.__state.isLake && window.__state.isLake[nb] === 1;
          if (isWaterNeighbor && !isLake) {
            town.onRiver = true;
          }
        });

        // Generate name if not provided
        if (!town.name) {
          town.name = BURG_NAMES[town.id % BURG_NAMES.length] + 
                     (town.id > BURG_NAMES.length - 1 ? ` ${Math.floor(town.id / BURG_NAMES.length) + 1}` : '');
        }

        towns.push(town);

        // Block this cell + neighbors
        used[s.i] = 1;
        for (const n of c.neighbors) used[n] = 1;
      }

      console.log(`Generated ${towns.length} towns using economic scoring`);
      return towns;
    }

    /**
     * Ensure towns have spur roads to the network
     * @param {Object} town - Town burg object
     * @param {Function} isRouteCell - Function to check if cell is on a route
     * @param {Function} nearestRouteCellFn - Function to find nearest route cell
     * @param {Function} addRoadPathFn - Function to add road path
     */
    function ensureSpurToRoad(town, isRouteCell, nearestRouteCellFn, addRoadPathFn) {
      const id = town.cell;
      if (isRouteCell(id)) return;
      
      const toId = nearestRouteCellFn(id);
      if (toId == null) return;
      
      const landGraph = window.__state.landGraph;
      if (!landGraph) return;
      
      const pathCells = shortestPath(id, toId, landGraph, new Set(), new Set());
      if (pathCells && pathCells.length) {
        addRoadPathFn(pathCells, {kind: "spur"});
      }
    }

    /**
     * Check if a cell is on a route
     * @param {number} cellId - Cell index
     * @returns {boolean} True if cell is on a route
     */
    function isRouteCell(cellId) {
      const cells = window.__state.cells;
      if (!cells || !cells[cellId]) return false;
      return (cells[cellId].path || 0) > 0;
    }

    /**
     * Find nearest cell that's on a route
     * @param {number} cellId - Starting cell index
     * @returns {number|null} Nearest route cell index or null
     */
    function nearestRouteCell(cellId) {
      const cells = window.__state.cells;
      if (!cells || !cells[cellId]) return null;
      
      // Simple BFS to find nearest route cell
      const visited = new Set();
      const queue = [{cell: cellId, dist: 0}];
      
      while (queue.length > 0) {
        const {cell, dist} = queue.shift();
        if (visited.has(cell)) continue;
        visited.add(cell);
        
        if (isRouteCell(cell)) {
          return cell;
        }
        
        // Add neighbors to queue
        const cellObj = cells[cell];
        if (cellObj && cellObj.neighbors) {
          for (const neighbor of cellObj.neighbors) {
            if (!visited.has(neighbor)) {
              queue.push({cell: neighbor, dist: dist + 1});
            }
          }
        }
      }
      
      return null;
    }

    /**
     * Add a spur road path
     * @param {Array} pathCells - Array of cell indices forming the path
     * @param {Object} options - Path options
     */
    function addSpurRoad(pathCells, options) {
      if (!pathCells || pathCells.length < 2) return;
      
      const cells = window.__state.cells;
      const points = pathCells.map(cellId => [cells[cellId].cx, cells[cellId].cy]);
      
      const line = d3.line().x(d => d[0]).y(d => d[1]).curve(d3.curveBasis);
      const smoothed = smoothLine(points, 1);
      
      // Add to trails (spurs are local connections)
      const trailsG = d3.select('#routes .trails');
      trailsG.append('path')
        .attr('d', line(smoothed))
        .attr('fill', 'none')
        .attr('stroke', '#9b7b3a')
        .attr('stroke-width', '0.8px')
        .attr('stroke-dasharray', '2 2')
        .attr('stroke-linecap', 'round')
        .attr('stroke-linejoin', 'round')
        .attr('vector-effect', 'non-scaling-stroke');
      
      console.log(`Added spur road with ${pathCells.length} cells`);
    }

    // --- Routes System ---
    
    /**
     * Build a navigation graph over land cells
     * @param {Array} cells - All cells array
     * @param {Array} isWater - Water mask array
     * @returns {Object} Graph with nodes and edges
     */
    function buildLandGraph(cells, isWater) {
      // Check cache first
      if (GraphCache.land) {
        if (DEBUG) console.log('buildLandGraph: using cached graph');
        return GraphCache.land;
      }
      
      const nodes = [];
      const edges = [];
      
      // Create nodes for all land cells
      for (let i = 0; i < cells.length; i++) {
        if (!isWater[i]) {
          nodes.push({ i: i, x: cells[i].cx, y: cells[i].cy, high: cells[i].high });
        }
      }
      
      // Create edges between neighboring land cells
      for (let i = 0; i < cells.length; i++) {
        if (isWater[i]) continue; // Skip water cells
        
        const cell = cells[i];
        for (const neighborIndex of cell.neighbors) {
          if (neighborIndex > i && !isWater[neighborIndex]) { // Avoid duplicate edges
            const neighbor = cells[neighborIndex];
            const dist = Math.hypot(cell.cx - neighbor.cx, cell.cy - neighbor.cy);
            const slope = Math.abs(cell.high - neighbor.high);
            const riverCross = crossesRiverSegment(cell, neighbor) ? 1 : 0;
            
            const slopePenalty = +document.getElementById('slopePenaltyInput').value || 1.2;
            const riverPenalty = +document.getElementById('riverPenaltyInput').value || 1.0;
            
            const w = dist * (1 + slope * slopePenalty + riverCross * riverPenalty);
            
            edges.push({
              u: i,
              v: neighborIndex,
              dist: dist,
              slope: slope,
              riverCross: riverCross,
              w: w
            });
          }
        }
      }
      
      if (DEBUG) console.log(`buildLandGraph: created ${nodes.length} nodes and ${edges.length} edges`);
      
      // Cache the graph for reuse
      finalizeLandGraph(cells.length, edges);
      
      return { nodes, edges };
    }
    
    /**
     * Check if a path crosses a river segment
     * @param {Object} cellA - First cell
     * @param {Object} cellB - Second cell
     * @returns {boolean} True if path crosses a river
     */
    function crossesRiverSegment(cellA, cellB) {
      // Simplified check: just return false for now to avoid potential issues
      // TODO: Implement proper river crossing detection
      return false;
    }
    
    /**
     * A* pathfinding algorithm for land navigation using edge weights
     * @param {number} startIndex - Starting cell index
     * @param {number} endIndex - Ending cell index
     * @param {Object} graph - Land graph
     * @param {Set} usedEdges - Set of already-used edges for road reuse discount
     * @param {Set} burgCells - Set of burg cell indices for pass-through bonus
     * @returns {Array} Path as array of cell indices
     */
    function shortestPath(startIndex, endIndex, graph, usedEdges = new Set(), burgCells = new Set()) {
      const cells = window.__state.cells;
      const isWater = window.__state.isWater || [];
      
      // Debug logging (only for first few calls)
      if (window.__state.shortestPathCallCount === undefined) {
        window.__state.shortestPathCallCount = 0;
      }
      window.__state.shortestPathCallCount++;
      
      if (DEBUG && window.__state.shortestPathCallCount <= 5) {
        console.log(`shortestPath called: start=${startIndex}, end=${endIndex}, graph edges=${graph?.edges?.length || 0}`);
      }
      
      // Skip if start or end is water
      if (isWater[startIndex] || isWater[endIndex]) {
        if (DEBUG) console.log(`shortestPath: start or end is water (start: ${isWater[startIndex]}, end: ${isWater[endIndex]})`);
        return null;
      }
      
      // Check if start and end are the same
      if (startIndex === endIndex) {
        if (DEBUG) console.log(`shortestPath: start and end are the same (${startIndex})`);
        return [startIndex];
      }
      
      // Validate graph
      if (!graph || !graph.edges || graph.edges.length === 0) {
        if (DEBUG) console.warn(`shortestPath: invalid or empty graph provided`);
        return null;
      }
      
      // Use cached graph if available
      const G = GraphCache.land;
      if (!G) {
        if (DEBUG) console.warn(`shortestPath: no cached land graph available`);
        return null;
      }
      
      const N = G.nodesCount;
      const neighbors = G.neighbors;
      const cost = (u,v)=> G.edgeCost.get(`${u}:${v}`) ?? 1;

      // Heuristic: straight-line in cell coords if available, else zero
      const H = (a,b)=> 0; // keep admissible; replace if you have xy[] per node

      const INF = 1e20;
      // Typed arrays
      const gScore = new Float64Array(N); gScore.fill(INF);
      const fScore = new Float64Array(N); fScore.fill(INF);
      const cameFrom = new Int32Array(N); cameFrom.fill(-1);
      const inOpen = new Uint8Array(N);

      gScore[startIndex]=0; fScore[startIndex]=H(startIndex, endIndex);

      const open = new MinHeap(i => fScore[i]); open.push(startIndex); inOpen[startIndex]=1;
      let safety=0, MAX_ITERS = N*20;

      while (open.size) {
        if (++safety > MAX_ITERS) break; // safety valve
        const current = open.pop();
        inOpen[current]=0;
        if (current===endIndex) return reconstructPath(cameFrom, current);

        const nbrs = neighbors[current];
        for (let k=0;k<nbrs.length;k++){
          const n = nbrs[k];
          const tentative = gScore[current] + cost(current, n);
          if (tentative < gScore[n]) {
            cameFrom[n] = current;
            gScore[n] = tentative;
            fScore[n] = tentative + H(n, endIndex);
            if (!inOpen[n]) { open.push(n); inOpen[n]=1; }
          }
        }
      }

      // Fallback BFS (unweighted) for robustness
      return bfsFallback(startIndex, endIndex, neighbors);
    }

    function reconstructPath(cameFrom, cur){
      const out = [cur];
      while (cameFrom[cur] !== -1) { cur = cameFrom[cur]; out.push(cur); }
      out.reverse(); return out;
    }
    
    function bfsFallback(start, goal, neighbors){
      const q=[start], prev = new Map([[start,-1]]); let i=0;
      while (i<q.length) {
        const u = q[i++];
        if (u===goal) break;
        for (const v of neighbors[u]) if (!prev.has(v)){ prev.set(v,u); q.push(v); }
      }
      if (!prev.has(goal)) return [];
      const path=[goal]; let x=goal;
      while (prev.get(x)!==-1){ x = prev.get(x); path.push(x); }
      return path.reverse();
    }
    
    /**
     * Admissible heuristic function for A* (straight-line distance)
     * @param {number} a - Cell index
     * @param {number} b - Cell index  
     * @param {Array} cells - All cells array
     * @returns {number} Heuristic value
     */
    function heuristic(a, b, cells) {
      const dx = cells[a].cx - cells[b].cx;
      const dy = cells[a].cy - cells[b].cy;
      const d = Math.hypot(dx, dy);
      // Use Euclidean distance directly - it's admissible and non-negative
      return Math.max(0, d);
    }

    /**
     * Calculate the total cost of a path using edge weights from land graph
     * @param {Array} path - Array of cell indices
     * @param {Object} landGraph - Land graph with edges
     * @returns {number} Total path cost
     */
    function calculatePathCost(path, landGraph) {
      if (path.length < 2) return 0;
      
      // Create edge lookup map
      const edgeMap = new Map();
      for (const edge of landGraph.edges) {
        const key = `${Math.min(edge.a, edge.b)}-${Math.max(edge.a, edge.b)}`;
        edgeMap.set(key, edge);
      }
      
      let totalCost = 0;
      for (let i = 1; i < path.length; i++) {
        const prev = path[i - 1];
        const curr = path[i];
        const edgeKey = `${Math.min(prev, curr)}-${Math.max(prev, curr)}`;
        const edge = edgeMap.get(edgeKey);
        
        if (edge) {
          totalCost += edge.w; // Use precomputed edge weight
        } else {
          // Fallback to Euclidean distance
          const prevCell = window.__state.cells[prev];
          const currCell = window.__state.cells[curr];
          totalCost += Math.hypot(prevCell.cx - currCell.cx, prevCell.cy - currCell.cy);
        }
      }
      
      return totalCost;
    }
    
    /**
     * Mark all edges in a path as used for road reuse discount
     * @param {Array} path - Array of cell indices
     * @param {Set} usedEdges - Set to track used edges
     */
    function markPathEdgesAsUsed(path, usedEdges) {
      for (let i = 1; i < path.length; i++) {
        const prev = path[i - 1];
        const curr = path[i];
        const edgeKey = `${Math.min(prev, curr)}-${Math.max(prev, curr)}`;
        usedEdges.add(edgeKey);
      }
    }
    
    /**
     * Calculate the total cost of a sea path using edge weights from sea graph
     * @param {Array} path - Array of cell indices
     * @param {Object} seaGraph - Sea graph with edges
     * @returns {number} Total path cost
     */
    function calculateSeaPathCost(path, seaGraph) {
      if (path.length < 2) return 0;
      
      // Create edge lookup map
      const edgeMap = new Map();
      for (const edge of seaGraph.edges) {
        const key = `${Math.min(edge.u, edge.v)}-${Math.max(edge.u, edge.v)}`;
        edgeMap.set(key, edge);
      }
      
      let totalCost = 0;
      for (let i = 1; i < path.length; i++) {
        const prev = path[i - 1];
        const curr = path[i];
        const edgeKey = `${Math.min(prev, curr)}-${Math.max(prev, curr)}`;
        const edge = edgeMap.get(edgeKey);
        
        if (edge) {
          totalCost += edge.w; // Use precomputed edge weight with offshore bias
        } else {
          // Fallback to Euclidean distance
          const prevCell = window.__state.cells[prev];
          const currCell = window.__state.cells[curr];
          totalCost += Math.hypot(prevCell.cx - currCell.cx, prevCell.cy - currCell.cy);
        }
      }
      
      return totalCost;
    }
    
    // --- caching single-source shortest paths for sea graph ---
    const seaSSSPCache = new Map(); // key: sourceNodeId -> {dist: Map, prev: Map}
    
    /**
     * Get cached single-source shortest path results for sea graph
     * @param {number} sourceNodeId - Starting water node
     * @param {Object} graph - Sea navigation graph
     * @param {Set} usedEdges - Set of already-used edges for reuse penalty
     * @returns {Object} {dist: Map, prev: Map} distances and predecessors
     */
    function getSeaSSSP(sourceNodeId, graph, usedEdges = new Set()) {
      const cacheKey = `${sourceNodeId}-${usedEdges.size}`; // Include usedEdges in cache key
      if (seaSSSPCache.has(cacheKey)) {
        return seaSSSPCache.get(cacheKey);
      }
      
      const {dist, prev} = dijkstraSea(sourceNodeId, graph, usedEdges);
      seaSSSPCache.set(cacheKey, {dist, prev});
      return {dist, prev};
    }
    
    /**
     * Reconstruct path from predecessors map
     * @param {Map} prev - Predecessors map
     * @param {number} targetNodeId - Target node
     * @returns {Array} Path as array of node indices
     */
    function reconstructSeaPath(prev, targetNodeId) {
      console.log(`reconstructSeaPath: targetNodeId=${targetNodeId}, prev type=${typeof prev}, isArray=${Array.isArray(prev)}`);
      const path = [];
      
      // Handle both Map and Array formats
      const getPrev = (nodeId) => {
        if (prev instanceof Map) {
          return prev.get(nodeId);
        } else if (Array.isArray(prev) || prev instanceof Float64Array || prev instanceof Int32Array) {
          return prev[nodeId];
        }
        return -1;
      };
      
      // Use a generous guard based on graph size instead of a tiny constant
      const nodesCount = GraphCache?.sea?.nodesCount ?? window.__state.cells.length;
      let guard = 0, maxHops = nodesCount + 5;
      
      for (let v = targetNodeId; v !== -1 && v !== undefined; v = getPrev(v)) {
        path.push(v);
        if (++guard > maxHops) {
          console.warn('reconstructSeaPath guard tripped; likely a bad predecessor chain');
          break;
        }
      }
      const result = path.reverse();
      console.log(`reconstructSeaPath: result path length=${result.length}, path=${result.slice(0, 5)}...`);
      return result;
    }
    
    /**
     * Optimized Dijkstra for sea navigation with edge reuse penalty
     * @param {number} startIndex - Starting cell index
     * @param {Object} graph - Sea graph
     * @param {Set} usedEdges - Set of already-used edges for penalty
     * @returns {Object} {dist: Map, prev: Map} distances and predecessors
     */
    function dijkstraSea(startIndex, graph, usedEdges = new Set()) {
      const cells = window.__state.cells;
      const isWater = window.__state.isWater || [];
      
      if (DEBUG) console.log(`dijkstraSea: starting from ${startIndex}, graph has ${graph.edges.length} edges`);
      
      if (!isWater[startIndex]) {
        console.log(`dijkstraSea: start is not water (start: ${isWater[startIndex]})`);
        return {dist: new Map(), prev: new Map()};
      }
      
      // Create edge lookup map for fast access
      const edgeMap = new Map();
      for (const edge of graph.edges) {
        const key = `${Math.min(edge.u, edge.v)}-${Math.max(edge.u, edge.v)}`;
        edgeMap.set(key, edge);
      }
      
      const dist = new Map();
      const prev = new Map();
      const visited = new Set();
      const queue = new MinHeap(item => item.cost);
      queue.push({ node: startIndex, cost: 0 });
      
      dist.set(startIndex, 0);
      prev.set(startIndex, -1);
      
      let iterations = 0;
      const maxIterations = (graph.edges?.length ?? 0) * 4 || Infinity; // Size-based limit
      
      while (queue.size > 0 && iterations < maxIterations) {
        iterations++;
        const { node: current, cost: currentCost } = queue.pop();
        
        if (visited.has(current)) continue;
        visited.add(current);
        
        // Find all edges from current node
        for (const edge of graph.edges) {
          let nextIndex = null;
          if (edge.u === current) {
            nextIndex = edge.v;
          } else if (edge.v === current) {
            nextIndex = edge.u;
          }
          
          if (nextIndex === null || visited.has(nextIndex)) continue;
          
          // Calculate edge cost with reuse penalty
          const edgeKey = `${Math.min(current, nextIndex)}-${Math.max(current, nextIndex)}`;
          let edgeCost = edge.w;
          
          // Apply reuse penalty if edge was already used
          if (usedEdges.has(edgeKey)) {
            edgeCost *= 0.15; // Azgaar's existing lane discount
          } else {
            edgeCost *= 1.5; // New lane penalty
          }
          
          const newCost = currentCost + edgeCost;
          
          if (!dist.has(nextIndex) || newCost < dist.get(nextIndex)) {
            dist.set(nextIndex, newCost);
            prev.set(nextIndex, current);
            queue.push({ node: nextIndex, cost: newCost });
          }
        }
      }
      
      if (DEBUG) console.log(`dijkstraSea: completed, found ${dist.size} reachable nodes from ${startIndex}`);
      return {dist, prev};
    }
    
    /**
     * Find path from start to end using precomputed distances from dijkstraSea
     * @param {number} startIndex - Starting cell index
     * @param {number} endIndex - Ending cell index
     * @param {Object} graph - Sea graph
     * @param {Map} distances - Precomputed distances from dijkstraSea
     * @returns {Array} Path as array of cell indices
     */
    function findPathFromDistances(startIndex, endIndex, graph, distances) {
      const cells = window.__state.cells;
      const isWater = window.__state.isWater || [];
      
      // Skip if start or end is not water
      if (!isWater[startIndex] || !isWater[endIndex]) {
        return null;
      }
      
      // Check if start and end are the same
      if (startIndex === endIndex) {
        return [startIndex];
      }
      
      // Check if end is reachable
      if (distances[endIndex] === undefined) {
        return null;
      }
      
      // Reconstruct path by following decreasing distances
      const path = [endIndex];
      let current = endIndex;
      
      while (current !== startIndex) {
        let bestNeighbor = null;
        let bestDistance = Infinity;
        
        // Find neighbor with lowest distance
        for (const edge of graph.edges) {
          let neighbor = null;
          if (edge.a === current) {
            neighbor = edge.b;
          } else if (edge.b === current) {
            neighbor = edge.a;
          }
          
          if (neighbor !== null && distances[neighbor] !== undefined && distances[neighbor] < distances[current]) {
            if (distances[neighbor] < bestDistance) {
              bestDistance = distances[neighbor];
              bestNeighbor = neighbor;
            }
          }
        }
        
        if (bestNeighbor === null) {
          // No path found
          return null;
        }
        
        path.unshift(bestNeighbor);
        current = bestNeighbor;
      }
      
      return path;
    }
    
    /**
     * Build a compressed port graph for efficient gap detection
     * @param {Array} portsWithSeaIndex - Array of ports with their sea indices
     * @param {Object} seaGraph - Sea navigation graph
     * @returns {Object} Port graph with nodes and edges
     */
    function buildPortGraph(portsWithSeaIndex, seaGraph) {
      const nodes = portsWithSeaIndex.map(p => ({
        id: p.id,
        x: p.x,
        y: p.y,
        nodeId: p.nodeId
      }));
      
      const edges = [];
      
      // Create edges between ports using cached SSSP distances
      for (let i = 0; i < nodes.length; i++) {
        for (let j = i + 1; j < nodes.length; j++) {
          const source = nodes[i];
          const target = nodes[j];
          
          // Get cached SSSP from source using SeaRouter
          const {dist} = SeaRouter.ensureFor(source.nodeId);
          
          // Edge weight is the sea distance between ports
          const weight = dist[target.nodeId] || Infinity;
          
          if (weight < Infinity) {
            edges.push({
              a: i,
              b: j,
              weight: weight,
              sourceId: source.id,
              targetId: target.id
            });
          }
        }
      }
      
      return { nodes, edges };
    }
    
    /**
     * Optimized gap patching using port graph
     * @param {Object} portGraph - Port graph
     * @param {Array} islandGroups - Island groups
     * @param {Map} islandDistances - Island distance data
     * @param {number} largestIslandId - Largest island ID
     * @returns {Array} Gap patches
     */
    function patchGapsOptimized(portGraph, islandGroups, islandDistances, largestIslandId) {
      const gapPatches = [];
      const maxPatchesPerIsland = 6; // Cap gap patches per island
      const detourRatio = 5.0; // Stricter detour ratio
      
      islandGroups.forEach((islandPorts, islandId) => {
        if (islandPorts.length < 2) return;
        
        const islandData = islandDistances.get(islandId);
        if (!islandData) return;
        
        // Find ports for this island in the port graph
        const islandPortIndices = [];
        islandPorts.forEach(port => {
          const portIndex = portGraph.nodes.findIndex(n => n.id === port.id);
          if (portIndex >= 0) {
            islandPortIndices.push(portIndex);
          }
        });
        
        if (islandPortIndices.length < 2) return;
        
        // Build MST for this island's ports
        const islandEdges = portGraph.edges.filter(edge => 
          islandPortIndices.includes(edge.a) && islandPortIndices.includes(edge.b)
        );
        
        // Sort by weight for Kruskal's algorithm
        islandEdges.sort((a, b) => a.weight - b.weight);
        
        // Simple MST using union-find
        const parent = new Array(portGraph.nodes.length).fill(0).map((_, i) => i);
        
        function find(x) {
          if (parent[x] !== x) {
            parent[x] = find(parent[x]);
          }
          return parent[x];
        }
        
        function union(x, y) {
          parent[find(x)] = find(y);
        }
        
        const mstEdges = new Set();
        for (const edge of islandEdges) {
          if (find(edge.a) !== find(edge.b)) {
            union(edge.a, edge.b);
            mstEdges.add(`${edge.a}-${edge.b}`);
            mstEdges.add(`${edge.b}-${edge.a}`);
          }
        }
        
        // Check for gaps: compare graph path vs direct edge
        let patchesAdded = 0;
        for (let i = 0; i < islandPortIndices.length && patchesAdded < maxPatchesPerIsland; i++) {
          for (let j = i + 1; j < islandPortIndices.length && patchesAdded < maxPatchesPerIsland; j++) {
            const portA = islandPortIndices[i];
            const portB = islandPortIndices[j];
            
            // Skip if already connected in MST
            if (mstEdges.has(`${portA}-${portB}`)) continue;
            
            // Find shortest path via existing edges
            const graphPathCost = findShortestPathInPortGraph(portA, portB, portGraph, mstEdges);
            const directCost = portGraph.edges.find(e => 
              (e.a === portA && e.b === portB) || (e.a === portB && e.b === portA)
            )?.weight || Infinity;
            
            if (graphPathCost >= detourRatio * directCost && directCost < Infinity) {
              // Add gap patch
              const portAId = portGraph.nodes[portA].id;
              const portBId = portGraph.nodes[portB].id;
              
              gapPatches.push({
                islandId: islandId,
                fromPort: { id: portAId, x: portGraph.nodes[portA].x, y: portGraph.nodes[portA].y },
                fromNodeId: portGraph.nodes[portA].nodeId,
                toPort: { id: portBId, x: portGraph.nodes[portB].x, y: portGraph.nodes[portB].y },
                toNodeId: portGraph.nodes[portB].nodeId,
                cost: directCost
              });
              
              patchesAdded++;
              
              // Throttle gap patch logging to avoid console spam
              if (gapPatches.length <= 10) {
                console.log(`Added gap patch on island ${islandId}: ${portAId} to ${portBId} (detour ${graphPathCost.toFixed(1)} vs direct ${directCost.toFixed(1)})`);
              } else if (gapPatches.length === 11) {
                console.log(`... and ${gapPatches.length - 10} more gap patches (logging throttled)`);
              }
            }
          }
        }
      });
      
      return gapPatches;
    }
    
    /**
     * Find shortest path in port graph using existing edges
     * @param {number} start - Start port index
     * @param {number} end - End port index
     * @param {Object} portGraph - Port graph
     * @param {Set} existingEdges - Set of existing edges
     * @returns {number} Path cost or Infinity if no path
     */
    function findShortestPathInPortGraph(start, end, portGraph, existingEdges) {
      const visited = new Set();
      const queue = [{ node: start, cost: 0 }];
      
      while (queue.length > 0) {
        queue.sort((a, b) => a.cost - b.cost);
        const { node: current, cost } = queue.shift();
        
        if (current === end) {
          return cost;
        }
        
        if (visited.has(current)) continue;
        visited.add(current);
        
        // Find neighbors via existing edges
        for (const edge of portGraph.edges) {
          let neighbor = null;
          if (edge.a === current && existingEdges.has(`${edge.a}-${edge.b}`)) {
            neighbor = edge.b;
          } else if (edge.b === current && existingEdges.has(`${edge.b}-${edge.a}`)) {
            neighbor = edge.a;
          }
          
          if (neighbor !== null && !visited.has(neighbor)) {
            queue.push({ node: neighbor, cost: cost + edge.weight });
          }
        }
      }
      
      return Infinity; // No path found
    }
    
    /**
     * Simple BFS pathfinding for sea navigation using the sea graph
     * @param {number} startIndex - Starting cell index
     * @param {number} endIndex - Ending cell index
     * @param {Object} graph - Sea graph
     * @returns {Array} Path as array of cell indices
     */
    function shortestPathSea(startIndex, endIndex, graph) {
      const cells = window.__state.cells;
      const isWater = window.__state.isWater || [];
      
      // Skip if start or end is not water
      if (!isWater[startIndex] || !isWater[endIndex]) {
        console.log(`shortestPathSea: start or end is not water (start: ${isWater[startIndex]}, end: ${isWater[endIndex]})`);
        return null;
      }
      
      // Check if start and end are the same
      if (startIndex === endIndex) {
        return [startIndex];
      }
      
      // Weighted BFS using sea graph edges with offshore bias
      const visited = new Set();
      const queue = [[startIndex, [startIndex], 0]]; // [current, path, cost]
      visited.add(startIndex);
      
      while (queue.length > 0) {
        // Sort queue by cost to prefer lower-cost (more offshore) paths
        queue.sort((a, b) => a[2] - b[2]);
        const [current, path, cost] = queue.shift();
        
        if (current === endIndex) {
          console.log(`shortestPathSea: found path with ${path.length} cells between ${startIndex} and ${endIndex}`);
          return path;
        }
        
        // Find all edges from current node in sea graph
        for (const edge of graph.edges) {
          let nextIndex = null;
          if (edge.a === current) {
            nextIndex = edge.b;
          } else if (edge.b === current) {
            nextIndex = edge.a;
          }
          
          if (nextIndex !== null && !visited.has(nextIndex)) {
            // Calculate cost based on distance and land proximity
            const nextCell = cells[nextIndex];
            let landProximity = 0;
            
            // Count land neighbors to bias away from coast
            for (const nb of nextCell.neighbors) {
              if (!isWater[nb]) {
                landProximity += 1;
              }
            }
            
            // Higher cost for cells near land (encourages offshore routes)
            const newCost = cost + edge.w + (landProximity * 10);
            
            visited.add(nextIndex);
            queue.push([nextIndex, [...path, nextIndex], newCost]);
          }
        }
      }
      
      console.log(`shortestPathSea: no path found between ${startIndex} and ${endIndex}`);
      return null; // No path found
    }
    
    /**
     * Heuristic function for A* (Euclidean distance)
     * @param {number} a - Cell index
     * @param {number} b - Cell index
     * @param {Array} cells - All cells array
     * @returns {number} Heuristic value
     */
    function heuristic(a, b, cells) {
      return Math.hypot(cells[a].cx - cells[b].cx, cells[a].cy - cells[b].cy);
    }
    
    /**
     * Convert path indices to polyline points
     * @param {Array} pathIndices - Array of cell indices
     * @returns {Array} Array of [x, y] points
     */
    function polylineFromPath(pathIndices) {
      const cells = window.__state.cells;
      return pathIndices.map(index => [cells[index].cx, cells[index].cy]);
    }
    
    /**
     * Smooth a polyline using Chaikin smoothing
     * @param {Array} points - Array of [x, y] points
     * @param {number} iterations - Number of smoothing iterations
     * @returns {Array} Smoothed polyline
     */
    function smoothLine(points, iterations = 1) {
      if (points.length < 3) return points;
      
      let smoothed = points;
      for (let iter = 0; iter < iterations; iter++) {
        const newPoints = [];
        for (let i = 0; i < smoothed.length - 1; i++) {
          const [x1, y1] = smoothed[i];
          const [x2, y2] = smoothed[i + 1];
          
          newPoints.push([x1, y1]);
          newPoints.push([(x1 + x2) / 2, (y1 + y2) / 2]);
        }
        newPoints.push(smoothed[smoothed.length - 1]);
        smoothed = newPoints;
      }
      
      return smoothed;
    }
    
    /**
     * Mark ports in burgs array, ensuring every island has at least one port
     * @param {Array} burgs - Burgs array
     * @param {Array} cells - All cells array
     * @param {Array} isWater - Water mask array
     */
    function markPorts(burgs, cells, isWater) {
      const sea = +document.getElementById('seaLevelInput').value;
      
      // First pass: mark obvious ports
      burgs.forEach(burg => {
        // Check if burg is near water (within 32 pixels)
        let minWaterDist = Infinity;
        for (let i = 0; i < cells.length; i++) {
          if (isWater[i]) {
            const dist = Math.hypot(burg.x - cells[i].cx, burg.y - cells[i].cy);
            minWaterDist = Math.min(minWaterDist, dist);
          }
        }
        
        const isPort = minWaterDist < 32;
        burg.isPort = isPort;
        burg.port = isPort; // keep renderers and routers in sync
      });
      
      // Second pass: ensure every island has at least one port
      const landGraph = buildLandGraph(cells, isWater);
      const components = findConnectedComponents(burgs, landGraph);
      
      components.forEach((islandBurgs, islandIndex) => {
        const hasPort = islandBurgs.some(burg => burg.isPort);
        
        if (!hasPort && islandBurgs.length > 0) {
          // Find the best port candidate on this island
          let bestPortCandidate = null;
          let bestScore = -Infinity;
          
          islandBurgs.forEach(burg => {
            // Score based on burg type and proximity to water
            let score = 0;
            
            // Prefer larger settlements
            if (burg.type === 'capital') score += 100;
            else if (burg.type === 'city') score += 50;
            else if (burg.type === 'town') score += 25;
            else if (burg.type === 'hamlet') score += 10;
            
            // Find minimum distance to water
            let minWaterDist = Infinity;
            for (let i = 0; i < cells.length; i++) {
              if (isWater[i]) {
                const dist = Math.hypot(burg.x - cells[i].cx, burg.y - cells[i].cy);
                minWaterDist = Math.min(minWaterDist, dist);
              }
            }
            
            // Prefer closer to water (inverse distance)
            if (minWaterDist < Infinity) {
              score += Math.max(0, 100 - minWaterDist);
            }
            
            if (score > bestScore) {
              bestScore = score;
              bestPortCandidate = burg;
            }
          });
          
          if (bestPortCandidate) {
            bestPortCandidate.port = true;
            bestPortCandidate.isPort = true;
            bestPortCandidate.isSignificantPort = true;
            if (DEBUG) console.log(`Promoted ${bestPortCandidate.type} ${bestPortCandidate.id} to port on island ${islandIndex}`);
          } else {
            if (DEBUG) console.log(`No suitable port candidate found on island ${islandIndex}`);
          }
        }
      });
    }
    
    /**
     * Find the nearest water cell to a given cell
     * @param {number} fromIndex - Starting cell index
     * @param {Array} isWater - Water mask array
     * @param {Array} cells - All cells array
     * @returns {number} Index of nearest water cell, or -1 if none found
     */
    function nearestWaterCellIndex(fromIndex, isWater, cells) {
      if (isWater[fromIndex]) return fromIndex;
      const visited = new Uint8Array(cells.length);
      const q = [fromIndex];
      visited[fromIndex] = 1;
      while (q.length) {
        const i = q.shift();
        for (const nb of cells[i].neighbors) {
          if (visited[nb]) continue;
          if (isWater[nb]) return nb;       // first water cell found
          visited[nb] = 1;
          q.push(nb);
        }
      }
      return -1; // none found (shouldn't happen on coastal ports)
    }
    

    
    /**
     * Helper function to get or create a group
     * @param {Object} parent - Parent D3 selection
     * @param {string} className - Class name for the group
     * @returns {Object} D3 selection for the group
     */
    function getOrCreateGroup(parent, className) {
      let group = parent.select(`.${className}`);
      if (group.size() === 0) {
        group = parent.append('g').attr('class', className);
      }
      return group;
    }
    
    /**
     * Find connected components of burgs using flood fill on land cells
     * @param {Array} burgs - Burgs array
     * @param {Object} landGraph - Land navigation graph
     * @returns {Array} Array of arrays, each containing connected burgs
     */
    function findConnectedComponents(burgs, landGraph) {
      if (burgs.length === 0) return [];
      
      const cells = window.__state.cells;
      const isWater = window.__state.isWater || [];
      
      // Create a map of burg cell indices to burg objects
      const burgByCell = new Map();
      burgs.forEach(burg => burgByCell.set(burg.cell, burg));
      
      const components = [];
      const visitedCells = new Set();
      const visitedBurgs = new Set();
      
      for (const burg of burgs) {
        if (visitedBurgs.has(burg.id)) continue;
        
        // Start a new component with this burg
        const component = [];
        const cellQueue = [burg.cell];
        visitedCells.add(burg.cell);
        visitedBurgs.add(burg.id);
        component.push(burg);
        
        // Flood fill from this burg's cell to find all connected land cells
        let floodSize = 0;
        while (cellQueue.length > 0) {
          const currentCellIndex = cellQueue.shift();
          const currentCell = cells[currentCellIndex];
          floodSize++;
          
          // Check all neighbors of this cell
          for (const neighborIndex of currentCell.neighbors) {
            if (visitedCells.has(neighborIndex)) continue;
            if (isWater[neighborIndex]) continue; // Skip water cells
            
            visitedCells.add(neighborIndex);
            cellQueue.push(neighborIndex);
            
            // If there's a burg on this cell, add it to the component
            const neighborBurg = burgByCell.get(neighborIndex);
            if (neighborBurg && !visitedBurgs.has(neighborBurg.id)) {
              visitedBurgs.add(neighborBurg.id);
              component.push(neighborBurg);
              if (DEBUG) console.log(`Flood found burg ${neighborBurg.id} at cell ${neighborIndex}`);
            }
          }
        }
        if (DEBUG) console.log(`Flood from burg ${burg.id} (cell ${burg.cell}) explored ${floodSize} cells, found ${component.length} burgs`);
        
        components.push(component);
      }
      
      if (DEBUG) console.log(`findConnectedComponents: found ${components.length} connected components:`, 
        components.map(c => c.length));
      
      // Debug: show which burgs are in which component
      components.forEach((component, i) => {
        console.log(`Component ${i}:`, component.map(b => `burg ${b.id} (cell ${b.cell})`));
      });
      
      // Debug: show burg positions to verify they're on different landmasses
      console.log('Burg positions:', burgs.map(b => ({ id: b.id, cell: b.cell, x: cells[b.cell].cx, y: cells[b.cell].cy })));
      
      return components;
    }
    
    /**
     * Build primary road network (MST between major burgs)
     * @param {Array} burgs - Burgs array
     * @param {Object} landGraph - Land navigation graph
     */
    function buildBackboneRoads(burgs, landGraph) {
      if (burgs.length < 2) return [];
      
      const roadDensity = +document.getElementById('roadDensityInput').value || 0.6;
      const hubCount = Math.max(2, Math.round(burgs.length * (0.35 + 0.5 * roadDensity)));
      
      // Create sets for tracking used edges and burg cells
      const usedEdges = new Set();
      const burgCells = new Set(burgs.map(b => b.cell));
      
      // Collect all route segments for road usage tracking
      const allRouteSegments = [];
      
      // Group burgs by connected components
      const components = findConnectedComponents(burgs, landGraph);
      console.log(`Found ${components.length} connected land components`);
      
      // Build roads within each component
      components.forEach((componentBurgs, componentIndex) => {
        if (DEBUG) console.log(`Processing component ${componentIndex} with ${componentBurgs.length} burgs`);
        if (componentBurgs.length < 2) {
                      if (DEBUG) console.log(`Component ${componentIndex} has < 2 burgs, skipping`);
          return;
        }
        
        // Select hubs within this component
        const componentHubs = componentBurgs
          .sort((a, b) => b.population - a.population)
          .slice(0, Math.max(2, Math.round(componentBurgs.length * 0.6)));
        
                  if (DEBUG) console.log(`Component ${componentIndex}: selected ${componentHubs.length} hubs from ${componentBurgs.length} burgs`);
        
        // Build complete graph of hub-to-hub path costs within component
        const hubEdges = [];
        
        console.log(`Component ${componentIndex}: building ${componentHubs.length * (componentHubs.length - 1) / 2} potential hub connections`);
        
        for (let i = 0; i < componentHubs.length; i++) {
          for (let j = i + 1; j < componentHubs.length; j++) {
            console.log(`Trying path from hub ${i} (cell ${componentHubs[i].cell}) to hub ${j} (cell ${componentHubs[j].cell})`);
            const path = shortestPath(componentHubs[i].cell, componentHubs[j].cell, landGraph, usedEdges, burgCells);
            if (path) {
              console.log(`Found path: ${path.length} cells`);
              
              // Calculate weighted cost using edge weights from land graph
              const cost = calculatePathCost(path, landGraph);
              hubEdges.push({ a: i, b: j, cost: cost, path: path });
            } else {
              console.log(`Component ${componentIndex}: no path between hubs ${i} and ${j} (cells ${componentHubs[i].cell} and ${componentHubs[j].cell})`);
            }
          }
        }
        
        if (DEBUG) console.log(`Component ${componentIndex}: found ${hubEdges.length} valid hub connections`);
        
        // Sort edges by cost for Kruskal's algorithm
        hubEdges.sort((a, b) => a.cost - b.cost);
        
        // Kruskal's algorithm for MST within component
        const parent = new Array(componentHubs.length).fill(0).map((_, i) => i);
        
        function find(x) {
          if (parent[x] !== x) {
            parent[x] = find(parent[x]);
          }
          return parent[x];
        }
        
        function union(x, y) {
          parent[find(x)] = find(y);
        }
        
        const mstEdges = [];
        for (const edge of hubEdges) {
          if (find(edge.a) !== find(edge.b)) {
            union(edge.a, edge.b);
            mstEdges.push(edge);
          }
        }
        
        // Render MST edges as roads and mark used edges
        const roadsG = d3.select('#routes .roads');
        const line = d3.line().x(d => d[0]).y(d => d[1]).curve(d3.curveBasis);
        
        // Collect all road paths first and mark used edges
        const roadPaths = mstEdges.map(edge => {
          // Mark edges as used for future pathfinding
          markPathEdgesAsUsed(edge.path, usedEdges);
          
          // Add to route segments for road usage tracking
          allRouteSegments.push(edge.path);
          
          const points = polylineFromPath(edge.path);
          const smoothed = smoothLine(points, 1);
          return {
            d: line(smoothed),
            fill: 'none',
            stroke: '#6b4e16',
            'stroke-width': '1.5px',
            'stroke-linecap': 'round',
            'stroke-linejoin': 'round',
            'vector-effect': 'non-scaling-stroke'
          };
        });
        
        // Batch add all paths at once using optimized drawing
        const roadSegments = roadPaths.map(p => {
          // Extract points from the SVG path data
          const pathData = p.d;
          // For now, use the original D3 approach since the data structure is complex
          return p;
        });
        
        // Use original D3 approach for now since path data is already in SVG format
        roadsG.selectAll('path')
          .data(roadSegments)
          .enter()
          .append('path')
          .each(function(d) {
            Object.entries(d).forEach(([attr, value]) => {
              d3.select(this).attr(attr, value);
            });
          });
        
        if (DEBUG) console.log(`Component ${componentIndex}: ${mstEdges.length} roads between ${componentHubs.length} hubs`);
      });
      
      return allRouteSegments;
    }
    
    /**
     * Build local trail network
     * @param {Array} burgs - Burgs array
     * @param {Object} landGraph - Land navigation graph
     */
    function buildLocalTrails(burgs, landGraph) {
      if (burgs.length < 2) return [];
      
      const trailDensity = +document.getElementById('trailDensityInput').value || 0.5;
      const maxDistance = 160 + (trailDensity * 80); // 160-240px range
      const maxConnections = Math.max(1, Math.round(1 + trailDensity * 2)); // 1-3 connections
      
      // Create sets for tracking used edges and burg cells
      const usedEdges = new Set();
      const burgCells = new Set(burgs.map(b => b.cell));
      
      const line = d3.line().x(d => d[0]).y(d => d[1]).curve(d3.curveBasis);
      const existingTrails = [];
      const trailPaths = [];
      const allTrailSegments = [];
      
      // Group burgs by connected components
      const components = findConnectedComponents(burgs, landGraph);
      
      // Build trails within each component
      components.forEach((componentBurgs, componentIndex) => {
        if (DEBUG) console.log(`Building trails for component ${componentIndex} with ${componentBurgs.length} burgs`);
        if (componentBurgs.length < 2) {
                      if (DEBUG) console.log(`Component ${componentIndex} has < 2 burgs, skipping trails`);
          return;
        }
        
        componentBurgs.forEach(burg => {
          // Find nearby burgs within max distance (only within same component)
          const nearby = componentBurgs
            .filter(other => other !== burg)
            .map(other => ({
              burg: other,
              dist: Math.hypot(burg.x - other.x, burg.y - other.y)
            }))
            .filter(item => item.dist <= maxDistance)
            .sort((a, b) => a.dist - b.dist)
            .slice(0, maxConnections);
          
          console.log(`Burg ${burg.id} (cell ${burg.cell}): found ${nearby.length} nearby burgs within ${maxDistance}px`);
        
          nearby.forEach(item => {
            const path = shortestPath(burg.cell, item.burg.cell, landGraph, usedEdges, burgCells);
            if (path) {
              const points = polylineFromPath(path);
              const smoothed = smoothLine(points, 1);
              
              // Check for overlap with existing trails (simple bounding box check)
              const trailKey = [Math.min(burg.cell, item.burg.cell), Math.max(burg.cell, item.burg.cell)].join('-');
              if (!existingTrails.includes(trailKey)) {
                existingTrails.push(trailKey);
                
                // Add to trail segments for road usage tracking
                allTrailSegments.push(path);
                
                // Collect trail path data instead of adding immediately
                trailPaths.push({
                  d: line(smoothed),
                  fill: 'none',
                  stroke: '#9b7b3a',
                  'stroke-width': '1px',
                  'stroke-dasharray': '3 3',
                  'stroke-linecap': 'round',
                  'stroke-linejoin': 'round',
                  'vector-effect': 'non-scaling-stroke'
                });
              }
            }
          });
        });
        
        if (DEBUG) console.log(`Component ${componentIndex}: ${existingTrails.length} trails built`);
      });
      
      // Batch add all trail paths at once using optimized drawing
      const trailsG = d3.select('#routes .trails');
      
      // Use original D3 approach for now since path data is already in SVG format
      trailsG.selectAll('path')
        .data(trailPaths)
        .enter()
        .append('path')
        .each(function(d) {
          Object.entries(d).forEach(([attr, value]) => {
            d3.select(this).attr(attr, value);
          });
        });
      
      if (DEBUG) console.log(`Total trails built: ${existingTrails.length}`);
      
      return allTrailSegments;
    }
    
    // ---- Water Path Validation ---------------------------------------------
    
    // Helper: returns true if the segment stays over water
    function waterOnlySegment(ax, ay, bx, by, isWater, cells, steps = Math.ceil(Math.hypot(ax-bx, ay-by) / 6)) {
      for (let s = 1; s < steps; s++) {
        const t = s / steps;
        const x = ax + (bx - ax) * t;
        const y = ay + (by - ay) * t;
        
        // Find the nearest cell using brute force (since delaunay isn't available)
        let nearestIdx = -1;
        let nearestDist = Infinity;
        for (let i = 0; i < cells.length; i++) {
          const dist = Math.hypot(cells[i].cx - x, cells[i].cy - y);
          if (dist < nearestDist) {
            nearestDist = dist;
            nearestIdx = i;
          }
        }
        
        if (nearestIdx < 0 || !isWater[nearestIdx]) return false;
      }
      return true;
    }

    // ---- Hub & Spoke Sea Network ---------------------------------------------

    function getPortCandidates() {
      // Prefer explicit ports if you have them; otherwise use coastal burgs
      const ports = (window.__state.ports && window.__state.ports.length)
        ? window.__state.ports.map(p => ({ x: p.x, y: p.y, name: p.name }))
        : (window.__state.burgs || [])
            .filter(b => b.port || b.isPort || b.type === 'port' || b.isCoastal)
            .map(b => ({ x: b.x, y: b.y, name: b.name }));
      return ports;
    }

    function chooseHubsFarthestFirst(portNodes, k) {
      // k ≈ sqrt(P) is a nice default
      const hubs = [];
      if (!portNodes.length) return hubs;
      hubs.push(portNodes[0]);

      while (hubs.length < k && hubs.length < portNodes.length) {
        let best = null, bestScore = -1;
        for (const p of portNodes) {
          if (hubs.includes(p)) continue;
          const score = hubs.reduce((m, h) => Math.min(m, h.dist[p.nodeId]), Infinity);
          if (score > bestScore) { bestScore = score; best = p; }
        }
        hubs.push(best);
      }
      return hubs;
    }

    function buildSeaTransitNetwork({ kHubs } = {}) {
      const G = GraphCache.sea;
      if (!G) return;

      // 1) Collect/snap ports to sea graph
      const rawPorts = getPortCandidates();
      const ports = rawPorts.map(p => {
        const nodeId = snapPortToSeaNode(p.x, p.y, 24);
        return nodeId >= 0 ? { ...p, nodeId } : null;
      }).filter(Boolean);
      if (ports.length < 2) return;

      // Optional: split by connected component so hubs never cross land-locked seas
      const comp = labelSeaComponents();
      const groups = new Map();
      for (const p of ports) {
        const c = comp ? comp[p.nodeId] : 0;
        if (!groups.has(c)) groups.set(c, []);
        groups.get(c).push(p);
      }

      // Edge usage accumulator (undirected)
      const edgeUsage = new Map();
      const addPath = (prev, a, b, weight = 1) => {
        for (let v = b; v !== -1 && v !== a; v = prev[v]) {
          const u = prev[v]; if (u < 0) break;
          const key = u < v ? `${u}|${v}` : `${v}|${u}`;
          edgeUsage.set(key, (edgeUsage.get(key) || 0) + weight);
        }
      };

      // Process each connected sea component separately
      for (const [_cid, P] of groups) {
        if (P.length === 0) continue;

        // Precompute one Dijkstra per **candidate hub** (cached by SeaRouter)
        const packs = new Map();
        for (const p of P) packs.set(p.nodeId, SeaRouter.ensureFor(p.nodeId));

        // 2) Choose hubs (default k ≈ sqrt(P))
        const K = kHubs || Math.max(1, Math.round(Math.sqrt(P.length)));
        // Annotate ports with distance maps for farthest-first
        for (const p of P) p.dist = packs.get(p.nodeId).dist;
        const hubs = chooseHubsFarthestFirst(P, K);

        // 3) Assign every port to nearest hub by **sea distance**
        const hubPacks = new Map(hubs.map(h => [h.nodeId, packs.get(h.nodeId)]));
        for (const p of P) {
          let best = hubs[0], bestD = Infinity;
          for (const h of hubs) {
            const d = hubPacks.get(h.nodeId).dist[p.nodeId];
            if (d < bestD) { bestD = d; best = h; }
          }
          p.hub = best;
          addPath(hubPacks.get(best.nodeId).prev, best.nodeId, p.nodeId, 1);
        }

        // 4) Connect hubs with an MST over sea distances (trunks)
        const hubList = hubs.slice();
        const edges = [];
        for (let i = 0; i < hubList.length; i++)
          for (let j = i + 1; j < hubList.length; j++)
            edges.push({ i, j, w: packs.get(hubList[i].nodeId).dist[hubList[j].nodeId] });

        edges.sort((a, b) => a.w - b.w);
        const parent = hubList.map((_, i) => i);
        const find = i => parent[i] === i ? i : (parent[i] = find(parent[i]));
        const unite = (a, b) => { a = find(a); b = find(b); if (a === b) return false; parent[a] = b; return true; };

        for (const e of edges) {
          if (unite(e.i, e.j)) {
            const A = hubList[e.i].nodeId, B = hubList[e.j].nodeId;
            addPath(packs.get(A).prev, A, B, 3); // trunk edges carry more weight
          }
        }
      }

      // 5) Render all used edges once (shared segments)
      renderSeaNetwork(edgeUsage, G.xy);
    }

    // Turn the set of used edges into non-overlapping polylines (node-ID based)
    function polylinesFromEdgeUsage(edgeUsage, xy) {
      const adj = new Map();                // nodeId -> Set<neighborId>
      const degree = new Map();
      const edgeKey = (u,v)=> u<v ? `${u}|${v}` : `${v}|${u}`;
      const addAdj = (u,v)=>{
        if (!adj.has(u)) adj.set(u,new Set());
        if (!adj.has(v)) adj.set(v,new Set());
        adj.get(u).add(v); adj.get(v).add(u);
        degree.set(u,(degree.get(u)||0)+1);
        degree.set(v,(degree.get(v)||0)+1);
      };

      for (const key of edgeUsage.keys()) {
        const [a,b] = key.split('|').map(Number);
        addAdj(a,b);
      }

      const visited = new Set();
      const polylines = [];

      function walkChain(start, next){
        const line = [];
        let u = start, v = next;
        line.push({x: xy[u][0], y: xy[u][1]});
        while (true) {
          visited.add(edgeKey(u,v));
          line.push({x: xy[v][0], y: xy[v][1]});
          const degV = (adj.get(v)||new Set()).size;
          if (degV !== 2) break;
          // continue through the degree-2 corridor
          let w = undefined;
          for (const n of adj.get(v)) {
            if (n !== u && !visited.has(edgeKey(v,n))) { w = n; break; }
          }
          if (w == null) break;
          u = v; v = w;
        }
        return line;
      }

      // Start chains from junctions (degree != 2)
      for (const [node, deg] of degree) {
        if (deg !== 2) {
          for (const n of adj.get(node) || []) {
            const ek = edgeKey(node,n);
            if (!visited.has(ek)) polylines.push(walkChain(node,n));
          }
        }
      }

      // Any remaining cycles (all nodes degree==2)
      for (const [u, neigh] of adj) {
        for (const v of neigh) {
          const ek = edgeKey(u,v);
          if (!visited.has(ek)) polylines.push(walkChain(u,v));
        }
      }
      return polylines;
    }

    function renderSeaNetwork(edgeUsage, xy) {
      const g = d3.select('#routes .searoutes'); // this group already has the ocean mask
      const polys = polylinesFromEdgeUsage(edgeUsage, xy);
      const paths = g.selectAll('path').data(polys);
      paths.join('path')
        .attr('d', poly => 'M' + poly.map(p => `${p.x},${p.y}`).join('L'))
        .attr('fill', 'none')
        .attr('stroke', '#ffffff')
        .attr('stroke-dasharray', '6 4')             // keep your dashed look
        .attr('stroke-linecap', 'round')
        .attr('stroke-linejoin', 'round')
        .attr('opacity', '0.8')
        .attr('vector-effect', 'non-scaling-stroke');

      // Use consistent thin stroke width for all routes
      g.selectAll('path').attr('stroke-width', '1.2px');
    }

    /**
     * Build sea navigation graph
     * @param {Array} cells - All cells array
     * @param {Array} isWater - Water mask array
     * @returns {Object} Sea navigation graph
     */
    function buildSeaGraph(cells, isWater) {
      // Check cache first
      if (GraphCache.sea) {
        if (DEBUG) console.log('buildSeaGraph: using cached graph');
        return GraphCache.sea;
      }
      
      const nodes = [];
      const edges = [];
      
      // Create nodes for all water cells
      for (let i = 0; i < cells.length; i++) {
        if (isWater[i]) {
          nodes.push({ i: i, x: cells[i].cx, y: cells[i].cy });
        }
      }
      
      if (DEBUG) console.log(`buildSeaGraph: created ${nodes.length} water nodes`);
      
      // Create edges between neighboring water cells
      for (let i = 0; i < cells.length; i++) {
        if (!isWater[i]) continue; // Skip land cells
        
        const cell = cells[i];
        for (const neighborIndex of cell.neighbors) {
          if (neighborIndex > i && isWater[neighborIndex]) { // Avoid duplicate edges
            const neighbor = cells[neighborIndex];
            const dist = Math.hypot(cell.cx - neighbor.cx, cell.cy - neighbor.cy);
            
            // Add small penalty near land to bias routes offshore
            let landPenalty = 0;
            for (const nb of [cell, neighbor]) {
              for (const nbIndex of nb.neighbors) {
                if (!isWater[nbIndex]) {
                  landPenalty += 0.1;
                  break;
                }
              }
            }
            
            const w = dist * (1 + landPenalty);
            edges.push({ u: i, v: neighborIndex, dist: dist, w: w });
          }
        }
      }
      
      // Add long-distance sea connections to ensure islands can be connected
      // Create a more connected sea graph by adding edges between distant water cells
      const waterCells = [];
      for (let i = 0; i < cells.length; i++) {
        if (isWater[i]) {
          waterCells.push({ index: i, x: cells[i].cx, y: cells[i].cy });
        }
      }
      
      // Use a much more efficient approach: connect only strategic water cells
      // Create a sparse network by sampling water cells and connecting them intelligently
      const sampleRate = 0.1; // Only use 10% of water cells for the graph
      const sampledCells = [];
      
      // Sample water cells randomly but ensure good coverage
      for (let i = 0; i < waterCells.length; i++) {
        if (Math.random() < sampleRate) {
          sampledCells.push(waterCells[i]);
        }
      }
      
      // Ensure we have at least some cells for connectivity
      if (sampledCells.length < 100) {
        // Add more cells if we don't have enough
        for (let i = 0; i < waterCells.length && sampledCells.length < 200; i++) {
          if (!sampledCells.includes(waterCells[i])) {
            sampledCells.push(waterCells[i]);
          }
        }
      }
      
      if (DEBUG) console.log(`Sea graph optimization: using ${sampledCells.length} cells out of ${waterCells.length} water cells`);
      
      // Connect sampled cells with a more reasonable approach
      for (let i = 0; i < sampledCells.length; i++) {
        const cell1 = sampledCells[i];
        
        // Connect to nearby cells within reasonable distance
        for (let j = i + 1; j < sampledCells.length; j++) {
          const cell2 = sampledCells[j];
          const dist = Math.hypot(cell1.x - cell2.x, cell1.y - cell2.y);
          
          // Only connect very close neighbors to avoid overland shortcuts
          if (dist >= 20 && dist <= 50) {
            // Check if the path between cells stays over water
            if (waterOnlySegment(cell1.x, cell1.y, cell2.x, cell2.y, isWater, cells)) {
              // Add some randomness to avoid creating too many edges
              if (Math.random() < 0.5) { // 50% chance of connection
                const w = dist * 1.2;
                edges.push({ u: cell1.index, v: cell2.index, dist: dist, w: w });
              }
            }
          }
        }
        
        // Also connect to a few random distant cells for long-range connectivity
        // REMOVED: These random long-distance edges create shortcuts across land
        // if (i % 10 === 0) { // Every 10th cell
        //   for (let j = 0; j < 3; j++) { // Connect to 3 random distant cells
        //     const randomCell = sampledCells[Math.floor(Math.random() * sampledCells.length)];
        //     if (randomCell !== cell1) {
        //       const dist = Math.hypot(cell1.x - randomCell.x, cell1.y - randomCell.y);
        //       if (dist > 100) { // Only long-distance connections
        //         const w = dist * 2.0; // Higher cost for long-distance
        //         edges.push({ u: cell1.index, v: randomCell.index, dist: dist, w: w });
        //       }
        //     }
        //   }
        // }
      }
      
      if (DEBUG) console.log(`buildSeaGraph: created ${edges.length} water edges (${nodes.length} water nodes) - optimized for performance`);
      
      // Create xy coordinates array for the sea graph (indexed by cell index)
      const xy = Array(cells.length);
      for (let i = 0; i < cells.length; i++) {
        if (isWater[i]) {
          xy[i] = [cells[i].cx, cells[i].cy];
        }
      }
      
      // REMOVED: Shore penalty using computeDistanceToWater - unreliable with cell-based indexing
      // The neighbor-based land penalty already biases routes offshore
      // const distanceToWater = computeDistanceToWater(isWater, window.__state.width, window.__state.height);
      // for (const edge of edges) {
      //   const u = edge.u, v = edge.v;
      //   const midX = (cells[u].cx + cells[v].cx) / 2;
      //   const midY = (cells[u].cy + cells[v].cy) / 2;
      //   const midIdx = Math.floor(midY) * window.__state.width + Math.floor(midX);
      //   const d = distanceToWater[midIdx] || 0; // distance to land in pixels/cells
      //   const shorePenalty = 1 + 4 * Math.max(0, (2 - d)); // strong penalty when d<2px
      //   edge.w = edge.w * shorePenalty;
      // }
      
      // Cache the graph for reuse
      finalizeSeaGraph(cells.length, edges, xy);
      
      return { nodes, edges };
    }
    
    /**
     * Disjoint Set Union (DSU) for tracking connected components
     */
    class DSU {
      constructor(n) {
        this.p = [...Array(n).keys()];
        this.r = Array(n).fill(0);
      }
      
      find(x) {
        return this.p[x] === x ? x : this.p[x] = this.find(this.p[x]);
      }
      
      union(a, b) {
        a = this.find(a);
        b = this.find(b);
        if (a === b) return false;
        if (this.r[a] < this.r[b]) [a, b] = [b, a];
        this.p[b] = a;
        if (this.r[a] === this.r[b]) this.r[a]++;
        return true;
      }
    }
    
    /**
     * Connect sea network ensuring all ports are connected
     * @param {Array} ports - Array of port objects with cell indices
     * @param {Array} mstEdges - MST edges from Kruskal
     * @param {Function} oceanPath - Function to find ocean path between two cells
     * @returns {Array} Array of path segments to render
     */
    function connectSeaNetwork(ports, mstEdges, oceanPath) {
      const n = ports.length;
      const dsu = new DSU(n);
      const segments = [];
      
      // 1) Add MST edges (when path exists)
      for (const [i, j] of mstEdges) {
        const path = oceanPath(ports[i].cell, ports[j].cell);
        if (path && path.length) {
          segments.push(path);
          dsu.union(i, j);
        }
      }
      
      // 2) Force-connect any remaining components
      const root0 = dsu.find(0);
      for (let u = 0; u < n; u++) {
        if (dsu.find(u) === root0) continue;
        
        // Find nearest port in the main component by euclidean distance
        let bestV = -1, bestD = Infinity;
        for (let v = 0; v < n; v++) {
          if (dsu.find(v) === root0) {
            const dx = ports[u].x - ports[v].x;
            const dy = ports[u].y - ports[v].y;
            const d = dx * dx + dy * dy;
            if (d < bestD) {
              bestD = d;
              bestV = v;
            }
          }
        }
        
        const path = oceanPath(ports[u].cell, ports[bestV].cell);
        if (path && path.length) {
          segments.push(path);
          dsu.union(u, bestV);
        }
      }
      
      return segments;
    }
    
    /**
     * Build sea route backbone using Azgaar-style single-source approach
     * @param {Array} portBurgs - Array of port burgs
     * @param {Object} seaGraph - Sea navigation graph
     * @param {Object} landGraph - Land navigation graph
     */
    function buildSeaBackbone(portBurgs, seaGraph, landGraph) {
      if (portBurgs.length < 2) return;
      const cells = window.__state.cells;
      const isWater = window.__state.isWater;

      // 1) Group ports by island (land component)
      const islandGroups = findConnectedComponents(portBurgs, landGraph);
      console.log(`Found ${islandGroups.length} island groups for sea routing`);
      
      // 2) Map ports to nearest sea nodes and ensure all islands have sea access
      const portsWithSeaIndex = portBurgs
        .map(p => ({
          ...p,
          nodeId: snapPortToSeaNode(p.x, p.y, 16) // Snap to nearest sea node within 16px
        }))
        .filter(p => p.nodeId >= 0);
      
      // Label sea components to avoid routing between disconnected water bodies
      const seaComponents = labelSeaComponents();
      if (seaComponents) {
        // Group ports by sea component
        const portComponents = new Map();
        portsWithSeaIndex.forEach(port => {
          const compId = seaComponents[port.nodeId];
          if (!portComponents.has(compId)) portComponents.set(compId, []);
          portComponents.get(compId).push(port);
        });
        
        // Only keep ports in the largest sea component (usually the ocean)
        const largestComponent = Array.from(portComponents.entries())
          .reduce((max, [compId, ports]) => ports.length > max[1].length ? [compId, ports] : max);
        
        console.log(`Sea routing: using ${largestComponent[1].length} ports from largest sea component (${portComponents.size} total components)`);
        
        // Filter to only ports in the largest component
        const filteredPorts = largestComponent[1];
        portsWithSeaIndex.length = 0;
        portsWithSeaIndex.push(...filteredPorts);
      }
      
      // Ensure every island has at least one port with sea access
      const islandsWithSeaAccess = new Set();
      islandGroups.forEach((islandPorts, islandId) => {
        const hasSeaAccess = islandPorts.some(p => 
          portsWithSeaIndex.some(ps => ps.id === p.id)
        );
        if (hasSeaAccess) {
          islandsWithSeaAccess.add(islandId);
        } else {
          console.warn(`Island ${islandId} has no ports with sea access!`);
        }
      });
      
      console.log(`Islands with sea access: ${islandsWithSeaAccess.size}/${islandGroups.length}`);
      
      // 3) Build island-level distance tables using single-source Dijkstra
      const islandDistances = new Map(); // islandId -> { hubPort, distances }
      const usedEdges = new Set(); // Track used edges for penalty
      
      islandGroups.forEach((islandPorts, islandId) => {
        if (islandPorts.length === 0 || !islandsWithSeaAccess.has(islandId)) return;
        
        // Pick hub port (first port with sea access)
        const hubPort = islandPorts.find(p => {
          const portWithSea = portsWithSeaIndex.find(ps => ps.id === p.id);
          return portWithSea && portWithSea.nodeId >= 0;
        });
        
        if (!hubPort) return;
        
        const hubNodeId = portsWithSeaIndex.find(ps => ps.id === hubPort.id).nodeId;
        
        // Run single-source Dijkstra from hub (cached)
        console.log(`Island ${islandId}: Running SSSP from hub port ${hubPort.id} (nodeId: ${hubNodeId})`);
        const {dist, prev} = SeaRouter.ensureFor(hubNodeId);
        
        // Validate that we got valid results
        if (!dist || !prev || dist.length === 0) {
          console.warn(`Island ${islandId}: No valid sea distances computed from hub ${hubPort.id} (nodeId: ${hubNodeId})`);
          return;
        }
        
        console.log(`Island ${islandId}: SSSP computed distances to ${dist.length} nodes, predecessors for ${prev.length} nodes`);
        
        islandDistances.set(islandId, {
          hubPort,
          hubNodeId,
          distances: dist,
          predecessors: prev
        });
        
        if (DEBUG) console.log(`Island ${islandId}: hub at port ${hubPort.id}, computed distances to ${dist.length} ocean nodes`);
      });
      
      // 4) Build inter-island connections
      const islandConnections = [];
      
      // Find largest island (most ports) that has sea access
      const largestIslandId = islandGroups.reduce((max, ports, id) => {
        if (!islandsWithSeaAccess.has(id)) return max;
        if (!islandsWithSeaAccess.has(max)) return id;
        return ports.length > islandGroups[max]?.length ? id : max;
      }, 0);
      
      const largestIsland = islandDistances.get(largestIslandId);
      if (!largestIsland) {
        if (DEBUG) console.warn('No largest island with sea access found!');
        return;
      }
      
      if (DEBUG) console.log(`Largest island: ${largestIslandId} with ${islandGroups[largestIslandId].length} ports`);
      
      // Connect each island to largest island
      islandGroups.forEach((islandPorts, islandId) => {
        if (islandId === largestIslandId || islandPorts.length === 0 || !islandsWithSeaAccess.has(islandId)) return;
        
        const islandData = islandDistances.get(islandId);
        if (!islandData) {
          if (DEBUG) console.warn(`Island ${islandId} has no distance data despite having sea access!`);
          return;
        }
        
        // Find best connection to largest island
        let bestConnection = null;
        let bestCost = Infinity;
        
        islandPorts.forEach(port => {
          const portWithSea = portsWithSeaIndex.find(ps => ps.id === port.id);
          if (!portWithSea) return;
          
          const cost = islandData.distances[portWithSea.nodeId];
          const finalCost = (cost !== undefined && cost !== null) ? cost : Infinity;
          if (finalCost < bestCost) {
            bestCost = finalCost;
            bestConnection = {
              fromIsland: islandId,
              fromPort: port,
              fromNodeId: portWithSea.nodeId,
              toIsland: largestIslandId,
              cost: finalCost
            };
          }
        });
        
        if (bestConnection && bestCost < Infinity) {
          islandConnections.push(bestConnection);
          if (DEBUG) console.log(`Connected island ${islandId} to largest island ${largestIslandId} with cost ${bestCost.toFixed(1)}`);
        } else {
          if (DEBUG) console.warn(`Failed to connect island ${islandId} to largest island ${largestIslandId}`);
        }
      });
      
      // 5) Add optional connections between big islands (≥4 ports)
      const bigIslands = islandGroups
        .map((ports, id) => ({ id, portCount: ports.length }))
        .filter(island => island.portCount >= 4 && island.id !== largestIslandId);
      
      bigIslands.forEach(island => {
        const islandData = islandDistances.get(island.id);
        if (!islandData) return;
        
        // Find best connection to largest island (already computed above)
        const existingConnection = islandConnections.find(conn => conn.fromIsland === island.id);
        if (existingConnection) {
          // Add one more connection to another big island if beneficial
          bigIslands.forEach(otherIsland => {
            if (otherIsland.id <= island.id) return; // Avoid duplicates
            
            const otherData = islandDistances.get(otherIsland.id);
            if (!otherData) return;
            
            // Simple heuristic: connect if both islands are big and close
            const distance = Math.hypot(
              islandData.hubPort.x - otherData.hubPort.x,
              islandData.hubPort.y - otherData.hubPort.y
            );
            
            if (distance < 300) { // Threshold for big island connections
                               islandConnections.push({
                   fromIsland: island.id,
                   fromPort: islandData.hubPort,
                   fromNodeId: islandData.hubNodeId,
                   toIsland: otherIsland.id,
                   cost: distance
                 });
            }
          });
        }
      });
      
      // 6) Render connections
      const seaG = d3.select('#routes .searoutes');
      console.log('Sea routes layer found:', seaG.node());
      const line = d3.line().x(d => d[0]).y(d => d[1]).curve(d3.curveBasis);
      
      // Sea routes layer is working correctly
      
      console.log(`Processing ${islandConnections.length} island connections...`);
      let routesAdded = 0;
      
      islandConnections.forEach((connection, index) => {
        console.log(`Processing connection ${index + 1}/${islandConnections.length}:`, connection);
        // Find path from source to target
        const targetPort = islandGroups[connection.toIsland]?.[0];
        if (!targetPort) return;
        
        const targetWithSea = portsWithSeaIndex.find(ps => ps.id === targetPort.id);
        if (!targetWithSea) return;
        
        // Get the distances from the source island's data
        const sourceIslandData = islandDistances.get(connection.fromIsland);
        if (!sourceIslandData) return;
        
        // Use the predecessors from cached SSSP to find the actual path
        console.log(`Sea route: from island ${connection.fromIsland} (port ${connection.fromPort.id}, nodeId ${connection.fromNodeId}) to island ${connection.toIsland} (port ${targetPort.id}, nodeId ${targetWithSea.nodeId})`);
        
        const path = reconstructSeaPath(sourceIslandData.predecessors, targetWithSea.nodeId);
        console.log('Reconstructed path:', path, 'length:', path ? path.length : 0);
        
        // Sanity check: ensure the path actually reaches the target
        if (path && path.length > 0 && path[path.length - 1] !== targetWithSea.nodeId) {
          console.warn('Truncated sea route detected.', {target: targetWithSea.nodeId, pathLen: path.length, lastNode: path[path.length - 1]});
        }
        
        if (!path || path.length === 0) {
          console.warn('Empty path reconstructed, skipping route');
          return;
        }
        
        if (path && path.length > 1) {
          const points = polylineFromPath(path);
          console.log('Polyline points:', points, 'length:', points ? points.length : 0);
          
          if (!points || points.length === 0) {
            console.warn('Empty polyline points, skipping route');
            return;
          }
          
          // Use stricter simplification for sea routes to avoid crossing land
          // const simplified = adaptiveSimplifySea([points], window.__state.width, window.__state.height)[0];
          const simplified = points; // Use original points without simplification for now
          const smoothed = smoothLine(simplified, 1);
          
          console.log('Drawing sea route with points:', points.length, 'smoothed:', smoothed.length);
          if (smoothed.length > 0) {
            console.log('First point:', smoothed[0], 'Last point:', smoothed[smoothed.length - 1]);
          }
          
          const pathElement = seaG.append('path')
            .attr('d', line(smoothed))
            .attr('fill', 'none')
            .attr('stroke', '#ffffff')
            .attr('stroke-width', '2px')
            .attr('stroke-dasharray', '6 4')
            // Using layer mask instead of individual clip-path
            .attr('stroke-linecap', 'round')
            .attr('stroke-linejoin', 'round')
            .attr('opacity', '0.8')
            .attr('vector-effect', 'non-scaling-stroke');
          
          console.log('Added sea route path element:', pathElement.node());
          routesAdded++;
        }
      });
      
      console.log(`Successfully added ${routesAdded} sea routes`);
      
             // 7) Build port graph and optimize gap patching
      const portGraph = buildPortGraph(portsWithSeaIndex, seaGraph);
      const gapPatches = patchGapsOptimized(portGraph, islandGroups, islandDistances, largestIslandId);
       
       // 8) Ensure all islands with sea access are connected (fallback)
       const connectedIslands = new Set([largestIslandId]);
       islandConnections.forEach(conn => connectedIslands.add(conn.fromIsland));
       
       const unconnectedIslands = Array.from(islandsWithSeaAccess).filter(id => !connectedIslands.has(id));
       if (unconnectedIslands.length > 0) {
         console.warn(`Found ${unconnectedIslands.length} unconnected islands:`, unconnectedIslands);
         
         // Force connect unconnected islands to largest island
         unconnectedIslands.forEach(islandId => {
           const islandPorts = islandGroups[islandId];
           const islandData = islandDistances.get(islandId);
           
           if (!islandData || islandPorts.length === 0) return;
           
           // Find any port with sea access
           const anyPort = islandPorts.find(port => {
             const portWithSea = portsWithSeaIndex.find(ps => ps.id === port.id);
             return portWithSea && portWithSea.nodeId >= 0;
           });
           
           if (anyPort) {
             const portWithSea = portsWithSeaIndex.find(ps => ps.id === anyPort.id);
             console.log(`Force connecting unconnected island ${islandId} via port ${anyPort.id}`);
             
             // Add a direct connection to largest island
             const targetPort = islandGroups[largestIslandId]?.[0];
             if (targetPort) {
               const targetWithSea = portsWithSeaIndex.find(ps => ps.id === targetPort.id);
               if (targetWithSea) {
                 gapPatches.push({
                   fromPort: anyPort,
                   fromNodeId: portWithSea.nodeId,
                   toPort: targetPort,
                   toNodeId: targetWithSea.nodeId,
                   islandId: islandId, // Add island ID for path reconstruction
                   cost: Math.hypot(anyPort.x - targetPort.x, anyPort.y - targetPort.y)
                 });
               }
             }
           }
         });
       }
       
       // Render gap patches
       gapPatches.forEach(patch => {
         // Get the distances from the island this gap patch belongs to
         const islandData = islandDistances.get(patch.islandId);
         if (!islandData) return;
         
         const path = reconstructSeaPath(islandData.predecessors, patch.toNodeId);
         if (path) {
           const points = polylineFromPath(path);
           // Use stricter simplification for sea routes to avoid crossing land
           // const simplified = adaptiveSimplifySea([points], window.__state.width, window.__state.height)[0];
           const simplified = points; // Use original points without simplification for now
           const smoothed = smoothLine(simplified, 1);
           
           seaG.append('path')
             .attr('d', line(smoothed))
             .attr('fill', 'none')
             .attr('stroke', '#ff0000')
             .attr('stroke-width', '2px')
             .attr('stroke-dasharray', '3 3')
             .attr('stroke-linecap', 'round')
             .attr('stroke-linejoin', 'round')
             .attr('opacity', '0.7')
             .attr('vector-effect', 'non-scaling-stroke');
         }
       });
       
       console.log(`Built ${islandConnections.length} inter-island sea connections + ${gapPatches.length} gap patches`);
     }
    
    // Batch processing for sea routes to keep UI responsive
    async function buildSeaRoutesInBatches(jobs, batch=8){
      let i=0;
      while(i<jobs.length){
        const end = Math.min(i+batch, jobs.length);
        for (; i<end; i++) {
          // Process one route job
          const job = jobs[i];
          // This would be where you call your routing function
          // For now, we'll just simulate the work
        }
        ProgressManager.update(90 * (i/jobs.length), 'Building routes…', `${i}/${jobs.length}`);
        await new Promise(r => requestAnimationFrame(r));
      }
      ProgressManager.update(100, 'Routes done');
      ProgressManager.hide();
    }

    // Guard against multiple simultaneous executions
    let isComputingRoutes = false;
    
    /**
     * Main routes computation function
     */
    function computeRoutes() {
      // Single-flight routing: if already running, set pending flag and return
      if (isRouting) {
        pendingRoutes = true;
        console.log('computeRoutes already running, setting pending flag...');
        return;
      }
      
      const token = ++routeRunToken;
      isRouting = true;
      pendingRoutes = false;
      
      // Reset debug counters and clear caches
      window.__state.shortestPathCallCount = 0;
      seaSSSPCache.clear(); // Clear sea route cache
      
      try {
        // Guard against calling before water mask exists
        if (!window.__state.isWater) {
          const sea = +DOM.seaLevelInput.value;
          computeLakes(sea);
        }
      
      // Update progress during route computation
      ProgressManager.update(92, 'Building routes...', 'Computing land networks...');
      
      // Use centralized route layers
      const roadsG = RouteLayers.roads;
      const trailsG = RouteLayers.trails;
      const seaG = RouteLayers.sea;
      
      // Incremental updates - only rebuild what's dirty
      if (RouteDirty.burgs || RouteDirty.landGraph) {
        roadsG.selectAll('path').remove();
        trailsG.selectAll('path').remove();
      }
      if (RouteDirty.sea) {
        seaG.selectAll('path').remove();
      }
      
      const cells = window.__state.cells;
      const isWater = window.__state.isWater;
      const burgs = window.__state.burgs || [];
      
      if (!cells || !isWater || burgs.length < 2) {
        return;
      }
      
      // Debug: Check if data is valid
      if (DEBUG) console.log(`computeRoutes: cells=${cells?.length || 0}, isWater=${isWater?.length || 0}, burgs=${burgs?.length || 0}`);
      
      const landGraph = buildLandGraph(cells, isWater);
      
      // Debug: Check if we have enough data
      if (DEBUG) {
        console.log('burgs', burgs.length);
        console.log('land edges', landGraph.edges.length);
      }
      
      markPorts(burgs, cells, isWater);
      
      // Collect route data for economic town placement
      const routeData = { routes: [], trails: [] };
      
      // Build primary roads (only if enabled)
      if (document.getElementById('roadsOnInput') && document.getElementById('roadsOnInput').checked) {
        ProgressManager.update(93, 'Building routes...', 'Computing primary roads...');
        
        // Add timeout to prevent hanging on roads computation
        const roadsTimeout = setTimeout(() => {
          console.warn('Roads computation taking too long, skipping...');
          return;
        }, 5000); // 5 second timeout
        
        try {
          routeData.routes = buildBackboneRoads(burgs, landGraph);
        } finally {
          clearTimeout(roadsTimeout);
        }
      }
      
      // Build local trails (only if enabled)
      if (document.getElementById('trailsOnInput') && document.getElementById('trailsOnInput').checked) {
        ProgressManager.update(94, 'Building routes...', 'Computing local trails...');
        
        // Add timeout to prevent hanging on trails computation
        const trailsTimeout = setTimeout(() => {
          console.warn('Trails computation taking too long, skipping...');
          return;
        }, 5000); // 5 second timeout
        
        try {
          routeData.trails = buildLocalTrails(burgs, landGraph);
        } finally {
          clearTimeout(trailsTimeout);
        }
      }
      
      // Build road usage data for economic town placement
      if (routeData.routes.length > 0 || routeData.trails.length > 0) {
        buildRoadUsage(routeData, cells);
      }
      
      // Build sea routes if enabled
      if (DOM.seaRoutesOnInput.checked) {
        ProgressManager.update(95, 'Building routes...', 'Computing sea networks...');
        if (DEBUG) console.log('Sea routes enabled, building sea graph...');
        
        const seaRouteStart = performance.now();
        
        // Add timeout to prevent hanging
        const seaRouteTimeout = setTimeout(() => {
          console.warn('Sea route computation taking too long, skipping...');
          return;
        }, 10000); // 10 second timeout
        
        try {
          const seaGraph = buildSeaGraph(cells, isWater);
          if (DEBUG) console.log(`Sea graph: ${seaGraph.nodes.length} nodes, ${seaGraph.edges.length} edges`);
          
          const portBurgs = burgs.filter(b => b.isPort || b.port);
          if (DEBUG) console.log(`Found ${portBurgs.length} port burgs:`, portBurgs.map(p => ({ id: p.id, cell: p.cell, name: p.name })));
          
          if (portBurgs.length >= 2) {
            // Group ports by landmass component for better sea route planning
            const components = findConnectedComponents(burgs, landGraph);
            const portComponents = components.map(component => 
              component.filter(burg => burg.isPort || burg.port)
            ).filter(ports => ports.length > 0);
            
            if (DEBUG) console.log(`Port components:`, portComponents.map(ports => ports.length));
            
            // Build hub-and-spoke sea transit network
            buildSeaTransitNetwork({ kHubs: Math.round(Math.sqrt((window.__state.ports?.length || window.__state.burgs?.length || 16) / 2)) });
            
            const seaRouteTime = performance.now() - seaRouteStart;
            if (DEBUG) console.log(`Sea routes built in ${seaRouteTime.toFixed(1)}ms (cache hits: ${seaSSSPCache.size})`);
          } else {
            if (DEBUG) console.log('Not enough port burgs for sea routes (need >= 2)');
          }
        } finally {
          clearTimeout(seaRouteTimeout);
        }
      } else {
        if (DEBUG) console.log('Sea routes disabled');
      }
      
      // Remove any test/debug lines
      d3.select('#test-line, #debug-line, .test-line, .debug-line').remove();
      
      // Debug: Check what was actually rendered
      if (DEBUG) {
        console.log('roads:', document.querySelectorAll('#routes .roads path').length);
        console.log('trails:', document.querySelectorAll('#routes .trails path').length);
        console.log('sea:', document.querySelectorAll('#routes .searoutes path').length);
      }
      
      // Optional: Add one-liner after rendering to confirm you drew something
      const seaPathCount = document.querySelectorAll('#routes .searoutes path').length;
      console.log(`Sea routes rendered: ${seaPathCount} paths`);
      if (seaPathCount > 0) {
        console.log('Sea route paths found:', document.querySelectorAll('#routes .searoutes path'));
        // Debug: Check if paths are actually visible
        const firstPath = document.querySelector('#routes .searoutes path');
        if (firstPath) {
          console.log('First sea route path:', firstPath);
          console.log('Path d attribute:', firstPath.getAttribute('d'));
          console.log('Path stroke:', firstPath.getAttribute('stroke'));
          console.log('Path stroke-width:', firstPath.getAttribute('stroke-width'));
          console.log('Path computed style:', window.getComputedStyle(firstPath).stroke);
        }
      }
      
      // Raise burgs above routes for crisp rendering
      d3.select('#burgs').raise();
      
      // Debug: Force sea routes to be on top
      d3.select('#routes .searoutes').raise();
      
      // Update progress to completion
      ProgressManager.update(100, 'Routes complete!', 'All road and sea networks built successfully');
      
      } catch (error) {
        console.error('Error in computeRoutes:', error);
        // Update progress to show error
        ProgressManager.update(100, 'Error in route computation', error.message);
      } finally {
        // Check if this is still the current run
        if (token !== routeRunToken) {
          console.log('Stale computeRoutes finisher, ignoring...');
          return;
        }
        
        isRouting = false;
        
        // Hide progress overlay after a short delay to show completion
        setTimeout(() => {
          ProgressManager.hide();
        }, 1000);
        
        // If there's a pending request, run once more
        if (pendingRoutes) {
          console.log('Pending routes detected, running one more time...');
          setTimeout(() => {
            if (window.__state.computeRoutes) {
              window.__state.computeRoutes();
            }
          }, 50);
        }
      }
    }

    // --- Test harness --- (kept original tests and added border checks)
    document.getElementById('runTests').addEventListener('click', runTests);

    function runTests() {
      const out = document.getElementById('testResults');
      out.innerHTML = '';

      function assert(name, condition) {
        const li = document.createElement('li');
        li.textContent = (condition ? '✓ ' : '✗ ') + name;
        li.className = condition ? 'pass' : 'fail';
        out.appendChild(li);
      }

      try {
        // Existing tests
        const n = sizeInput.valueAsNumber;
        const cellPaths = d3.selectAll('path.mapCell').size();
        assert('renders one SVG path per site', cellPaths === n);

        const st = window.__state;
        const mid = Math.floor(st.cells.length / 2);
        const beforeSeed = st.cells[mid].high;
        st.add(mid, 'island');
        const afterSeed = st.cells[mid].high;
        const neighborRaised = st.cells[st.cells[mid].neighbors[0]] ? (st.cells[st.cells[mid].neighbors[0]].high > 0) : true; // tolerate edge cases
        assert('add() increases height at the seed cell', afterSeed > beforeSeed);
        const allClamped = st.cells.every(c => c.high >= 0 && c.high <= 1);
        assert('all cell heights stay within [0, 1]', allClamped);
        assert('add() affects at least one neighbor', neighborRaised);

        // New tests
        // T4: autoSeed raises heights in many cells
        const raisedBefore = st.cells.filter(c => c.high > 0).length;
        st.autoSeed();
        const raisedAfter = st.cells.filter(c => c.high > 0).length;
        assert('autoSeed() raises heights in multiple cells', raisedAfter > raisedBefore + 5);

        // T5: sea level = 1.0 -> all water
        document.getElementById('seaLevelInput').value = 1.0; st.recolor();
        const waterAtMaxSea = st.cells.filter(c => c.high < 1.0).length;
        assert('sea level = 1.0 -> all water', waterAtMaxSea === st.cells.length);

        // T6: sea level = 0.0 -> all land
        document.getElementById('seaLevelInput').value = 0.0; st.recolor();
        const waterAtZeroSea = st.cells.filter(c => c.high < 0.0).length;
        assert('sea level = 0.0 -> all land', waterAtZeroSea === 0);

        // T7: default sea level (0.35) -> mix of land and water after autoSeed
        document.getElementById('seaLevelInput').value = 0.35; st.recolor();
        const water = st.cells.filter(c => c.high < 0.35).length;
        const land = st.cells.length - water;
        assert('sea level 0.35 -> mixed terrain', water > 0 && land > 0);

        // T8: Azgaar palette produces a gradient (many unique fills)
        const fills = new Set(Array.from(document.querySelectorAll('path.mapCell')).slice(0, 200).map(p => p.getAttribute('fill')));
        assert('Azgaar palette -> gradient (many unique fills)', fills.size > 5);

        // T9: Center area is significant after autoSeed (center-biased island)
        const svgSel = st.svg;
        const w = +svgSel.attr('width');
        const h = +svgSel.attr('height');
        const centerIdx = st.delaunay.find(w / 2, h / 2);
        assert('Center cell height is significant after autoSeed', st.cells[centerIdx].high > 0.4);

        // T10: Coastlines appear for mixed terrain
        st.recolor();
        const coastCount = d3.selectAll('g.coastline path.coast').size();
        assert('Coastlines are drawn when terrain is mixed', coastCount > 0);

        // T11: No coastlines when all water
        document.getElementById('seaLevelInput').value = 1.0; st.recolor();
        const coastAllWater = d3.selectAll('g.coastline path.coast').size();
        assert('No coastlines at sea level 1.0', coastAllWater === 0);

        // T12: No coastlines when all land
        document.getElementById('seaLevelInput').value = 0.0; st.recolor();
        const coastAllLand = d3.selectAll('g.coastline path.coast').size();
        assert('No coastlines at sea level 0.0', coastAllLand === 0);

        // T13: Border mask keeps a water frame around the map
        document.getElementById('seaLevelInput').value = 0.35; st.applyBorder(); st.recolor();
        const margin = st.borderPx * 0.9;
        const nearEdgeLand = st.cells.some(c => Math.min(c.cx, c.cy, w - c.cx, h - c.cy) < margin && c.high >= 0.35);
        assert('No land within the border margin', !nearEdgeLand);

        // T14: Water is a single uniform color below sea level
        document.getElementById('seaLevelInput').value = 0.5; st.recolor();
        const seaLvl = 0.5;
        const waterCells = st.cells.map((c,i)=>({i, h:c.high})).filter(o => o.h < seaLvl);
        let uniform = true;
        if (waterCells.length >= 2) {
          const getFill = (idx)=> (document.getElementById(String(idx))||{}).getAttribute ? document.getElementById(String(idx)).getAttribute('fill') : null;
          const first = getFill(waterCells[0].i);
          for (let k = 1; k < Math.min(200, waterCells.length); k++) {
            if (getFill(waterCells[k].i) !== first) { uniform = false; break; }
          }
        }
        assert('Water below sea level uses a uniform color', uniform);

        // T15: Low land near sea level should be greener than purple (G channel dominant)
        document.getElementById('seaLevelInput').value = 0.35; st.recolor();
        const seaLvl2 = 0.35;
        const nearShoreLand = st.cells.map((c,i)=>({i, h:c.high})).filter(o => o.h >= seaLvl2 && o.h < seaLvl2 + 0.03);
        function rgbParse(s){
          if(!s) return null; const i1=s.indexOf('('), i2=s.indexOf(')'); if(i1<0||i2<0) return null; const a=s.slice(i1+1,i2).split(',').map(x=>parseInt(x,10)); if(a.length<3) return null; return {r:a[0], g:a[1], b:a[2]};
        }
        let greenish = true;
        if (nearShoreLand.length){
          const idx = nearShoreLand[0].i; const fill = (document.getElementById(String(idx))||{}).getAttribute ? document.getElementById(String(idx)).getAttribute('fill') : null; const rgb = rgbParse(fill);
          greenish = !!rgb && (rgb.g > rgb.r && rgb.g > rgb.b);
        }
        assert('Low land near sea level is greenish', greenish);

        // T16: Highest peaks render light (snow‑capped), not dark
        document.getElementById('seaLevelInput').value = 0.35; st.recolor();
        const landCells = st.cells.map((c,i)=>({i, h:c.high})).filter(o=>o.h >= 0.35).sort((a,b)=>b.h-a.h);
        const top = landCells.slice(0, Math.max(1, Math.floor(landCells.length*0.01)));
        let snowOK = true;
        if (top.length){
          const getFill = (idx)=> (document.getElementById(String(idx))||{}).getAttribute ? document.getElementById(String(idx)).getAttribute('fill') : null;
          const lum = (s)=>{ if(!s) return 0; const i1=s.indexOf('('), i2=s.indexOf(')'); if(i1<0||i2<0) return 0; const a=s.slice(i1+1,i2).split(',').map(x=>parseInt(x,10)); if(a.length<3) return 0; const [r,g,b]=a.map(v=>{v/=255; return v<=0.03928? v/12.92 : Math.pow((v+0.055)/1.055,2.4);}); return 0.2126*r+0.7152*g+0.0722*b; };
          const lumVals = top.map(o=>lum(getFill(o.i))).filter(v=>!isNaN(v));
          const avgLum = lumVals.reduce((s,v)=>s+v,0)/lumVals.length;
          snowOK = avgLum > 0.75; // should be quite light
        }
        assert('High peaks are light (snow‑caps)', snowOK);

        // T17: No strokes on cells (fills meet with no borders)
        const anyStroked = Array.from(document.querySelectorAll('path.mapCell')).some(p => {
          const s = window.getComputedStyle(p);
          const sw = s.getPropertyValue('stroke-width');
          const stc = s.getPropertyValue('stroke');
          return (sw && sw !== '0px') && (stc && stc !== 'none' && stc !== 'rgba(0, 0, 0, 0)');
        });
        assert('Cells render without strokes/borders', !anyStroked);

        // T18: Rivers exist at default settings
        document.getElementById('seaLevelInput').value = 0.35; st.recolor();
        const riverCount = d3.selectAll('g.rivers path.rivers').size();
        assert('At least one river is drawn', riverCount > 0);

        // T19: No rivers when all water
        document.getElementById('seaLevelInput').value = 1.0; st.recolor();
        const riverNone = d3.selectAll('g.rivers path.rivers').size();
        assert('No rivers when map is all water', riverNone === 0);

        // T20: More rainfall -> more rivers
        document.getElementById('seaLevelInput').value = 0.35;
        document.getElementById('rainInput').value = 0.2; st.recolor();
        const riversLow = d3.selectAll('g.rivers path.rivers').size();
        document.getElementById('rainInput').value = 1.8; st.recolor();
        const riversHigh = d3.selectAll('g.rivers path.rivers').size();
        assert('Higher rainfall increases river count', riversHigh > riversLow);

        // T21: Higher river-density quantile -> fewer rivers
        document.getElementById('rainInput').value = 1.0;
        document.getElementById('riverDensityInput').value = 0.98; st.recolor();
        const riversDense = d3.selectAll('g.rivers path.rivers').size();
        document.getElementById('riverDensityInput').value = 0.85; st.recolor();
        const riversSparse = d3.selectAll('g.rivers path.rivers').size();
        assert('Lower threshold draws more rivers', riversSparse >= riversDense);

        // T22: Tributaries are drawn (in addition to main rivers)
        document.getElementById('seaLevelInput').value = 0.35;
        document.getElementById('rainInput').value = 1.4; st.recolor();
        const majors = d3.selectAll('g.rivers path.rivers.main').size();
        const tribs = d3.selectAll('g.rivers path.rivers.trib').size();
        assert('Tributaries are present', tribs > 0 && majors >= 5 && majors <= 15);

        // T23: Tributaries are thinner than mains (average width)
        function avgWidth(sel){ const arr = []; d3.selectAll(sel).each(function(){ const w = +this.getAttribute('stroke-width')||0; if (w>0) arr.push(w); }); return arr.length? (arr.reduce((a,b)=>a+b,0)/arr.length) : 0; }
        const avgMain = avgWidth('g.rivers path.rivers.main');
        const avgTrib = avgWidth('g.rivers path.rivers.trib');
        assert('Tributaries are thinner than main rivers', avgTrib > 0 && avgMain > 0 && avgTrib < avgMain);

        // T24: Rivers have visible tapering (variation in widths across segments)
        st.recolor();
        const widths = []; d3.selectAll('g.rivers path.rivers').each(function(){ const w = +this.getAttribute('stroke-width')||0; if (w>0) widths.push(w); });
        const minW = Math.min.apply(null, widths), maxW = Math.max.apply(null, widths);
        assert('River widths vary (tapering present)', widths.length>5 && maxW > minW * 1.3);

        // T25: At least one confluence exists at higher rain
        document.getElementById('rainInput').value = 1.6; st.recolor();
        const rs = window.__state.riverStats || {confluences:0};
        assert('Confluences detected (>=1)', rs.confluences >= 1);

        // T26: Most main rivers reach the ocean
        document.getElementById('rainInput').value = 1.2; st.recolor();
        const rs2 = window.__state.riverStats || {majorsDrawn:0, majorsReachedSea:0};
        const fracOcean = rs2.majorsDrawn ? (rs2.majorsReachedSea / rs2.majorsDrawn) : 0;
        assert('Major rivers: majority reach the ocean', rs2.majorsDrawn === 0 || fracOcean >= 0.6);

        // T27: Main rivers are reasonably long on average
        const rs3 = window.__state.riverStats || {avgMainLength:0};
        assert('Average main length is decent (>=60px)', rs3.avgMainLength >= 60 || rs2.majorsDrawn === 0);

        // T28: Lakes (if any) have a valid outlet or are endorheic
        document.getElementById('seaLevelInput').value = 0.35; st.recolor();
        const lakes = window.__state.lakes || [];
        let lakesOk = true;
        for (let i = 0; i < lakes.length; i++) {
          const L = lakes[i];
          if (!L) continue;
          if (L.outlet == null || L.outlet === -1) continue; // endorheic allowed
          if (!(L.outlet >= 0 && L.outlet < st.cells.length)) { lakesOk = false; break; }
        }
        assert('Lakes (if any) have outlet or are endorheic', lakesOk);

        // T29: Lake cells render as water (transparent polygon fill over ocean backdrop)
        let foundLakeCell = -1;
        if (window.__state.lakeId) {
          for (let i = 0; i < st.cells.length; i++) { if (st.cells[i].high >= 0.35 && window.__state.lakeId[i] >= 0) { foundLakeCell = i; break; } }
        }
        let lakeFillNone = true;
        if (foundLakeCell >= 0) {
          const el = document.getElementById(String(foundLakeCell));
          lakeFillNone = !!el && el.getAttribute('fill') === 'none';
        }
        assert('Lake polygons use no fill (water shows through)', foundLakeCell === -1 || lakeFillNone);

        // T30: Lake filtering reduces excessive small lakes
        const lakeArray = window.__state.lakes || [];
        const lakeCells = window.__state.isLake ? window.__state.isLake.reduce((sum, val) => sum + val, 0) : 0;
        const totalLandCells = st.cells.filter(c => c.high >= 0.35).length;
        const lakePercentage = totalLandCells > 0 ? (lakeCells / totalLandCells) : 0;
        assert('Lake filtering prevents excessive lake coverage', lakePercentage < 0.15); // Lakes should not cover more than 15% of land

        // T31: Biome system assigns valid biomes to land cells
        document.getElementById('renderMode').value = 'biomes'; st.recolor();
        const biomeLandCells = st.cells.filter(c => c.high >= 0.35);
        const validBiomes = ['Tundra', 'Boreal Forest', 'Temperate Forest', 'Grassland', 'Desert', 'Savanna', 'Tropical Rainforest'];
        const hasValidBiomes = biomeLandCells.every(c => c.biome && validBiomes.includes(c.biome));
        assert('All land cells have valid biome assignments', hasValidBiomes);

        // T32: Temperature decreases with elevation
        const highCells = st.cells.filter(c => c.high > 0.6).slice(0, 10);
        const lowCells = st.cells.filter(c => c.high > 0.35 && c.high < 0.45).slice(0, 10);
        const avgHighTemp = highCells.reduce((sum, c) => sum + c.temp, 0) / highCells.length;
        const avgLowTemp = lowCells.reduce((sum, c) => sum + c.temp, 0) / lowCells.length;
        assert('Temperature decreases with elevation', avgHighTemp < avgLowTemp);

        // T33: Erosion reduces jaggy ridges (thermal erosion test)
        document.getElementById('talusInput').value = 0.02;
        document.getElementById('thermalStrengthInput').value = 0.5;
        document.getElementById('smoothAlphaInput').value = 0.2;
        st.generate(); // Regenerate with erosion
        const erodedLandCells = st.cells.filter(c => c.high > 0.35);
        let maxHeightDiff = 0;
        erodedLandCells.forEach(c => {
          c.neighbors.forEach(nb => {
            const diff = Math.abs(c.high - st.cells[nb].high);
            maxHeightDiff = Math.max(maxHeightDiff, diff);
          });
        });
        assert('Erosion reduces extreme height differences', maxHeightDiff < 0.8); // Should be less than 0.8 after erosion

        // T34: Wind belt system creates latitudinal precipitation patterns
        document.getElementById('windBelts').value = 'hadley';
        document.getElementById('rainInput').value = 1.0;
        st.recolor();
        const precipArray = window.__state.precipArray || [];
        if (precipArray.length > 0) {
          // Check that different latitude bands have different precipitation patterns
          const northernCells = st.cells.filter(c => c.cy < 300).slice(0, 20); // Top portion
          const southernCells = st.cells.filter(c => c.cy > 500).slice(0, 20); // Bottom portion
          const northernPrecip = northernCells.reduce((sum, c) => sum + (precipArray[c.index] || 0), 0) / northernCells.length;
          const southernPrecip = southernCells.reduce((sum, c) => sum + (precipArray[c.index] || 0), 0) / southernCells.length;
          // Should have some variation due to wind belts
          assert('Wind belts create latitudinal precipitation variation', Math.abs(northernPrecip - southernPrecip) > 0.01);
        } else {
          assert('Wind belt precipitation computation works', true); // Fallback if no precip array
        }

        // T35: Shaded relief creates depth perception
        document.getElementById('shadingMode').value = 'shaded';
        st.recolor();
        const shadedCells = d3.selectAll('path.mapCell').filter(function() {
          const fill = this.getAttribute('fill');
          return fill && fill.startsWith('rgb('); // Shaded cells use rgb() format
        });
        assert('Shaded relief applies RGB shading to land cells', shadedCells.size() > 0);

        // T36: Export functions are available
        assert('SVG export function is available', typeof window.saveSVG === 'function');
        assert('PNG export function is available', typeof window.savePNG === 'function');
        
        // T37: Ocean background is properly set for export
        const svg = document.querySelector('svg');
        const oceanRect = svg.querySelector('rect.ocean');
        assert('Ocean background rect exists', !!oceanRect);
        assert('Ocean background has correct fill color', oceanRect.getAttribute('fill') === WATER_COLOR);
        
        // T38: Rivers are properly computed and rendered
        const riverGroups = svg.querySelectorAll('g.rivers, g.riversShade');
        const riverPaths = svg.querySelectorAll('g.rivers path, g.riversShade path');
        assert('River groups exist in SVG', riverGroups.length > 0);
        assert('River paths are rendered', riverPaths.length > 0);
        
        // T38.5: Coastlines are properly computed and rendered
        const coastlineGroups = svg.querySelectorAll('g.coastline');
        const coastlinePaths = svg.querySelectorAll('g.coastline path.coast');
        assert('Coastline groups exist in SVG', coastlineGroups.length > 0);
        assert('Coastline paths are rendered', coastlinePaths.length > 0);
        
        // T38.6: Burgs are properly computed and rendered
        const burgGroups = svg.querySelectorAll('#burgs');
        const burgs = svg.querySelectorAll('#burgs g.burg');
        assert('Burg groups exist in SVG', burgGroups.length > 0);
        assert('Burgs are rendered', burgs.length > 0);
        
        // T38.7: Burgs have proper styling
        if (burgs.length > 0) {
          const sampleBurg = burgs[0];
          const circle = sampleBurg.querySelector('circle');
          assert('Burgs have circle elements', !!circle);
          if (circle) {
            const hasFill = circle.hasAttribute('fill');
            const hasStroke = circle.hasAttribute('stroke');
            const hasStrokeWidth = circle.hasAttribute('stroke-width');
            assert('Burg circles have proper styling', hasFill && hasStroke && hasStrokeWidth);
          }
        }
        
        // T38.8: Routes are properly computed and rendered
        const routeGroups = svg.querySelectorAll('#routes');
        const roads = svg.querySelectorAll('#routes .roads path');
        const trails = svg.querySelectorAll('#routes .trails path');
        const seaRoutes = svg.querySelectorAll('#routes .searoutes path');
        assert('Route groups exist in SVG', routeGroups.length > 0);
        assert('Roads are rendered', roads.length > 0);
        assert('Trails are rendered', trails.length > 0);
        
        // T38.9: Routes have proper styling
        if (roads.length > 0) {
          const sampleRoad = roads[0];
          const hasStroke = sampleRoad.hasAttribute('stroke');
          const hasStrokeWidth = sampleRoad.hasAttribute('stroke-width');
          assert('Road paths have proper styling', hasStroke && hasStrokeWidth);
        }
        
        // Check that rivers have proper styling
        if (riverPaths.length > 0) {
          const samplePath = riverPaths[0];
          const hasStroke = samplePath.hasAttribute('stroke') || samplePath.style.stroke;
          const hasStrokeWidth = samplePath.hasAttribute('stroke-width') || samplePath.style.strokeWidth;
          assert('River paths have stroke attributes', hasStroke || hasStrokeWidth);
        }
        
        // Test ocean export preservation
        const clone = svg.cloneNode(true);
        const cloneOcean = clone.querySelector('rect.ocean');
        cloneOcean.setAttribute('fill', WATER_COLOR);
        cloneOcean.setAttribute('style', `fill: ${WATER_COLOR}`);
        inlineSvgStyles(clone, true);
        assert('Ocean fill is preserved during export styling', cloneOcean.getAttribute('fill') === WATER_COLOR);
        
        // Test river export preservation
        const exportRiverGroups = clone.querySelectorAll('g.rivers, g.riversShade');
        const exportRiverPaths = clone.querySelectorAll('g.rivers path, g.riversShade path');
        assert('River groups are present in export clone', exportRiverGroups.length > 0);
        assert('River paths are present in export clone', exportRiverPaths.length > 0);
        
        // Check that river styles are properly inlined
        if (exportRiverPaths.length > 0) {
          const samplePath = exportRiverPaths[0];
          const hasStroke = samplePath.hasAttribute('stroke') || samplePath.style.stroke;
          const hasStrokeWidth = samplePath.hasAttribute('stroke-width') || samplePath.style.strokeWidth;
          assert('River paths have stroke attributes inlined', hasStroke || hasStrokeWidth);
        }
        
        // T39: Coastlines are properly exported
        const exportCoastlineGroups = clone.querySelectorAll('g.coastline');
        const exportCoastlinePaths = clone.querySelectorAll('g.coastline path.coast');
        assert('Coastline groups are present in export clone', exportCoastlineGroups.length > 0);
        assert('Coastline paths are present in export clone', exportCoastlinePaths.length > 0);
        
        // Check that coastline styles are properly inlined
        if (exportCoastlinePaths.length > 0) {
          const samplePath = exportCoastlinePaths[0];
          const hasStroke = samplePath.hasAttribute('stroke') || samplePath.style.stroke;
          const hasStrokeWidth = samplePath.hasAttribute('stroke-width') || samplePath.style.strokeWidth;
          assert('Coastline paths have stroke attributes inlined', hasStroke || hasStrokeWidth);
        }
        
        // T40: Burgs are properly exported
        const exportBurgGroups = clone.querySelectorAll('#burgs');
        const exportBurgs = clone.querySelectorAll('#burgs g.burg');
        assert('Burg groups are present in export clone', exportBurgGroups.length > 0);
        assert('Burgs are present in export clone', exportBurgs.length > 0);
        
        // Check that burg styles are properly inlined
        if (exportBurgs.length > 0) {
          const sampleBurg = exportBurgs[0];
          const circle = sampleBurg.querySelector('circle');
          if (circle) {
            const hasFill = circle.hasAttribute('fill') || circle.style.fill;
            const hasStroke = circle.hasAttribute('stroke') || circle.style.stroke;
            const hasStrokeWidth = circle.hasAttribute('stroke-width') || circle.style.strokeWidth;
            assert('Burg circles have style attributes inlined', hasFill && hasStroke && hasStrokeWidth);
          }
        }
        
        // T41: Routes are properly exported
        const exportRouteGroups = clone.querySelectorAll('#routes');
        const exportRoads = clone.querySelectorAll('#routes .roads path');
        const exportTrails = clone.querySelectorAll('#routes .trails path');
        const exportSeaRoutes = clone.querySelectorAll('#routes .searoutes path');
        assert('Route groups are present in export clone', exportRouteGroups.length > 0);
        assert('Roads are present in export clone', exportRoads.length > 0);
        assert('Trails are present in export clone', exportTrails.length > 0);
        
        // Check that route styles are properly inlined
        if (exportRoads.length > 0) {
          const sampleRoad = exportRoads[0];
          const hasStroke = sampleRoad.hasAttribute('stroke') || sampleRoad.style.stroke;
          const hasStrokeWidth = sampleRoad.hasAttribute('stroke-width') || sampleRoad.style.strokeWidth;
          assert('Road paths have stroke attributes inlined', hasStroke && hasStrokeWidth);
        }

      } catch (e) {
        const li = document.createElement('li');
        li.textContent = '✗ Tests crashed: ' + (e && e.message ? e.message : e);
        li.className = 'fail';
        out.appendChild(li);
        console.error(e);
      }
    }

    // Modal and tab functionality
    window.toggleSettings = function() {
      const modal = document.getElementById('settingsModal');
      if (modal.style.display === 'block') {
        modal.style.display = 'none';
      } else {
        modal.style.display = 'block';
      }
    }

    window.showTab = function(tabName) {
      // Hide all tab contents
      const tabContents = document.querySelectorAll('.tab-content');
      tabContents.forEach(content => {
        content.classList.remove('active');
      });

      // Remove active class from all tab buttons
      const tabButtons = document.querySelectorAll('.tab-btn');
      tabButtons.forEach(btn => {
        btn.classList.remove('active');
      });

      // Show selected tab content
      const selectedTab = document.getElementById(tabName + '-tab');
      if (selectedTab) {
        selectedTab.classList.add('active');
      }

      // Add active class to selected tab button
      const selectedButton = document.querySelector(`[onclick="showTab('${tabName}')"]`);
      if (selectedButton) {
        selectedButton.classList.add('active');
      }
    }

    // Close modal when clicking outside of it
    window.onclick = function(event) {
      const modal = document.getElementById('settingsModal');
      if (event.target === modal) {
        modal.style.display = 'none';
      }
    }

    // Close modal with Escape key
    document.addEventListener('keydown', function(event) {
      if (event.key === 'Escape') {
        const modal = document.getElementById('settingsModal');
        if (modal.style.display === 'block') {
          modal.style.display = 'none';
        }
      }
    });
  })();
  </script>
</body>
</html>
