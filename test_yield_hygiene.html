<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Yield & Timeout Hygiene Test</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .test-section { margin: 20px 0; padding: 15px; border: 1px solid #ccc; }
        .success { color: green; }
        .error { color: red; }
        .warning { color: orange; }
        button { padding: 10px 20px; margin: 5px; }
        #log { background: #f5f5f5; padding: 10px; height: 300px; overflow-y: auto; font-family: monospace; }
    </style>
</head>
<body>
    <h1>Yield & Timeout Hygiene Test</h1>
    
    <div class="test-section">
        <h2>Performance Observer Test</h2>
        <p>This test verifies that no long tasks >250ms occur during burg seeding.</p>
        <button onclick="testLongTasks()">Test Long Tasks</button>
        <div id="longTaskResults"></div>
    </div>
    
    <div class="test-section">
        <h2>Timeout Recovery Test</h2>
        <p>This test verifies that timeouts are handled gracefully and progress continues.</p>
        <button onclick="testTimeoutRecovery()">Test Timeout Recovery</button>
        <div id="timeoutResults"></div>
    </div>
    
    <div class="test-section">
        <h2>Error Recovery Test</h2>
        <p>This test verifies that name generation errors don't block the pipeline.</p>
        <button onclick="testErrorRecovery()">Test Error Recovery</button>
        <div id="errorResults"></div>
    </div>
    
    <div class="test-section">
        <h2>Burg Seeding Test</h2>
        <p>This test verifies that burg seeding works correctly and generates capitals.</p>
        <button onclick="testBurgSeeding()">Test Burg Seeding</button>
        <div id="burgResults"></div>
    </div>
    
    <div class="test-section">
        <h2>IsWater Test</h2>
        <p>This test verifies that isWater computation works correctly.</p>
        <button onclick="testIsWater()">Test IsWater</button>
        <div id="isWaterResults"></div>
    </div>
    
    <div class="test-section">
        <h2>Land Fallback Test</h2>
        <p>This test verifies that land fallback rendering works when regions fail.</p>
        <button onclick="testLandFallback()">Test Land Fallback</button>
        <div id="landFallbackResults"></div>
    </div>
    
    <div class="test-section">
        <h2>Test Log</h2>
        <div id="log"></div>
    </div>

    <script>
        function log(message, type = 'info') {
            const logDiv = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            const color = type === 'error' ? 'red' : type === 'success' ? 'green' : type === 'warning' ? 'orange' : 'black';
            logDiv.innerHTML += `<div style="color: ${color}">[${timestamp}] ${message}</div>`;
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function testLongTasks() {
            log('Starting long task test...');
            const resultsDiv = document.getElementById('longTaskResults');
            
            // Install PerformanceObserver if not already present
            if (!window.longTaskObserver) {
                try {
                    const obs = new PerformanceObserver((list) => {
                        for (const entry of list.getEntries()) {
                            if (entry.duration > 250) {
                                log(`⚠️ Long task detected: ${Math.round(entry.duration)}ms`, 'warning');
                            }
                        }
                    });
                    obs.observe({ entryTypes: ['longtask'] });
                    window.longTaskObserver = obs;
                    log('PerformanceObserver installed for long tasks', 'success');
                } catch (e) {
                    log(`Failed to install PerformanceObserver: ${e.message}`, 'error');
                }
            }
            
            // Simulate a long-running operation with yields
            let longTaskCount = 0;
            const startTime = performance.now();
            
            async function simulateLongOperation() {
                for (let i = 0; i < 1000; i++) {
                    // Simulate work
                    for (let j = 0; j < 10000; j++) {
                        Math.random() * Math.random();
                    }
                    
                    // Yield every 8ms
                    if (i % 100 === 0) {
                        await new Promise(resolve => requestAnimationFrame(resolve));
                    }
                }
            }
            
            simulateLongOperation().then(() => {
                const duration = performance.now() - startTime;
                log(`Long operation completed in ${Math.round(duration)}ms`, 'success');
                resultsDiv.innerHTML = `<div class="success">✅ Long task test completed. Check console for any long task warnings.</div>`;
            });
        }

        function testTimeoutRecovery() {
            log('Starting timeout recovery test...');
            const resultsDiv = document.getElementById('timeoutResults');
            
            // Simulate a timeout scenario
            const timeoutPromise = new Promise(resolve => 
                setTimeout(() => resolve('__TIMEOUT__'), 100)
            );
            
            const workPromise = new Promise(resolve => {
                // Simulate work that takes longer than timeout
                setTimeout(() => resolve('WORK_COMPLETE'), 500);
            });
            
            Promise.race([workPromise, timeoutPromise]).then(result => {
                if (result === '__TIMEOUT__') {
                    log('✅ Timeout occurred and was handled gracefully', 'success');
                    resultsDiv.innerHTML = `<div class="success">✅ Timeout recovery test passed</div>`;
                } else {
                    log('⚠️ Work completed before timeout', 'warning');
                    resultsDiv.innerHTML = `<div class="warning">⚠️ Work completed before timeout (this is OK)</div>`;
                }
            });
        }

        function testErrorRecovery() {
            log('Starting error recovery test...');
            const resultsDiv = document.getElementById('errorResults');
            
            // Simulate error-prone operations
            async function simulateErrorRecovery() {
                const results = [];
                
                for (let i = 0; i < 10; i++) {
                    try {
                        // Simulate occasional errors
                        if (Math.random() < 0.3) {
                            throw new Error(`Simulated error for item ${i}`);
                        }
                        results.push(`Item ${i} processed successfully`);
                    } catch (error) {
                        log(`Error processing item ${i}: ${error.message}`, 'warning');
                        results.push(`Item ${i} failed, using fallback`);
                    }
                    
                    // Yield to prevent UI blocking
                    if (i % 3 === 0) {
                        await new Promise(resolve => requestAnimationFrame(resolve));
                    }
                }
                
                return results;
            }
            
            simulateErrorRecovery().then(results => {
                log(`✅ Error recovery test completed. Processed ${results.length} items.`, 'success');
                resultsDiv.innerHTML = `<div class="success">✅ Error recovery test passed. All items processed with fallbacks.</div>`;
            });
        }

        function testBurgSeeding() {
            log('Starting burg seeding test...');
            const resultsDiv = document.getElementById('burgResults');
            
            // Mock the necessary functions and data for testing
            const mockCells = Array.from({length: 100}, (_, i) => ({
                cx: Math.random() * 800,
                cy: Math.random() * 600,
                index: i,
                high: Math.random()
            }));
            
            const mockIsWater = new Array(100).fill(false).map(() => Math.random() < 0.3);
            
            // Mock the mulberry32 function
            function mockMulberry32(seed) {
                return function() {
                    seed = seed + 0x6D2B79F5 | 0;
                    let t = Math.imul(seed ^ seed >>> 15, 1 | seed);
                    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
                    return ((t ^ t >>> 14) >>> 0) / 4294967296;
                };
            }
            
            // Mock the generateSeededBurgs function
            function generateSeededBurgs(cells, isWater, seed) {
                const rng = mockMulberry32(seed);
                const burgs = [];
                
                // Find land cells
                const landCells = cells.map((c, i) => ({...c, index: i})).filter(c => !isWater[c.index]);
                
                if (landCells.length === 0) {
                    log('generateSeededBurgs: no land cells found', 'warning');
                    return burgs;
                }
                
                // Generate a reasonable number of burgs based on land area
                const targetBurgCount = Math.max(3, Math.floor(landCells.length * 0.02));
                const capitalCount = Math.max(1, Math.floor(targetBurgCount * 0.1));
                
                // Generate capitals first (farthest-first placement)
                const capitals = [];
                if (landCells.length > 0) {
                    // Start with a random cell
                    const firstCapital = landCells[Math.floor(rng() * landCells.length)];
                    capitals.push({
                        x: firstCapital.cx,
                        y: firstCapital.cy,
                        cellIndex: firstCapital.index,
                        type: 'capital',
                        capital: true,
                        power: 1
                    });
                    
                    // Add more capitals using farthest-first
                    while (capitals.length < capitalCount && capitals.length < landCells.length) {
                        let bestCell = null;
                        let bestMinDist = -1;
                        
                        for (const cell of landCells) {
                            if (capitals.some(cap => cap.cellIndex === cell.index)) continue;
                            
                            let minDist = Infinity;
                            for (const cap of capitals) {
                                const dx = cell.cx - cap.x;
                                const dy = cell.cy - cap.y;
                                const dist = dx * dx + dy * dy;
                                if (dist < minDist) minDist = dist;
                            }
                            
                            if (minDist > bestMinDist) {
                                bestMinDist = minDist;
                                bestCell = cell;
                            }
                        }
                        
                        if (bestCell) {
                            capitals.push({
                                x: bestCell.cx,
                                y: bestCell.cy,
                                cellIndex: bestCell.index,
                                type: 'capital',
                                capital: true,
                                power: 1
                            });
                        } else {
                            break;
                        }
                    }
                }
                
                // Add capitals to burgs array
                burgs.push(...capitals);
                
                // Generate regular burgs
                const remainingSlots = targetBurgCount - capitals.length;
                const availableCells = landCells.filter(cell => 
                    !capitals.some(cap => cap.cellIndex === cell.index)
                );
                
                for (let i = 0; i < remainingSlots && i < availableCells.length; i++) {
                    const cell = availableCells[Math.floor(rng() * availableCells.length)];
                    availableCells.splice(availableCells.indexOf(cell), 1);
                    
                    const burgType = rng() < 0.3 ? 'town' : 'village';
                    burgs.push({
                        x: cell.cx,
                        y: cell.cy,
                        cellIndex: cell.index,
                        type: burgType,
                        capital: false,
                        power: 0.5
                    });
                }
                
                return burgs;
            }
            
            // Test the burg seeding
            const testSeed = 12345;
            const burgs = generateSeededBurgs(mockCells, mockIsWater, testSeed);
            
            const capitalCount = burgs.filter(b => b.capital).length;
            const totalBurgs = burgs.length;
            
            log(`Generated ${totalBurgs} burgs with ${capitalCount} capitals`, 'success');
            
            if (totalBurgs > 0 && capitalCount > 0) {
                log('✅ Burg seeding test passed', 'success');
                resultsDiv.innerHTML = `<div class="success">✅ Burg seeding test passed. Generated ${totalBurgs} burgs with ${capitalCount} capitals.</div>`;
            } else {
                log('❌ Burg seeding test failed', 'error');
                resultsDiv.innerHTML = `<div class="error">❌ Burg seeding test failed. No burgs or capitals generated.</div>`;
            }
        }

        function testIsWater() {
            log('Starting isWater test...');
            const resultsDiv = document.getElementById('isWaterResults');
            
            // Mock cells with different heights
            const mockCells = [
                { high: 0.2, water: false },  // Below sea level (water)
                { high: 0.6, water: false },  // Above sea level (land)
                { high: 0.3, water: false },  // Below sea level (water)
                { high: 0.8, water: false },  // Above sea level (land)
                { high: 0.1, water: false }   // Below sea level (water)
            ];
            
            // Mock ensureIsWater function
            function ensureIsWater(cells) {
                const sea = 0.5; // Mock sea level
                const out = new Uint8Array(cells.length);
                
                for (let i = 0; i < out.length; i++) {
                    const c = cells[i] || {};
                    const flag = c.water ?? c.isWater ?? (c.high != null ? c.high < sea : false);
                    out[i] = flag ? 1 : 0;
                }
                
                return out;
            }
            
            // Test the isWater computation
            const isWater = ensureIsWater(mockCells);
            const waterCount = isWater.reduce((a, b) => a + b, 0);
            const landCount = isWater.length - waterCount;
            const landFrac = landCount / isWater.length;
            
            log(`Generated isWater array: [${Array.from(isWater)}]`, 'success');
            log(`Water cells: ${waterCount}, Land cells: ${landCount}`, 'success');
            log(`Land fraction: ${landFrac.toFixed(2)}`, 'success');
            
            if (waterCount > 0 && landCount > 0 && landFrac > 0.1) {
                log('✅ IsWater test passed', 'success');
                resultsDiv.innerHTML = `<div class="success">✅ IsWater test passed. Land fraction: ${landFrac.toFixed(2)}</div>`;
            } else {
                log('❌ IsWater test failed', 'error');
                resultsDiv.innerHTML = `<div class="error">❌ IsWater test failed. Land fraction too low: ${landFrac.toFixed(2)}</div>`;
            }
        }

        function testLandFallback() {
            log('Starting land fallback test...');
            const resultsDiv = document.getElementById('landFallbackResults');
            
            // Mock region assignment that fails (no regions)
            const mockRegionOfCell = new Array(10).fill(-1); // All neutral/water
            
            // Mock cells with land polygons
            const mockCells = [
                { poly: [[0,0], [10,0], [10,10], [0,10]], high: 0.6 }, // Land cell
                { poly: [[20,20], [30,20], [30,30], [20,30]], high: 0.7 }, // Land cell
                { poly: [[40,40], [50,40], [50,50], [40,50]], high: 0.8 }  // Land cell
            ];
            
            const mockIsWater = [0, 0, 0]; // All land cells
            
            // Test the fallback logic
            const hasRegions = Array.isArray(mockRegionOfCell) && mockRegionOfCell.some(r => r >= 0);
            const landPolys = mockCells?.filter((_,i)=>!mockIsWater?.[i]).map(c => c.poly).filter(Boolean) || [];
            
            log(`Has regions: ${hasRegions}`, 'warning');
            log(`Land polygons found: ${landPolys.length}`, 'success');
            
            if (!hasRegions && landPolys.length > 0) {
                log('✅ Land fallback test passed - fallback would render', 'success');
                resultsDiv.innerHTML = `<div class="success">✅ Land fallback test passed. Would render ${landPolys.length} land polygons as fallback.</div>`;
            } else if (hasRegions) {
                log('⚠️ Land fallback test - regions exist, fallback not needed', 'warning');
                resultsDiv.innerHTML = `<div class="warning">⚠️ Land fallback test - regions exist, fallback not needed.</div>`;
            } else {
                log('❌ Land fallback test failed - no land polygons found', 'error');
                resultsDiv.innerHTML = `<div class="error">❌ Land fallback test failed. No land polygons found for fallback.</div>`;
            }
        }

        // Auto-run basic tests on page load
        window.addEventListener('load', () => {
            log('Page loaded, running basic tests...');
            setTimeout(() => testLongTasks(), 1000);
            setTimeout(() => testTimeoutRecovery(), 2000);
            setTimeout(() => testErrorRecovery(), 3000);
            setTimeout(() => testBurgSeeding(), 4000);
            setTimeout(() => testIsWater(), 5000);
            setTimeout(() => testLandFallback(), 6000);
        });
    </script>
</body>
</html>
