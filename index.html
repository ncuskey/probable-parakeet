<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Voronoi Heightmap Playground</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji"; }
    body { margin: 16px; line-height: 1.45; }
    svg { background-color: #5E4FA2; display: block; border-radius: 8px; }
    .mapCell { stroke: none; stroke-width: 0; }
    label { margin-right: 6px; }
    input[type="range"] { width: 280px; vertical-align: middle; }
    output { display: inline-block; min-width: 48px; text-align: right; margin-left: 8px; }
    .controls { margin-top: 12px; }
    button { margin-right: 8px; }
    details.tests { margin-top: 14px; }
    .pass { color: #0a0; }
    .fail { color: #b00; }
    .row { margin: 6px 0; }
    /* Coastline styling */
      .coast { fill: none; stroke: #111; stroke-width: 0.6px; stroke-linejoin: round; vector-effect: non-scaling-stroke; }
    .rivers { stroke: #4D83AE; stroke-linecap: round; stroke-linejoin: round; vector-effect: non-scaling-stroke; }
    .riversShade { stroke: rgba(0,0,0,0.35); stroke-linecap: round; stroke-linejoin: round; vector-effect: non-scaling-stroke; }
    
    /* Route styling */
    #routes .roads { stroke: #6b4e16; stroke-width: 1.4px; fill: none; stroke-linecap: round; }
    #routes .trails { stroke: #9b7b3a; stroke-width: 1.0px; fill: none; stroke-dasharray: 3 3; stroke-linecap: round; }
    #routes .searoutes { stroke: #cfe9ff; stroke-width: 1.2px; fill: none; stroke-dasharray: 6 4; mix-blend-mode: overlay; }
    /* ensure export-friendly */
    #routes path { vector-effect: non-scaling-stroke; }

    /* Progress overlay styling */
    .progress-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      backdrop-filter: blur(2px);
    }

    .progress-content {
      background: rgba(255, 255, 255, 0.95);
      padding: 40px 50px;
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      text-align: center;
      min-width: 400px;
      border: 2px solid #4CAF50;
    }

    .progress-title {
      font-size: 20px;
      font-weight: bold;
      margin-bottom: 25px;
      color: #333;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .progress-bar {
      width: 100%;
      height: 12px;
      background: #e0e0e0;
      border-radius: 6px;
      overflow: hidden;
      margin-bottom: 20px;
      border: 1px solid #ccc;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #4CAF50, #45a049);
      width: 0%;
      transition: width 0.5s ease;
      border-radius: 6px;
      box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
    }

    .progress-text {
      font-size: 14px;
      color: #666;
      margin-bottom: 10px;
    }

    .progress-detail {
      font-size: 12px;
      color: #999;
      font-style: italic;
    }

    /* Add pulsing animation to make progress more visible */
    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.7; }
      100% { opacity: 1; }
    }

    .progress-overlay {
      animation: pulse 2s ease-in-out infinite;
    }

    /* Modal styles */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
    }

    .modal-content {
      background-color: #fefefe;
      margin: 5% auto;
      padding: 0;
      border: 1px solid #888;
      border-radius: 8px;
      width: 80%;
      max-width: 600px;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px 20px;
      border-bottom: 1px solid #ddd;
      background-color: #f8f9fa;
      border-radius: 8px 8px 0 0;
    }

    .modal-header h2 {
      margin: 0;
      color: #333;
      font-size: 1.5em;
    }

    .close {
      color: #aaa;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
      line-height: 1;
    }

    .close:hover {
      color: #000;
    }

    .modal-body {
      padding: 20px;
    }

    .settings-tabs {
      display: flex;
      border-bottom: 1px solid #ddd;
      margin-bottom: 20px;
    }

    .tab-btn {
      background: none;
      border: none;
      padding: 10px 20px;
      cursor: pointer;
      border-bottom: 2px solid transparent;
      font-size: 14px;
      color: #666;
    }

    .tab-btn:hover {
      background-color: #f0f0f0;
    }

    .tab-btn.active {
      color: #333;
      border-bottom-color: #007bff;
      font-weight: bold;
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    .hint {
      opacity: 0.7;
      font-size: 0.9em;
      color: #666;
      margin-left: 8px;
    }

    .primary-btn {
      background-color: #007bff;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
    }

    .primary-btn:hover {
      background-color: #0056b3;
    }

    .settings-btn {
      background-color: #6c757d;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
    }

    .settings-btn:hover {
      background-color: #545b62;
    }
  </style>
</head>
<body>
  <div style="display: flex; gap: 20px; align-items: flex-start;">
    <div id="mapContainer" style="flex: 1; min-width: 0; position: relative;">
      <svg id="map" width="1280" height="560" viewBox="0 0 1280 560" role="img" aria-label="Voronoi heightmap canvas" style="width: 100%; height: auto; max-width: none;"></svg>
      
      <!-- Progress Overlay -->
      <div id="progressOverlay" class="progress-overlay">
        <div class="progress-content">
          <div class="progress-title">Generating Map...</div>
          <div class="progress-bar">
            <div id="progressFill" class="progress-fill"></div>
          </div>
          <div id="progressText" class="progress-text">Initializing...</div>
          <div id="progressDetail" class="progress-detail"></div>
        </div>
      </div>
    </div>
    
    <div id="biomeLegend" style="display: none; min-width: 200px; background: rgba(255,255,255,0.9); padding: 10px; border-radius: 8px; border: 1px solid #ccc;">
      <h4 style="margin: 0 0 10px 0; font-size: 14px;">Biome Legend</h4>
      <div id="legendItems" style="font-size: 12px; line-height: 1.4;"></div>
    </div>
  </div>

  <div class="controls">
    <div class="row">
      <button onclick="generate()" class="primary-btn">Generate Map</button>
      <button onclick="toggleSettings()" class="settings-btn">⚙️ Settings</button>
    </div>

    <div class="row">
      <button onclick="saveSVG(document.querySelector('svg'), 'voronoi_map.svg')">Export SVG</button>
      <button onclick="savePNG(document.querySelector('svg'), 1280, 560, 'voronoi_map.png')">Export PNG</button>
    </div>
  </div>

  <!-- Settings Modal -->
  <div id="settingsModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Map Settings</h2>
        <span class="close" onclick="toggleSettings()">&times;</span>
      </div>
      
      <div class="modal-body">
        <div class="settings-tabs">
          <button class="tab-btn active" onclick="showTab('terrain')">Terrain</button>
          <button class="tab-btn" onclick="showTab('climate')">Climate</button>
          <button class="tab-btn" onclick="showTab('settlements')">Settlements</button>
          <button class="tab-btn" onclick="showTab('routes')">Routes</button>
        </div>

        <!-- Terrain Tab -->
        <div id="terrain-tab" class="tab-content active">
    <div class="row">
      <label>Graph Size:</label>
                    <input id="sizeInput" value="10000" type="range" min="100" max="25000" step="500" oninput="sizeOutput.value = sizeInput.valueAsNumber">
      <output id="sizeOutput">10000</output>
    </div>

    <div class="row">
      <label>Max High:</label>
      <input id="highInput" value="0.9" type="range" min="0.1" max="1" step="0.01" oninput="highOutput.value = highInput.valueAsNumber">
      <output id="highOutput">0.9</output>
    </div>

    <div class="row">
      <label>Radius:</label>
      <input id="radiusInput" value="0.9" type="range" min="0.5" max="0.999" step="0.001" oninput="radiusOutput.value = radiusInput.valueAsNumber">
            <output id="radiusOutput">0.9</output>
            <span class="hint">(change gently!)</span>
    </div>

    <div class="row">
      <label>Sharpness:</label>
      <input id="sharpnessInput" value="0.2" type="range" min="0" max="0.5" step="0.1" oninput="sharpnessOutput.value = sharpnessInput.valueAsNumber">
      <output id="sharpnessOutput">0.2</output>
    </div>

    <div class="row">
            <label># Small Hills:</label>
      <input id="smallCountInput" value="20" type="range" min="0" max="60" step="1" oninput="smallCountOutput.value = smallCountInput.valueAsNumber">
      <output id="smallCountOutput">20</output>
            <span class="hint">(auto‑seeded)</span>
    </div>

    <div class="row">
            <label>Sea Level:</label>
            <input id="seaLevelInput" value="0.35" type="range" min="0" max="1" step="0.01" oninput="seaLevelOutput.value = seaLevelInput.valueAsNumber;">
      <output id="seaLevelOutput">0.35</output>
    </div>

    <div class="row">
            <label>Water Border (%):</label>
            <input id="borderPctInput" value="8" type="range" min="2" max="20" step="1" oninput="borderPctOutput.value = borderPctInput.valueAsNumber; __state.applyBorder && __state.applyBorder(); __state.recolor && __state.recolor();">
      <output id="borderPctOutput">8</output>
    </div>

    <div class="row">
            <label>Min Lake Size:</label>
      <input id="minLakeSizeInput" value="3" type="range" min="1" max="10" step="1" oninput="minLakeSizeOutput.value = minLakeSizeInput.valueAsNumber; __state.recolor && __state.recolor();">
      <output id="minLakeSizeOutput">3</output>
    </div>

    <div class="row">
            <label>Min Lake Depth:</label>
      <input id="minLakeDepthInput" value="0.05" type="range" min="0.01" max="0.15" step="0.01" oninput="minLakeDepthOutput.value = minLakeDepthInput.valueAsNumber; __state.recolor && __state.recolor();">
      <output id="minLakeDepthOutput">0.05</output>
    </div>

    <div class="row">
      <label>World Type:</label>
      <select id="worldType" onchange="generate();">
        <option value="island" selected>Single Island</option>
        <option value="continents">Continents</option>
      </select>
    </div>

    <div class="row">
      <label>Thermal Erosion (Talus):</label>
      <input id="talusInput" value="0.02" type="range" min="0.01" max="0.05" step="0.005" oninput="talusOutput.value = talusInput.valueAsNumber; __state.recolor && __state.recolor();">
      <output id="talusOutput">0.02</output>
    </div>

    <div class="row">
      <label>Thermal Erosion (Strength):</label>
      <input id="thermalStrengthInput" value="0.5" type="range" min="0.1" max="1.0" step="0.1" oninput="thermalStrengthOutput.value = thermalStrengthInput.valueAsNumber; __state.recolor && __state.recolor();">
      <output id="thermalStrengthOutput">0.5</output>
    </div>

    <div class="row">
      <label>Land Smoothing (Alpha):</label>
      <input id="smoothAlphaInput" value="0.2" type="range" min="0.05" max="0.5" step="0.05" oninput="smoothAlphaOutput.value = smoothAlphaInput.valueAsNumber; __state.recolor && __state.recolor();">
      <output id="smoothAlphaOutput">0.2</output>
    </div>

    <div class="row">
      <label>River Style:</label>
      <select id="riverStyle" onchange="__state.recolor && __state.recolor();">
        <option value="lines">Lines</option>
        <option value="polygons" selected>Polygonal</option>
      </select>
    </div>

    <div class="row">
      <label>River Width:</label>
      <input id="riverWidthInput" value="200" type="range" min="50" max="400" step="10" oninput="riverWidthOutput.value = riverWidthInput.valueAsNumber; __state.recolor && __state.recolor();">
      <output id="riverWidthOutput">200</output>
    </div>
        </div>

        <!-- Climate Tab -->
        <div id="climate-tab" class="tab-content">
          <div class="row">
            <label>Rainfall:</label>
            <input id="rainInput" value="1.0" type="range" min="0" max="2" step="0.05" oninput="rainOutput.value = rainInput.valueAsNumber; __state.recolor && __state.recolor();">
            <output id="rainOutput">1.0</output>
          </div>

          <div class="row">
            <label>Wind Belts:</label>
            <select id="windBelts" onchange="__state.recolor && __state.recolor();">
              <option value="none" selected>None (Random)</option>
              <option value="hadley">Hadley/Ferrel/Polar</option>
            </select>
          </div>

          <div class="row">
            <label>River Density:</label>
            <input id="riverDensityInput" value="0.90" type="range" min="0.70" max="0.99" step="0.01" oninput="riverDensityOutput.value = riverDensityInput.valueAsNumber;">
            <output id="riverDensityOutput">0.90</output>
          </div>

          <div class="row">
            <label>Base Temperature (°F):</label>
            <input id="baseTempInput" value="67" type="range" min="41" max="77" step="1" oninput="baseTempOutput.value = baseTempInput.valueAsNumber; __state.recolor && __state.recolor();">
            <output id="baseTempOutput">67</output>
          </div>

          <div class="row">
            <label>Precipitation Scale:</label>
            <input id="precipScaleInput" value="1.1" type="range" min="0.1" max="2.0" step="0.1" oninput="precipScaleOutput.value = precipScaleInput.valueAsNumber; __state.recolor && __state.recolor();">
            <output id="precipScaleOutput">1.1</output>
          </div>

    <div class="row">
      <label>Render Mode:</label>
      <select id="renderMode" onchange="__state.recolor && __state.recolor();">
        <option value="heightmap" selected>Heightmap</option>
        <option value="biomes">Biomes</option>
        <option value="hybrid">Hybrid</option>
      </select>
    </div>

    <div class="row">
      <label>Shaded Relief:</label>
      <select id="shadingMode" onchange="__state.recolor && __state.recolor();">
        <option value="none" selected>None</option>
        <option value="shaded">Shaded</option>
      </select>
          </div>
    </div>

        <!-- Settlements Tab -->
        <div id="settlements-tab" class="tab-content">
          <div class="row">
            <label>Burgs Count:</label>
            <input id="burgsCountInput" value="25" type="range" min="0" max="50" step="1" oninput="burgsCountOutput.value = burgsCountInput.valueAsNumber; __state.generateBurgs && __state.generateBurgs();">
<output id="burgsCountOutput">25</output>
          </div>

    <div class="row">
            <label>Burg Spacing (px):</label>
            <input id="burgSpacingInput" value="12" type="range" min="8" max="20" step="1" oninput="burgSpacingOutput.value = burgSpacingInput.valueAsNumber; __state.generateBurgs && __state.generateBurgs();">
            <output id="burgSpacingOutput">12</output>
          </div>

          <div class="row">
            <label>River Weight:</label>
            <input id="riverWeightInput" value="0.4" type="range" min="0" max="1" step="0.1" oninput="riverWeightOutput.value = riverWeightInput.valueAsNumber; __state.generateBurgs && __state.generateBurgs();">
            <output id="riverWeightOutput">0.4</output>
          </div>

          <div class="row">
            <label>Coast Weight:</label>
            <input id="coastWeightInput" value="0.3" type="range" min="0" max="1" step="0.1" oninput="coastWeightOutput.value = coastWeightInput.valueAsNumber; __state.generateBurgs && __state.generateBurgs();">
            <output id="coastWeightOutput">0.3</output>
          </div>

          <div class="row">
            <label>Flatness Weight:</label>
            <input id="flatnessWeightInput" value="0.2" type="range" min="0" max="1" step="0.1" oninput="flatnessWeightOutput.value = flatnessWeightInput.valueAsNumber; __state.generateBurgs && __state.generateBurgs();">
            <output id="flatnessWeightOutput">0.2</output>
          </div>

          <div class="row">
            <label>Fertility Weight:</label>
            <input id="fertilityWeightInput" value="0.1" type="range" min="0" max="1" step="0.1" oninput="fertilityWeightOutput.value = fertilityWeightInput.valueAsNumber; __state.generateBurgs && __state.generateBurgs();">
            <output id="fertilityWeightOutput">0.1</output>
          </div>
        </div>

        <!-- Routes Tab -->
        <div id="routes-tab" class="tab-content">
          <div class="row">
            <label>Road Density (Primary):</label>
            <input id="roadDensityInput" value="0.6" type="range" min="0" max="1" step="0.05" oninput="roadDensityOutput.value = roadDensityInput.valueAsNumber; __state.computeRoutes && __state.computeRoutes();">
            <output id="roadDensityOutput">0.6</output>
          </div>

          <div class="row">
            <label>Trail Density (Local):</label>
            <input id="trailDensityInput" value="0.5" type="range" min="0" max="1" step="0.05" oninput="trailDensityOutput.value = trailDensityInput.valueAsNumber; __state.computeRoutes && __state.computeRoutes();">
            <output id="trailDensityOutput">0.5</output>
          </div>

          <div class="row">
            <label>Slope Penalty:</label>
            <input id="slopePenaltyInput" value="1.2" type="range" min="0" max="3" step="0.1" oninput="slopePenaltyOutput.value = slopePenaltyInput.valueAsNumber; __state.computeRoutes && __state.computeRoutes();">
            <output id="slopePenaltyOutput">1.2</output>
          </div>

          <div class="row">
            <label>River Crossing Penalty:</label>
            <input id="riverPenaltyInput" value="1.0" type="range" min="0" max="3" step="0.1" oninput="riverPenaltyOutput.value = riverPenaltyInput.valueAsNumber; __state.computeRoutes && __state.computeRoutes();">
            <output id="riverPenaltyOutput">1.0</output>
          </div>

          <div class="row">
            <label>Roads:</label>
            <input id="roadsOnInput" type="checkbox" checked onchange="toggleRoutes('roads', this.checked);">
            <span style="margin-left: 8px;">Enable primary roads</span>
          </div>

          <div class="row">
            <label>Trails:</label>
            <input id="trailsOnInput" type="checkbox" checked onchange="toggleRoutes('trails', this.checked);">
            <span style="margin-left: 8px;">Enable local trails</span>
          </div>

          <div class="row">
            <label>Sea Routes:</label>
            <input id="seaRoutesOnInput" type="checkbox" checked onchange="toggleRoutes('searoutes', this.checked);">
            <span style="margin-left: 8px;">Enable sea routes</span>
          </div>
        </div>
      </div>
    </div>
  </div>

  <details class="tests">
    <summary>Show Tests</summary>
    <button id="runTests">Run Tests</button>
    <ol id="testResults"></ol>
  </details>

  <!-- libs -->
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <!-- D3 v7 (uses d3.pointer and d3-delaunay for Voronoi) -->
  <script src="https://d3js.org/d3.v7.min.js"></script>

  <script>
    // Map size management function
    function setMapSize(w, h) {
      const svg = d3.select('#map');
      svg.attr('width', w).attr('height', h).attr('viewBox', `0 0 ${w} ${h}`);
      const canvas = document.getElementById('canvas');
      if (canvas) { canvas.width = w; canvas.height = h; }
    }

    // Debug flag for performance
    const DEBUG = false;

    // Debounce function for UI updates
    const rafDebounce = (fn) => {
      let r = 0; 
      return (...a) => { 
        cancelAnimationFrame(r); 
        r = requestAnimationFrame(() => fn(...a)); 
      }; 
    };

    // Heavy debounced recolor for expensive operations
    const heavyDebounce = (fn, delay = 150) => {
      let timeout = 0; 
      return (...a) => { 
        clearTimeout(timeout); 
        timeout = setTimeout(() => fn(...a), delay); 
      }; 
    };

    // Cached DOM elements for performance
    const DOM = {
      seaLevelInput: document.getElementById('seaLevelInput'),
      seaRoutesOnInput: document.getElementById('seaRoutesOnInput'),
      sizeInput: document.getElementById('sizeInput')
    };

    // Canvas-based terrain rendering for performance
    const TerrainCanvas = (() => {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      let terrainDirty = true;
      
      return {
        canvas,
        ctx,
        setDirty: () => { terrainDirty = true; },
        isDirty: () => terrainDirty,
        markClean: () => { terrainDirty = false; }
      };
    })();

    // Precipitation caching
    let PRECIP = null;
    function recomputePrecip() { 
      PRECIP = computePrecipArray(); 
    }

    // Set up precipitation recomputation on climate changes
    ['rainInput', 'windBelts'].forEach(id => {
      const element = document.getElementById(id);
      if (element) {
        element.addEventListener('input', rafDebounce(recomputePrecip));
      }
    });

    // Set up terrain dirty flag triggers
    ['seaLevelInput', 'talusInput', 'thermalStrengthInput', 'smoothAlphaInput'].forEach(id => {
      const element = document.getElementById(id);
      if (element) {
        element.addEventListener('input', () => TerrainCanvas.setDirty());
      }
    });

    // Set up debounced recolor for heavy sliders
    const heavySliders = ['seaLevelInput', 'riverDensityInput', 'riverWidthInput', 'minLakeSizeInput', 'minLakeDepthInput'];
    heavySliders.forEach(id => {
      const element = document.getElementById(id);
      if (element) {
        element.addEventListener('input', heavyDebounce(() => {
          RegenerationFlags.setNeedsRecolor();
          if (window.__state && window.__state.recolor) {
            window.__state.recolor();
          }
        }, 200));
      }
    });

    // Set up regeneration flags for seed-only changes
    const seedOnlySliders = ['highInput', 'radiusInput', 'sharpnessInput', 'smallCountInput'];
    seedOnlySliders.forEach(id => {
      const element = document.getElementById(id);
      if (element) {
        element.addEventListener('input', () => {
          RegenerationFlags.setNeedsRegenerate();
        });
      }
    });

    // Centralized route layer management
    const RouteLayers = (() => {
      const svg = d3.select('svg');
      let root = d3.select('#routes');
      if (root.empty()) {
        root = svg.append('g').attr('id', 'routes');
        root.append('g').attr('class', 'roads');
        root.append('g').attr('class', 'trails');
        root.append('g').attr('class', 'searoutes');
        // Keep routes group above map only once
        root.raise();
      }
      const g = {
        root,
        roads: root.select('.roads'),
        trails: root.select('.trails'),
        sea: root.select('.searoutes')
      };
      return g;
    })();

    // Route building optimization
    function pathFromPolylines(lines) {
      // lines: Array<Array<[x,y]>>
      let d = '';
      for (const L of lines) {
        if (!L.length) continue;
        d += `M${L[0][0]},${L[0][1]}`;
        for (let i = 1; i < L.length; i++) d += `L${L[i][0]},${L[i][1]}`;
      }
      return d;
    }
    
    /**
     * Draw lines with instrumentation for debugging
     * @param {string} selector - CSS selector for the target group
     * @param {Array} lines - Array of polylines
     */
    function drawLines(selector, lines) {
      const d = pathFromPolylines(lines);
      const sel = d3.select(selector);
      sel.selectAll('path').data([0]).join('path').attr('d', d);

      // Quick instrumentation
      const segs = lines.reduce((a, L) => a + Math.max(0, L.length - 1), 0);
      const len = lines.reduce((a, L) => a + L.reduce((s, [x, y], i) => s + (i ? Math.hypot(x - L[i - 1][0], y - L[i - 1][1]) : 0), 0), 0);
      console.log(selector, { polylines: lines.length, segments: segs, totalLength: len.toFixed(1) });
    }

    // SVG Path simplification using Ramer-Douglas-Peucker algorithm
    function simplifyPath(points, tolerance = 0.2) {
      if (points.length <= 2) return points;
      
      function perpendicularDistance(point, lineStart, lineEnd) {
        const [x, y] = point;
        const [x1, y1] = lineStart;
        const [x2, y2] = lineEnd;
        
        const A = x - x1;
        const B = y - y1;
        const C = x2 - x1;
        const D = y2 - y1;
        
        const dot = A * C + B * D;
        const lenSq = C * C + D * D;
        let param = -1;
        
        if (lenSq !== 0) param = dot / lenSq;
        
        let xx, yy;
        if (param < 0) {
          xx = x1;
          yy = y1;
        } else if (param > 1) {
          xx = x2;
          yy = y2;
        } else {
          xx = x1 + param * C;
          yy = y1 + param * D;
        }
        
        const dx = x - xx;
        const dy = y - yy;
        return Math.sqrt(dx * dx + dy * dy);
      }
      
      function douglasPeucker(points, start, end, tolerance, result) {
        if (end <= start + 1) return;
        
        let maxDistance = 0;
        let index = start;
        
        for (let i = start + 1; i < end; i++) {
          const distance = perpendicularDistance(points[i], points[start], points[end]);
          if (distance > maxDistance) {
            index = i;
            maxDistance = distance;
          }
        }
        
        if (maxDistance > tolerance) {
          douglasPeucker(points, start, index, tolerance, result);
          result.push(points[index]);
          douglasPeucker(points, index, end, tolerance, result);
        }
      }
      
      const result = [points[0]];
      douglasPeucker(points, 0, points.length - 1, tolerance, result);
      result.push(points[points.length - 1]);
      
      return result;
    }
    
    /**
     * Adaptive path simplification based on map size
     * @param {Array} lines - Array of polylines
     * @param {number} width - Map width
     * @param {number} height - Map height
     * @returns {Array} Simplified polylines
     */
    function adaptiveSimplify(lines, width, height) {
      const tol = Math.max(0.2, Math.min(1.5, Math.sqrt(width * height) / 1800));
      return lines.map(L => simplifyPath(L, tol));
    }

    // Dirty flags for incremental updates
    const RouteDirty = {
      burgs: true,
      landGraph: true,
      sea: true
    };

    // Regeneration flags for seed-only changes
    const RegenerationFlags = {
      needsRegenerate: false,
      needsRecolor: false,
      
      setNeedsRegenerate() {
        this.needsRegenerate = true;
        this.needsRecolor = true;
      },
      
      setNeedsRecolor() {
        this.needsRecolor = true;
      },
      
      clear() {
        this.needsRegenerate = false;
        this.needsRecolor = false;
      }
    };

    // Progress management system
    const ProgressManager = {
      overlay: null,
      fill: null,
      text: null,
      detail: null,
      isVisible: false,
      
      init() {
        this.overlay = document.getElementById('progressOverlay');
        this.fill = document.getElementById('progressFill');
        this.text = document.getElementById('progressText');
        this.detail = document.getElementById('progressDetail');
        
        // Debug logging
        console.log('ProgressManager.init() called');
        console.log('overlay:', this.overlay);
        console.log('fill:', this.fill);
        console.log('text:', this.text);
        console.log('detail:', this.detail);
      },
      
      show() {
        console.log('ProgressManager.show() called');
        if (this.overlay) {
          this.overlay.style.display = 'flex';
          this.isVisible = true;
          console.log('Progress overlay shown');
          
          // Force a repaint to ensure visibility
          this.overlay.offsetHeight;
        } else {
          console.log('Progress overlay not found!');
        }
      },
      
      hide() {
        console.log('ProgressManager.hide() called');
        if (this.overlay) {
          this.overlay.style.display = 'none';
          this.isVisible = false;
          console.log('Progress overlay hidden');
        }
      },
      
      update(percent, text, detail = '') {
        // Ensure overlay is visible before updating
        if (!this.isVisible) {
          this.show();
        }
        
        if (this.fill) {
          this.fill.style.width = `${Math.min(100, Math.max(0, percent))}%`;
        }
        if (this.text) {
          this.text.textContent = text;
        }
        if (this.detail) {
          this.detail.textContent = detail;
        }
        console.log(`Progress update: ${percent}% - ${text}`);
        
        // Force a repaint to ensure updates are visible
        if (this.overlay) {
          this.overlay.offsetHeight;
        }
      },
      
      setPhase(phase, percent) {
        const phases = {
          'init': { text: 'Initializing map generation...', percent: 5 },
          'voronoi': { text: 'Building Voronoi diagram...', percent: 15 },
          'terrain': { text: 'Generating terrain...', percent: 30 },
          'erosion': { text: 'Applying erosion...', percent: 45 },
          'rivers': { text: 'Computing rivers...', percent: 60 },
          'coastlines': { text: 'Drawing coastlines...', percent: 70 },
          'burgs': { text: 'Placing settlements...', percent: 80 },
          'routes': { text: 'Building routes...', percent: 90 },
          'final': { text: 'Finalizing...', percent: 95 }
        };
        
        const phaseInfo = phases[phase] || { text: phase, percent: percent || 50 };
        this.update(phaseInfo.percent, phaseInfo.text);
      }
    };

  (function () {
    'use strict';

      // Initialize progress manager after DOM is ready
      document.addEventListener('DOMContentLoaded', () => {
        ProgressManager.init();
      });
      
      // Also try to init immediately in case DOM is already loaded
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
          ProgressManager.init();
        });
      } else {
        ProgressManager.init();
      }

    // Define constants up-front so they're available when generate() first runs
    const WATER_COLOR = d3.interpolateBlues(0.55); // single water color (less busy)

    // Expose generate() globally for the button
    window.generate = generate;
    
    /**
     * Fast toggle for route visibility without recomputation
     * @param {string} routeType - Type of route ('roads', 'trails', 'searoutes')
     * @param {boolean} visible - Whether to show or hide
     */
    function toggleRoutes(routeType, visible) {
      const selector = `#routes .${routeType}`;
      const group = d3.select(selector);
      if (group.size() > 0) {
        group.style('display', visible ? null : 'none');
      }
      
      // Only recompute if density/slope settings changed
      // For now, just do fast toggle - can be enhanced later
    }

    // State we expose for tests/debugging
    window.__state = { cells: null, delaunay: null, voronoi: null, svg: null, add: null, recolor: null, autoSeed: null, drawCoastlines: null, applyBorder: null, borderPx: 0, generate: generate, burgs: [] };

    // Export functions (will be defined later)
    window.saveSVG = null;
    window.savePNG = null;

    // Burg data model and generation constants
    const BURG_TYPES = {
      hamlet: { radius: 1.5, population: 100 },
      town: { radius: 2.5, population: 1000 },
      city: { radius: 3.5, population: 10000 },
      capital: { radius: 4.5, population: 50000 },
      port: { radius: 2.5, population: 2000 }
    };

    // Simple name generation (placeholder - can be enhanced with culture-based names)
    const BURG_NAMES = [
      'Riverton', 'Harborview', 'Stonebridge', 'Greenfield', 'Ironforge',
      'Silverport', 'Goldcrest', 'Blackwood', 'Whitecliff', 'Redhaven',
      'Bluewater', 'Fairview', 'Highland', 'Lowland', 'Midtown',
      'Northport', 'Southgate', 'Eastside', 'Westend', 'Central'
    ];

    // initialize outputs to match inputs
    sizeOutput.value = sizeInput.valueAsNumber;
    highOutput.value = highInput.valueAsNumber;
    radiusOutput.value = radiusInput.valueAsNumber;
    sharpnessOutput.value = sharpnessInput.valueAsNumber;
    seaLevelOutput.value = seaLevelInput.valueAsNumber;
    smallCountOutput.value = smallCountInput.valueAsNumber;
    borderPctOutput.value = borderPctInput.valueAsNumber;
    minLakeSizeOutput.value = minLakeSizeInput.valueAsNumber;
    minLakeDepthOutput.value = minLakeDepthInput.valueAsNumber;
    baseTempOutput.value = baseTempInput.valueAsNumber;
    precipScaleOutput.value = precipScaleInput.valueAsNumber;
    riverWidthOutput.value = riverWidthInput.valueAsNumber;
    talusOutput.value = talusInput.valueAsNumber;
    thermalStrengthOutput.value = thermalStrengthInput.valueAsNumber;
    smoothAlphaOutput.value = smoothAlphaInput.valueAsNumber;
    burgsCountOutput.value = burgsCountInput.valueAsNumber;
    burgSpacingOutput.value = burgSpacingInput.valueAsNumber;
    riverWeightOutput.value = riverWeightInput.valueAsNumber;
    coastWeightOutput.value = coastWeightInput.valueAsNumber;
    flatnessWeightOutput.value = flatnessWeightInput.valueAsNumber;
    fertilityWeightOutput.value = fertilityWeightInput.valueAsNumber;
    roadDensityOutput.value = roadDensityInput.valueAsNumber;
    trailDensityOutput.value = trailDensityInput.valueAsNumber;
    slopePenaltyOutput.value = slopePenaltyInput.valueAsNumber;
    riverPenaltyOutput.value = riverPenaltyInput.valueAsNumber;

    generate();

    function generate() {
      // Ensure progress manager is initialized
      if (!ProgressManager.overlay) {
        ProgressManager.init();
      }
      
      // Show progress overlay
      ProgressManager.show();
      ProgressManager.setPhase('init');
      
      d3.select('.mapCells').remove();
      d3.select('.coastline').remove();
      d3.select('#burgs').remove();
      d3.select('#routes').remove();
      
      // Clear burgs from state
      window.__state.burgs = [];

      const svg = d3.select('svg');
      // Solid ocean backdrop to eliminate water seam artifacts (anti-aliasing between polygons)
      svg.select('rect.ocean').remove();
      svg.append('rect')
        .attr('class','ocean')
        .attr('x',0).attr('y',0)
        .attr('width', +svg.attr('width'))
        .attr('height', +svg.attr('height'))
        .attr('fill', WATER_COLOR);
      const mapCells = svg.append('g')
        .attr('class', 'mapCells');
      const riversShade = svg.append('g').attr('class', 'riversShade');
      const riversG = svg.append('g').attr('class', 'rivers');
      const coastG = svg.append('g').attr('class', 'coastline');
      const burgsG = svg.append('g').attr('id', 'burgs');
      const routesG = svg.append('g').attr('id', 'routes');
      const roadsG = routesG.append('g').attr('class', 'roads');
      const trailsG = routesG.append('g').attr('class', 'trails');
      const seaG = routesG.append('g').attr('class', 'searoutes');

      const width = +svg.attr('width');
      const height = +svg.attr('height');
      const n = sizeInput.valueAsNumber;

      // initial random points
      let sites = d3.range(n).map(() => [Math.random() * width, Math.random() * height]);

      // One Lloyd relaxation step for nicer spacing
      ({ sites } = relaxOnce(sites, width, height));

      // Build Delaunay + Voronoi structures
      ProgressManager.setPhase('voronoi');
      const delaunay = d3.Delaunay.from(sites);
      const voronoi = delaunay.voronoi([0, 0, width, height]);

      // Build cell objects with neighbors
      const cells = d3.range(n).map((i) => ({
        index: i,
        poly: voronoi.cellPolygon(i),
        neighbors: Array.from(delaunay.neighbors(i)),
        high: 0,
        used: 0
      }));

      // Precompute polygon centroids for border mask filtering
      cells.forEach(c => { const ct = d3.polygonCentroid(c.poly); c.cx = ct[0]; c.cy = ct[1]; });

      // Palette (kept for future tweaks)
      const interp = { water: (t) => d3.interpolateBlues(t) };

      // Land color ramp: green lowlands → tan → white peaks
      function landColor(t) {
        // t in [0,1], already normalized above sea level
        t = Math.max(0, Math.min(1, t));
        if (t < 0.35) {
          const u = t / 0.35; // 0..1
          return d3.interpolateYlGn(0.3 + 0.7 * u); // brighter coastal greens
        } else if (t < 0.7) {
          const u = (t - 0.35) / 0.35; // 0..1
          return d3.interpolateYlOrBr(0.25 + 0.75 * u); // foothills to tan
        } else if (t < 0.9) {
          const u = (t - 0.7) / 0.2; // 0..1
          return d3.interpolateOranges(0.4 + 0.6 * u); // warm rocky highlands
        } else {
          const u = (t - 0.9) / 0.1; // 0..1
          return d3.interpolateRgb('#e9ecef', '#ffffff')(u); // light grey → white snowcap
        }
      }

      // Draw polygons - use canvas for large maps, SVG for smaller ones
      const useCanvas = cells.length > 8000;
      
      if (useCanvas) {
        // Canvas-based rendering for large maps
        TerrainCanvas.canvas.width = width;
        TerrainCanvas.canvas.height = height;
        TerrainCanvas.ctx.fillStyle = '#000';
        
        cells.forEach(cell => {
          if (cell.poly.length > 2) {
            TerrainCanvas.ctx.beginPath();
            TerrainCanvas.ctx.moveTo(cell.poly[0][0], cell.poly[0][1]);
            for (let i = 1; i < cell.poly.length; i++) {
              TerrainCanvas.ctx.lineTo(cell.poly[i][0], cell.poly[i][1]);
            }
            TerrainCanvas.ctx.closePath();
            TerrainCanvas.ctx.fill();
          }
        });
        
        // Add canvas as image to SVG
        const dataURL = TerrainCanvas.canvas.toDataURL();
        mapCells.append('image')
          .attr('href', dataURL)
          .attr('width', width)
          .attr('height', height)
          .attr('x', 0)
          .attr('y', 0);
      } else {
        // SVG-based rendering for smaller maps
      mapCells.selectAll('path.mapCell')
        .data(cells)
        .enter()
        .append('path')
        .attr('class', 'mapCell')
        .attr('id', d => d.index)
        .attr('d', d => 'M' + d.poly.map(p => p.join(',')).join('L') + 'Z')
        .attr('fill', '#000')
        .attr('fill-rule', 'nonzero');
      }

      // Keep shared state for tests and other functions
      window.__state.cells = cells;
      window.__state.delaunay = delaunay;
      window.__state.voronoi = voronoi;
      window.__state.svg = svg;
      window.__state.add = add;
      window.__state.recolor = rafDebounce(recolor);
      window.__state.autoSeed = autoSeed;
      window.__state.drawCoastlines = drawCoastlines;
      window.__state.applyBorder = applyBorderMask;
      window.__state.computeRivers = computeRivers;
      window.__state.generateBurgs = generateBurgs;
      window.__state.renderBurgs = renderBurgs;
      window.__state.computeRoutes = computeRoutes;

          // Initialize reusable typed arrays for performance
    window.__state.tmp = {
      dist: new Int32Array(cells.length),
      down: new Int32Array(cells.length),
      flux: new Float32Array(cells.length),
    };

    // Typed array pool for reuse across runs
    const ArrayPool = {
      float32: [],
      int32: [],
      uint32: [],
      
      getFloat32(size) {
        const pool = this.float32.filter(arr => arr.length >= size);
        if (pool.length > 0) {
          const arr = pool.pop();
          arr.fill(0);
          return arr;
        }
        return new Float32Array(size);
      },
      
      getInt32(size) {
        const pool = this.int32.filter(arr => arr.length >= size);
        if (pool.length > 0) {
          const arr = pool.pop();
          arr.fill(0);
          return arr;
        }
        return new Int32Array(size);
      },
      
      getUint32(size) {
        const pool = this.uint32.filter(arr => arr.length >= size);
        if (pool.length > 0) {
          const arr = pool.pop();
          arr.fill(0);
          return arr;
        }
        return new Uint32Array(size);
      },
      
      returnFloat32(arr) {
        this.float32.push(arr);
      },
      
      returnInt32(arr) {
        this.int32.push(arr);
      },
      
      returnUint32(arr) {
        this.uint32.push(arr);
      }
    };

      // Auto-generate: center island + N small hills
      ProgressManager.setPhase('terrain');
      autoSeed();
      // Apply the water-border mask (keeps edges water)
      applyBorderMask();
      
      // Erosion passes: smooth jaggy ridges and improve drainage
      ProgressManager.setPhase('erosion');
      const talus = +document.getElementById('talusInput').value || 0.02;
      const thermalStrength = +document.getElementById('thermalStrengthInput').value || 0.5;
      const smoothAlpha = +document.getElementById('smoothAlphaInput').value || 0.2;
      thermalErode(talus, thermalStrength, 2);
      smoothLand(smoothAlpha);
      
      // Mark terrain as dirty for canvas rendering
      TerrainCanvas.setDirty();
      
      // initial recolor according to current UI (also draws coastlines)
      ProgressManager.setPhase('rivers');
      recolor();
      
      // Hide progress overlay when complete
      ProgressManager.setPhase('final');
      setTimeout(() => {
        ProgressManager.hide();
      }, 1000); // Increased delay to 1 second so you can see the completion

      function relaxOnce(pts, w, h) {
        const dly = d3.Delaunay.from(pts);
        const vor = dly.voronoi([0, 0, w, h]);
        const relaxed = pts.map((_, i) => d3.polygonCentroid(vor.cellPolygon(i)));
        return { sites: relaxed };
      }

      function addWithOpts(start, type, opts) {
        // temporarily override sliders
        const prev = {
          high: +highInput.value,
          rad: +radiusInput.value,
          sharp: +sharpnessInput.value
        };
        if (opts && typeof opts.high === 'number') { highInput.value = opts.high; highOutput.value = opts.high; }
        if (opts && typeof opts.radius === 'number') { radiusInput.value = opts.radius; radiusOutput.value = opts.radius; }
        if (opts && typeof opts.sharpness === 'number') { sharpnessInput.value = opts.sharpness; sharpnessOutput.value = opts.sharpness; }
        add(start, type);
        // restore sliders
        highInput.value = prev.high; highOutput.value = prev.high;
        radiusInput.value = prev.rad; radiusOutput.value = prev.rad;
        sharpnessInput.value = prev.sharp; sharpnessOutput.value = prev.sharp;
      }

      function pickInteriorCell(marginPx) {
        // choose a cell whose centroid is at least marginPx from any edge
        const interior = cells.filter(c => Math.min(c.cx, c.cy, width - c.cx, height - c.cy) >= marginPx);
        if (interior.length === 0) return Math.floor(Math.random() * cells.length);
        const idx = Math.floor(Math.random() * interior.length);
        return interior[idx].index;
      }

      function autoSeed() {
        const worldType = document.getElementById('worldType').value;
        const N = +smallCountInput.value;
        const marginPx = Math.max(2, (+borderPctInput.value) / 100 * Math.min(width, height));
        
        if (worldType === 'island') {
          // Original single island generation
          let centerIndex = delaunay.find(width / 2, height / 2);
          if (Math.min(cells[centerIndex].cx, cells[centerIndex].cy, width - cells[centerIndex].cx, height - cells[centerIndex].cy) < marginPx) {
            centerIndex = pickInteriorCell(marginPx);
          }
          addWithOpts(centerIndex, 'island', { high: 0.9, radius: 0.94, sharpness: 0.2 });
          // N small smooth hills at interior random cells
          for (let i = 0; i < N; i++) {
            const idx = pickInteriorCell(marginPx);
            addWithOpts(idx, 'hill', { high: 0.3, radius: 0.985, sharpness: 0.1 });
          }
        } else if (worldType === 'continents') {
          generateContinents(marginPx);
        }
      }
      
      function generateContinents(marginPx) {
        // Based on Azgaar's continent template
        const centerX = width / 2, centerY = height / 2;
        
        // 1. Place main mountain (central high point)
        let centerIndex = delaunay.find(centerX, centerY);
        if (Math.min(cells[centerIndex].cx, cells[centerIndex].cy, width - cells[centerIndex].cx, height - cells[centerIndex].cy) < marginPx) {
          centerIndex = pickInteriorCell(marginPx);
        }
        addWithOpts(centerIndex, 'island', { high: 0.8, radius: 0.92, sharpness: 0.2 });
        
        // 2. Add 24 hills with distribution 0.25 (spread out)
        for (let i = 0; i < 24; i++) {
          const idx = pickInteriorCell(marginPx);
          addWithOpts(idx, 'hill', { high: 0.4, radius: 0.97, sharpness: 0.15 });
        }
        
        // 3. Add 2 mountain ranges (east-west and north-south)
        const range1Start = delaunay.find(centerX * 0.3, centerY);
        const range1End = delaunay.find(centerX * 1.7, centerY);
        addMountainRange(range1Start, range1End, 0.7, 0.3);
        
        const range2Start = delaunay.find(centerX, centerY * 0.4);
        const range2End = delaunay.find(centerX, centerY * 1.6);
        addMountainRange(range2Start, range2End, 0.6, 0.25);
        
        // 4. Add 3 hills with distribution 0.1 (near edges)
        for (let i = 0; i < 3; i++) {
          const idx = pickInteriorCell(marginPx * 0.5);
          addWithOpts(idx, 'hill', { high: 0.3, radius: 0.98, sharpness: 0.1 });
        }
        
        // 5. Multiply land cells by 0.7 (reduce overall elevation)
        cells.forEach(c => {
          if (c.high > 0.1) {
            c.high = 0.1 + (c.high - 0.1) * 0.7;
          }
        });
        
        // 6. Add strait (vertical depression to separate continents)
        addStrait(centerX, centerY * 0.3, centerY * 1.7, 3);
        
        // 7. Smooth the map
        smoothMap();
        
        // 8. Add 5 pits (inland depressions)
        for (let i = 0; i < 5; i++) {
          const idx = pickInteriorCell(marginPx);
          addPit(idx, 0.3, 0.4);
        }
        
        // 9. Add 3 troughs (elongated depressions)
        for (let i = 0; i < 3; i++) {
          const startIdx = pickInteriorCell(marginPx);
          const endIdx = pickInteriorCell(marginPx);
          addTrough(startIdx, endIdx, 0.2, 0.3);
        }
        
        // 10. Multiply land cells by 0.8 (further reduce elevation)
        cells.forEach(c => {
          if (c.high > 0.1) {
            c.high = 0.1 + (c.high - 0.1) * 0.8;
          }
        });
        
        // 11. Add 0.02 to all cells (slight elevation boost)
        cells.forEach(c => {
          c.high = Math.min(1.0, c.high + 0.02);
        });
      }
      
      function addMountainRange(startIdx, endIdx, maxHeight, radius) {
        const start = cells[startIdx];
        const end = cells[endIdx];
        const steps = 12;
        
        for (let i = 0; i <= steps; i++) {
          const t = i / steps;
          const x = start.cx + (end.cx - start.cx) * t;
          const y = start.cy + (end.cy - start.cy) * t;
          const targetIdx = delaunay.find(x, y);
          addWithOpts(targetIdx, 'hill', { high: maxHeight * (1 - Math.abs(t - 0.5) * 0.4), radius: radius, sharpness: 0.15 });
        }
      }
      
      function addStrait(centerX, startY, endY, width) {
        const steps = 20;
        for (let i = 0; i <= steps; i++) {
          const t = i / steps;
          const y = startY + (endY - startY) * t;
          const x = centerX + (Math.random() - 0.5) * width * 20; // Add some randomness
          const targetIdx = delaunay.find(x, y);
          if (targetIdx >= 0 && targetIdx < cells.length) {
            cells[targetIdx].high = Math.max(0.05, cells[targetIdx].high - 0.4);
          }
        }
      }
      
      function addPit(centerIdx, depth, radius) {
        const center = cells[centerIdx];
        const queue = [];
        cells[centerIdx].high = Math.max(0.05, cells[centerIdx].high - depth);
        queue.push(centerIdx);
        
        for (let i = 0; i < queue.length && depth > 0.01; i++) {
          depth = depth * radius;
          cells[queue[i]].neighbors.forEach((e) => {
            if (!cells[e].used) {
              cells[e].high = Math.max(0.05, cells[e].high - depth);
              cells[e].used = 1;
              queue.push(e);
            }
          });
        }
        cells.forEach(c => c.used = 0);
      }
      
      function addTrough(startIdx, endIdx, depth, radius) {
        const start = cells[startIdx];
        const end = cells[endIdx];
        const steps = 8;
        
        for (let i = 0; i <= steps; i++) {
          const t = i / steps;
          const x = start.cx + (end.cx - start.cx) * t;
          const y = start.cy + (end.cy - start.cy) * t;
          const targetIdx = delaunay.find(x, y);
          if (targetIdx >= 0 && targetIdx < cells.length) {
            cells[targetIdx].high = Math.max(0.05, cells[targetIdx].high - depth);
          }
        }
      }
      
      function smoothMap() {
        const smoothed = new Float32Array(cells.length);
        cells.forEach((c, i) => {
          let sum = c.high;
          let count = 1;
          c.neighbors.forEach(nb => {
            sum += cells[nb].high;
            count++;
          });
          smoothed[i] = sum / count;
        });
        cells.forEach((c, i) => {
          c.high = smoothed[i];
        });
      }

      // Erosion functions for terrain smoothing
      function isLand(i) {
        return cells[i].high > 0.1; // Sea level threshold
      }

      function thermalErode(talus = 0.02, k = 0.5, iters = 2) {
        const n = cells.length;
        for (let t = 0; t < iters; t++) {
          const delta = new Float32Array(n);
          for (let i = 0; i < n; i++) {
            const hi = cells[i].high;
            if (!isLand(i)) continue;
            for (const j of cells[i].neighbors) {
              const d = hi - cells[j].high - talus;
              if (d > 0) {
                const m = k * d * 0.5;
                delta[i] -= m;
                delta[j] += m;
              }
            }
          }
          for (let i = 0; i < n; i++) {
            cells[i].high = Math.max(0, cells[i].high + delta[i]);
          }
        }
      }

      function smoothLand(alpha = 0.2) {
        const n = cells.length;
        const out = new Float32Array(n);
        for (let i = 0; i < n; i++) {
          if (!isLand(i)) {
            out[i] = cells[i].high;
            continue;
          }
          let s = 0;
          for (const j of cells[i].neighbors) {
            s += cells[j].high;
          }
          out[i] = (1 - alpha) * cells[i].high + alpha * (s / cells[i].neighbors.length);
        }
        cells.forEach((c, i) => {
          c.high = out[i];
        });
      }

      // Expose autoSeed to window for tests
      window.autoSeed = autoSeed;

      function add(start, type) {
        // get options from sliders
        let high = +highInput.value;
        const radius = +radiusInput.value;
        const sharpness = +sharpnessInput.value;
        const queue = [];

        cells[start].high += high;
        cells[start].used = 1;
        queue.push(start);

        for (let i = 0; i < queue.length && high > 0.01; i++) {
          if (type === 'island') {
            high = cells[queue[i]].high * radius;
          } else {
            high = high * radius;
          }
          cells[queue[i]].neighbors.forEach((e) => {
            if (!cells[e].used) {
              let mod = Math.random() * sharpness + 1.1 - sharpness;
              if (sharpness === 0) mod = 1;
              cells[e].high += high * mod;
              if (cells[e].high > 1) cells[e].high = 1;
              cells[e].used = 1;
              queue.push(e);
            }
          });
        }
        // reset used flags
        cells.forEach(c => c.used = 0);
      }

      function applyBorderMask() {
        const pct = (+borderPctInput.value) / 100;
        const marginPx = Math.max(2, pct * Math.min(width, height));
        window.__state.borderPx = marginPx;
        // Smoothstep helper
        const clamp01 = (v) => v < 0 ? 0 : v > 1 ? 1 : v;
        const smooth = (v) => { v = clamp01(v); return v * v * (3 - 2 * v); };
        cells.forEach(c => {
          const distEdge = Math.min(c.cx, c.cy, width - c.cx, height - c.cy);
          const mask = smooth(distEdge / marginPx);
          c.high *= mask; // damp heights near the border to guarantee water frame
        });
      }

      // --- Lakes & basins (depression detection + spill level) ---
      function computeLakes(sea) {
        const N = cells.length;
        const isLake = new Uint8Array(N);
        const lakeId = new Int32Array(N); lakeId.fill(-1);
        const downSteep = new Int32Array(N); downSteep.fill(-1);
        const up = Array.from({length: N}, () => []);
        const landIdxs = [];
        for (let i = 0; i < N; i++) {
          if (cells[i].high >= sea) {
            landIdxs.push(i);
            let bestH = cells[i].high, best = -1;
            const nbs = cells[i].neighbors;
            for (let k = 0; k < nbs.length; k++) {
              const nb = nbs[k];
              const hh = cells[nb].high;
              if (hh < bestH) { bestH = hh; best = nb; }
            }
            if (best !== -1) { downSteep[i] = best; up[best].push(i); }
          }
        }
        const visited = new Uint8Array(N);
        const lakes = [];
        for (let sIdx = 0; sIdx < landIdxs.length; sIdx++) {
          const s = landIdxs[sIdx];
          if (visited[s] || downSteep[s] !== -1) continue; // only sinks
          // collect basin by traversing upstream graph
          const basin = []; const stack = [s]; visited[s] = 1; const basinSet = new Set();
          while (stack.length) {
            const v = stack.pop();
            basin.push(v); basinSet.add(v);
            const ups = up[v] || [];
            for (let t = 0; t < ups.length; t++) { const u = ups[t]; if (!visited[u]) { visited[u] = 1; stack.push(u); } }
          }
          // compute spill (lowest outside neighbor)
          let spill = Infinity; let outlet = -1;
          for (let bi = 0; bi < basin.length; bi++) {
            const b = basin[bi];
            const nbs = cells[b].neighbors;
            for (let k = 0; k < nbs.length; k++) {
              const nb = nbs[k];
              if (!basinSet.has(nb)) {
                const hnb = cells[nb].high;
                if (hnb < spill) { spill = hnb; outlet = nb; }
              }
            }
          }
          if (spill > sea && spill < Infinity) {
            let lakeCells = 0; const id = lakes.length;
            let maxDepth = 0;
            
            // Count cells that would be underwater and find max depth
            for (let bi = 0; bi < basin.length; bi++) {
              const b = basin[bi];
              if (cells[b].high < spill) { 
                lakeCells++; 
                const depth = spill - cells[b].high;
                maxDepth = Math.max(maxDepth, depth);
              }
            }
            
            // Only create lakes that are significant in size and depth
            const minLakeCells = +document.getElementById('minLakeSizeInput').value || 3;
            const minLakeDepth = +document.getElementById('minLakeDepthInput').value || 0.05;
            
            if (lakeCells >= minLakeCells && maxDepth >= minLakeDepth) {
              for (let bi = 0; bi < basin.length; bi++) {
                const b = basin[bi];
                if (cells[b].high < spill) { isLake[b] = 1; lakeId[b] = id; }
              }
              lakes.push({ id, level: spill, outlet, size: lakeCells, depth: maxDepth });
            }
          }
        }
        const isWater = cells.map((c, i) => (c.high < sea) || (isLake[i] === 1));
        window.__state.isLake = isLake;
        window.__state.lakeId = lakeId;
        window.__state.lakes = lakes;
        window.__state.isWater = isWater;
        return { isLake, lakeId, lakes, isWater };
      }

      function recolor() {
        const sea = +document.getElementById('seaLevelInput').value;
        const renderMode = document.getElementById('renderMode').value;
        const shadingMode = document.getElementById('shadingMode').value;
        
        // recompute lakes with current sea level and expose water mask
        computeLakes(sea);
        const isWater = window.__state.isWater || [];
        
        // Compute climate and biomes if needed
        if (renderMode === 'biomes' || renderMode === 'hybrid') {
          computeClimate(sea);
        }
        
        // Compute shading if enabled
        const shades = shadingMode === 'shaded' ? computeShading(cells, sea) : null;
        
        // Check if we're using canvas rendering
        const useCanvas = cells.length > 8000;
        
        if (useCanvas && TerrainCanvas.isDirty()) {
          // Re-render canvas for large maps
          TerrainCanvas.canvas.width = width;
          TerrainCanvas.canvas.height = height;
          
          cells.forEach(cell => {
            if (isWater[cell.index]) {
              // Skip water cells - they're handled by ocean backdrop
              return;
            }
            
            let baseColor;
            if (renderMode === 'biomes' || renderMode === 'hybrid') {
              baseColor = getBiomeColor(cell.biome, cell.high, sea);
            } else {
              const tl = (cell.high - sea) / Math.max(1 - sea, 0.0001);
              const tt = Math.max(0, Math.min(1, tl));
              baseColor = landColor(tt);
            }
            
            if (shadingMode === 'shaded' && shades) {
              baseColor = shadeColor(baseColor, shades[cell.index]);
            }
            
            // Draw cell on canvas
            TerrainCanvas.ctx.fillStyle = baseColor;
            if (cell.poly.length > 2) {
              TerrainCanvas.ctx.beginPath();
              TerrainCanvas.ctx.moveTo(cell.poly[0][0], cell.poly[0][1]);
              for (let i = 1; i < cell.poly.length; i++) {
                TerrainCanvas.ctx.lineTo(cell.poly[i][0], cell.poly[i][1]);
              }
              TerrainCanvas.ctx.closePath();
              TerrainCanvas.ctx.fill();
            }
          });
          
          // Update canvas image in SVG
          const dataURL = TerrainCanvas.canvas.toDataURL();
          mapCells.select('image').attr('href', dataURL);
          TerrainCanvas.markClean();
        } else if (!useCanvas) {
          // SVG-based rendering for smaller maps
        mapCells.selectAll('path.mapCell')
          .attr('fill', d => {
            if (isWater[d.index]) {
              return 'none';
            } else {
              let baseColor;
              if (renderMode === 'biomes' || renderMode === 'hybrid') {
                baseColor = getBiomeColor(d.biome, d.high, sea);
              } else {
                const tl = (d.high - sea) / Math.max(1 - sea, 0.0001);
                const tt = Math.max(0, Math.min(1, tl));
                baseColor = landColor(tt);
              }
              
              if (shadingMode === 'shaded' && shades) {
                return shadeColor(baseColor, shades[d.index]);
              } else {
                return baseColor;
              }
            }
          })
          .style('fill', d => {
            if (isWater[d.index]) {
              return 'none';
            } else {
              let baseColor;
              if (renderMode === 'biomes' || renderMode === 'hybrid') {
                baseColor = getBiomeColor(d.biome, d.high, sea);
              } else {
                const tl = (d.high - sea) / Math.max(1 - sea, 0.0001);
                const tt = Math.max(0, Math.min(1, tl));
                baseColor = landColor(tt);
              }
              
              if (shadingMode === 'shaded' && shades) {
                return shadeColor(baseColor, shades[d.index]);
              } else {
                return baseColor;
              }
            }
          });
        }
        
        // Update progress for each phase with detailed progress
        ProgressManager.setPhase('rivers');
        ProgressManager.update(60, 'Computing rivers...', 'Building river network...');
        
        // Small delay to ensure progress is visible
        setTimeout(() => {
        computeRivers();
          
          ProgressManager.setPhase('coastlines');
          ProgressManager.update(70, 'Drawing coastlines...', 'Processing coastline edges...');
          
          setTimeout(() => {
        drawCoastlines();
            
            ProgressManager.setPhase('burgs');
            ProgressManager.update(80, 'Placing settlements...', 'Scoring and placing burgs...');
            
            setTimeout(() => {
              generateBurgs();
              
              ProgressManager.setPhase('routes');
              ProgressManager.update(90, 'Building routes...', 'Computing road and sea networks...');
              
              setTimeout(() => {
                computeRoutes();
              }, 100);
            }, 100);
          }, 100);
        }, 100);
        
        // Update the biome legend
        updateBiomeLegend();
      }

      // --- Shaded Relief and Hypsometric Tinting ---
      function estimateNormal(i, cells, H) {
        // simple gradient from neighbors
        let dx = 0, dy = 0;
        const ci = cells[i];
        for (const j of ci.neighbors) {
          const cj = cells[j];
          const dh = H[j] - H[i];
          dx += dh * (cj.cx - ci.cx);
          dy += dh * (cj.cy - ci.cy);
        }
        // normal pointing "up": N ≈ normalize([-dx, -dy, scale])
        const scale = 1.0; // simplified scale
        let nx = -dx, ny = -dy, nz = scale;
        const len = Math.hypot(nx, ny, nz);
        return [nx / len, ny / len, nz / len];
      }

      function shadeColor(color, shade) {
        let r, g, b;
        
        if (color.startsWith('rgb(')) {
          // Parse rgb(r, g, b) format
          const rgbMatch = color.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
          if (rgbMatch) {
            r = parseInt(rgbMatch[1]);
            g = parseInt(rgbMatch[2]);
            b = parseInt(rgbMatch[3]);
          } else {
            return color; // fallback if parsing fails
          }
        } else if (color.startsWith('#')) {
          // Parse hex format
          const hex = color.replace('#', '');
          r = parseInt(hex.substr(0, 2), 16);
          g = parseInt(hex.substr(2, 2), 16);
          b = parseInt(hex.substr(4, 2), 16);
        } else {
          return color; // fallback for unknown formats
        }
        
        const shadedR = Math.round(r * shade);
        const shadedG = Math.round(g * shade);
        const shadedB = Math.round(b * shade);
        
        return `rgb(${shadedR}, ${shadedG}, ${shadedB})`;
      }

      function computeShading(cells, sea) {
        const lightDir = [-0.5, -0.5, 1]; // Light direction
        const lightLen = Math.hypot(lightDir[0], lightDir[1], lightDir[2]);
        const normalizedLight = lightDir.map(v => v / lightLen);
        
        const H = cells.map(c => c.high);
        const shades = new Float32Array(cells.length);
        
        for (let i = 0; i < cells.length; i++) {
          if (cells[i].high >= sea) {
            // Only shade land cells
            const normal = estimateNormal(i, cells, H);
            const dot = normal[0] * normalizedLight[0] + 
                       normal[1] * normalizedLight[1] + 
                       normal[2] * normalizedLight[2];
            shades[i] = Math.max(0.25, dot); // 0.25 = ambient
          } else {
            shades[i] = 1.0; // No shading for water
          }
        }
        
        return shades;
      }

      // --- Export Functions ---
      function getUsedIds(svg) {
        const used = new Set();
        const ATTRS = [
          'fill', 'stroke', 'filter', 'clip-path', 'mask',
          'marker-start', 'marker-mid', 'marker-end', 'href', 'xlink:href'
        ];
        svg.querySelectorAll('*').forEach(el => {
          for (const a of ATTRS) {
            const v = el.getAttribute(a);
            if (!v) continue;
            // url(#id) or href="#id"
            const m1 = v.match(/url\(#([^)]+)\)/);
            if (m1) used.add(m1[1]);
            const m2 = v.match(/^#(.+)/);
            if (m2) used.add(m2[1]);
          }
        });
        return used;
      }

      function pruneDefs(defs, used) {
        defs.querySelectorAll('[id]').forEach(node => {
          if (!used.has(node.id)) node.remove();
        });
      }

      function ensureBackgroundOcean(svg, color) {
        // Remove any prior injected bg
        svg.querySelector('#_export_bg')?.remove();

        const vb = svg.viewBox && svg.viewBox.baseVal;
        const w = svg.getAttribute('width') || (vb ? vb.width : null);
        const h = svg.getAttribute('height') || (vb ? vb.height : null);
        if (!w || !h) return; // set width/height/viewBox upstream as you already do

        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        rect.setAttribute('id', '_export_bg');
        rect.setAttribute('x', '0');
        rect.setAttribute('y', '0');
        rect.setAttribute('width', w);
        rect.setAttribute('height', h);
        rect.setAttribute('fill', color);

        // Insert behind everything, but after <defs> if present
        const firstRenderable = [...svg.childNodes].find(n => n.nodeType === 1 && n.tagName !== 'defs');
        if (firstRenderable) svg.insertBefore(rect, firstRenderable);
        else svg.appendChild(rect);
      }

      function inlineSvgStyles(svg, preservePatterns = false) {
        const all = svg.querySelectorAll('*');

        for (const el of all) {
          const cs = getComputedStyle(el);

          const setPaint = (prop, attr) => {
            // Never overwrite explicit fill/stroke attributes that are already set
            if ((attr === 'fill' || attr === 'stroke') && el.hasAttribute(attr)) {
              return;
            }
            
            let v = cs[prop];

            // Preserve patterns for SVG export
            if (preservePatterns && v && v.startsWith('url(')) {
              el.setAttribute(attr, v);
              return;
            }

            // Normalize transparent cases
            if (!v || v === 'none') {
              el.setAttribute(attr, 'none');
              return;
            }
            if (v.startsWith('rgba(')) {
              const [, r, g, b, a] = v.match(/rgba?\((\d+),\s*(\d+),\s*(\d+),\s*([.\d]+)\)/) || [];
              if (!r) { el.setAttribute(attr, 'none'); return; }
              if (+a === 0) { el.setAttribute(attr, 'none'); return; } // **important**
              el.setAttribute(attr, `rgb(${r}, ${g}, ${b})`);
              el.setAttribute(attr + '-opacity', a);
              return;
            }
            if (v.startsWith('rgb(')) {
              el.setAttribute(attr, v);
              return;
            }

            // Handle keywords like 'none'
            if (v === 'transparent' || v === 'currentcolor') {
              el.setAttribute(attr, 'none');
            } else {
              // last resort
              el.setAttribute(attr, v);
            }
          };

          setPaint('fill', 'fill');
          setPaint('stroke', 'stroke');

          // Stroke details
          const sw = cs.strokeWidth; if (sw) el.setAttribute('stroke-width', sw);
          const slc = cs.strokeLinecap; if (slc) el.setAttribute('stroke-linecap', slc);
          const slj = cs.strokeLinejoin; if (slj) el.setAttribute('stroke-linejoin', slj);
          const sda = cs.strokeDasharray; if (sda && sda !== 'none') el.setAttribute('stroke-dasharray', sda);
          const sdo = cs.strokeDashoffset; if (sdo && sdo !== '0px') el.setAttribute('stroke-dashoffset', sdo);
          
          // Special handling for river elements to ensure they're visible
          if (el.classList && (el.classList.contains('rivers') || el.classList.contains('riversShade'))) {
            // Ensure river paths have proper stroke attributes
            if (!el.hasAttribute('stroke') && !el.style.stroke) {
              if (el.classList.contains('rivers')) {
                el.setAttribute('stroke', '#4D83AE');
              } else if (el.classList.contains('riversShade')) {
                el.setAttribute('stroke', 'rgba(0,0,0,0.35)');
              }
            }
            // Ensure river paths have stroke-width if not set
            if (!el.hasAttribute('stroke-width') && !el.style.strokeWidth) {
              el.setAttribute('stroke-width', '1');
            }
          }
          
          // Special handling for coastline elements to ensure they're visible
          if (el.classList && el.classList.contains('coast')) {
            // Ensure coastline paths have proper stroke attributes
            if (!el.hasAttribute('stroke') && !el.style.stroke) {
              el.setAttribute('stroke', '#111');
            }
            // Ensure coastline paths have stroke-width if not set
            if (!el.hasAttribute('stroke-width') && !el.style.strokeWidth) {
              el.setAttribute('stroke-width', '0.6px');
            }
            // Ensure coastline paths have stroke-linejoin if not set
            if (!el.hasAttribute('stroke-linejoin') && !el.style.strokeLinejoin) {
              el.setAttribute('stroke-linejoin', 'round');
            }
          }
          
          // Special handling for burg elements to ensure they're visible
          if (el.classList && el.classList.contains('burg')) {
            // Burg groups don't need special handling, but their children do
          }
          
          // Special handling for burg circles
          if (el.tagName === 'circle' && el.parentElement && el.parentElement.classList && el.parentElement.classList.contains('burg')) {
            // Ensure burg circles have proper attributes
            if (!el.hasAttribute('fill') && !el.style.fill) {
              el.setAttribute('fill', '#ff0000');
            }
            if (!el.hasAttribute('stroke') && !el.style.stroke) {
              el.setAttribute('stroke', '#fff');
            }
            if (!el.hasAttribute('stroke-width') && !el.style.strokeWidth) {
              el.setAttribute('stroke-width', '0.6');
            }
            if (!el.hasAttribute('paint-order') && !el.style.paintOrder) {
              el.setAttribute('paint-order', 'stroke fill');
            }
            if (!el.hasAttribute('vector-effect') && !el.style.vectorEffect) {
              el.setAttribute('vector-effect', 'non-scaling-stroke');
            }
          }
          
          // Special handling for burg port rectangles
          if (el.tagName === 'rect' && el.parentElement && el.parentElement.classList && el.parentElement.classList.contains('burg')) {
            // Ensure port rectangles have proper attributes
            if (!el.hasAttribute('fill') && !el.style.fill) {
              el.setAttribute('fill', '#4D83AE');
            }
            if (!el.hasAttribute('stroke') && !el.style.stroke) {
              el.setAttribute('stroke', '#fff');
            }
            if (!el.hasAttribute('stroke-width') && !el.style.strokeWidth) {
              el.setAttribute('stroke-width', '0.3');
            }
            if (!el.hasAttribute('paint-order') && !el.style.paintOrder) {
              el.setAttribute('paint-order', 'stroke fill');
            }
            if (!el.hasAttribute('vector-effect') && !el.style.vectorEffect) {
              el.setAttribute('vector-effect', 'non-scaling-stroke');
            }
          }
          
          // Special handling for route paths
          if (el.tagName === 'path' && el.parentElement && el.parentElement.parentElement && el.parentElement.parentElement.id === 'routes') {
            const routeType = el.parentElement.className.baseVal;
            
            if (routeType === 'roads') {
              if (!el.hasAttribute('stroke') && !el.style.stroke) {
                el.setAttribute('stroke', '#6b4e16');
              }
              if (!el.hasAttribute('stroke-width') && !el.style.strokeWidth) {
                el.setAttribute('stroke-width', '1.2px');
              }
            } else if (routeType === 'trails') {
              if (!el.hasAttribute('stroke') && !el.style.stroke) {
                el.setAttribute('stroke', '#9b7b3a');
              }
              if (!el.hasAttribute('stroke-width') && !el.style.strokeWidth) {
                el.setAttribute('stroke-width', '0.8px');
              }
              if (!el.hasAttribute('stroke-dasharray') && !el.style.strokeDasharray) {
                el.setAttribute('stroke-dasharray', '3 3');
              }
            } else if (routeType === 'searoutes') {
              if (!el.hasAttribute('stroke') && !el.style.stroke) {
                el.setAttribute('stroke', '#ffffff');
              }
              if (!el.hasAttribute('stroke-width') && !el.style.strokeWidth) {
                el.setAttribute('stroke-width', '1.0px');
              }
              if (!el.hasAttribute('stroke-dasharray') && !el.style.strokeDasharray) {
                el.setAttribute('stroke-dasharray', '6 3');
              }
              if (!el.hasAttribute('opacity') && !el.style.opacity) {
                el.setAttribute('opacity', '0.9');
              }
            }
            
            // Common route attributes
            if (!el.hasAttribute('fill') && !el.style.fill) {
              el.setAttribute('fill', 'none');
            }
            if (!el.hasAttribute('stroke-linecap') && !el.style.strokeLinecap) {
              el.setAttribute('stroke-linecap', 'round');
            }
            if (!el.hasAttribute('stroke-linejoin') && !el.style.strokeLinejoin) {
              el.setAttribute('stroke-linejoin', 'round');
            }
            if (!el.hasAttribute('vector-effect') && !el.style.vectorEffect) {
              el.setAttribute('vector-effect', 'non-scaling-stroke');
            }
          }

          // Opacities (element-level)
          const op = cs.opacity; if (op && op !== '1') el.setAttribute('opacity', op);

          // Text extras
          const fw = cs.fontWeight; if (fw) el.setAttribute('font-weight', fw);
          const fs = cs.fontSize; if (fs) el.setAttribute('font-size', fs);
          const ff = cs.fontFamily; if (ff) el.setAttribute('font-family', ff);

          const po = cs.paintOrder; if (po && po !== 'normal') el.setAttribute('paint-order', po);
        }
      }

      function saveSVG(svgNode, filename = 'map.svg') {
        // Ensure the map is properly colored before export
        if (window.__state.recolor) {
          window.__state.recolor();
        }
        
        // Debug: Check if rivers exist before export
        const originalRivers = svgNode.querySelectorAll('g.rivers path, g.riversShade path');
        console.log(`Original rivers before export: ${originalRivers.length} paths`);
        if (originalRivers.length === 0) {
          console.log('No rivers found! Computing rivers...');
          if (window.__state.computeRivers) {
            window.__state.computeRivers();
          }
        }
        
        // Debug: Check if coastlines exist before export
        const originalCoastlines = svgNode.querySelectorAll('g.coastline path.coast');
        console.log(`Original coastlines before export: ${originalCoastlines.length} paths`);
        if (originalCoastlines.length === 0) {
          console.log('No coastlines found! Computing coastlines...');
          if (window.__state.drawCoastlines) {
            window.__state.drawCoastlines();
            // Check again after computing
            const newCoastlines = svgNode.querySelectorAll('g.coastline path.coast');
            console.log(`Coastlines after computing: ${newCoastlines.length} paths`);
          }
        }
        
        // Debug: Check if burgs exist before export
        const originalBurgs = svgNode.querySelectorAll('#burgs g.burg');
        console.log(`Original burgs before export: ${originalBurgs.length} burgs`);
        if (originalBurgs.length === 0) {
          console.log('No burgs found! Computing burgs...');
          if (window.__state.generateBurgs) {
            window.__state.generateBurgs();
            // Check again after computing
            const newBurgs = svgNode.querySelectorAll('#burgs g.burg');
            console.log(`Burgs after computing: ${newBurgs.length} burgs`);
          }
        }
        
        // Debug: Check if routes exist before export
        const originalRoutes = svgNode.querySelectorAll('#routes path');
        console.log(`Original routes before export: ${originalRoutes.length} routes`);
        if (originalRoutes.length === 0) {
          console.log('No routes found! Computing routes...');
          if (window.__state.computeRoutes) {
            window.__state.computeRoutes();
            // Check again after computing
            const newRoutes = svgNode.querySelectorAll('#routes path');
            console.log(`Routes after computing: ${newRoutes.length} routes`);
          }
        }
        
        const clone = svgNode.cloneNode(true);
        
        // Ensure ocean background is properly set
        const oceanRect = clone.querySelector('rect.ocean');
        if (oceanRect) {
          oceanRect.setAttribute('fill', WATER_COLOR);
          oceanRect.setAttribute('style', `fill: ${WATER_COLOR}`);
          console.log(`Ocean rect found and styled with color: ${WATER_COLOR}`);
        } else {
          console.log('No ocean rect found in clone!');
        }
        
        // Inline computed styles to ensure colors are preserved in export (preserve patterns)
        inlineSvgStyles(clone, true);
        
        // Prune unused defs but keep referenced ones
        const defs = clone.querySelector('defs');
        if (defs) {
          const usedIds = getUsedIds(clone);
          pruneDefs(defs, usedIds);
        }
        
        // Debug: Check what fills we have after inlining
        const allCells = clone.querySelectorAll('path.mapCell');
        let blackCells = 0, coloredCells = 0, noneCells = 0;
        allCells.forEach(cell => {
          const fill = cell.getAttribute('fill');
          if (fill === '#000' || fill === 'black') blackCells++;
          else if (fill === 'none') noneCells++;
          else coloredCells++;
        });
        console.log(`Export debug after inlining - Black: ${blackCells}, Colored: ${coloredCells}, None: ${noneCells}`);
        
        // Debug: Check SVG structure
        console.log('SVG clone structure:', clone.innerHTML.substring(0, 500) + '...');
        console.log('Ocean rect in clone:', clone.querySelector('rect.ocean')?.outerHTML);
        
        // Debug: Check river elements
        const riverGroups = clone.querySelectorAll('g.rivers, g.riversShade');
        console.log(`Found ${riverGroups.length} river groups in clone:`, riverGroups);
        riverGroups.forEach((group, i) => {
          const paths = group.querySelectorAll('path');
          console.log(`River group ${i} (${group.className.baseVal}): ${paths.length} paths`);
          if (paths.length > 0) {
            console.log('Sample river path:', paths[0].outerHTML);
          }
        });
        
        // Debug: Check coastline elements
        const coastlineGroups = clone.querySelectorAll('g.coastline');
        console.log(`Found ${coastlineGroups.length} coastline groups in clone:`, coastlineGroups);
        coastlineGroups.forEach((group, i) => {
          const paths = group.querySelectorAll('path.coast');
          console.log(`Coastline group ${i} (${group.className.baseVal}): ${paths.length} paths`);
          if (paths.length > 0) {
            console.log('Sample coastline path:', paths[0].outerHTML);
          }
        });
        
        // Debug: Check burg elements
        const burgGroups = clone.querySelectorAll('#burgs');
        console.log(`Found ${burgGroups.length} burg groups in clone:`, burgGroups);
        burgGroups.forEach((group, i) => {
          const burgs = group.querySelectorAll('g.burg');
          console.log(`Burg group ${i}: ${burgs.length} burgs`);
          if (burgs.length > 0) {
            console.log('Sample burg:', burgs[0].outerHTML);
          }
        });
        
        // Debug: Check route elements
        const routeGroups = clone.querySelectorAll('#routes');
        console.log(`Found ${routeGroups.length} route groups in clone:`, routeGroups);
        routeGroups.forEach((group, i) => {
          const roads = group.querySelectorAll('.roads path');
          const trails = group.querySelectorAll('.trails path');
          const seaRoutes = group.querySelectorAll('.searoutes path');
          console.log(`Route group ${i}: ${roads.length} roads, ${trails.length} trails, ${seaRoutes.length} sea routes`);
          if (roads.length > 0) {
            console.log('Sample road:', roads[0].outerHTML);
          }
        });
        
        // ensure inline styles/fonts if needed
        const svgText = new XMLSerializer().serializeToString(clone);
        const blob = new Blob([svgText], {type: 'image/svg+xml;charset=utf-8'});
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = filename;
        a.click();
        URL.revokeObjectURL(a.href);
      }

      async function savePNG(svgNode, w, h, filename = 'map.png') {
        // Ensure the map is properly colored before export
        if (window.__state.recolor) {
          window.__state.recolor();
        }
        
        // Debug: Check if coastlines exist before export
        const originalCoastlines = svgNode.querySelectorAll('g.coastline path.coast');
        console.log(`Original coastlines before PNG export: ${originalCoastlines.length} paths`);
        if (originalCoastlines.length === 0) {
          console.log('No coastlines found! Computing coastlines...');
          if (window.__state.drawCoastlines) {
            window.__state.drawCoastlines();
            // Check again after computing
            const newCoastlines = svgNode.querySelectorAll('g.coastline path.coast');
            console.log(`Coastlines after computing: ${newCoastlines.length} paths`);
          }
        }
        
        // Debug: Check if burgs exist before export
        const originalBurgs = svgNode.querySelectorAll('#burgs g.burg');
        console.log(`Original burgs before PNG export: ${originalBurgs.length} burgs`);
        if (originalBurgs.length === 0) {
          console.log('No burgs found! Computing burgs...');
          if (window.__state.generateBurgs) {
            window.__state.generateBurgs();
            // Check again after computing
            const newBurgs = svgNode.querySelectorAll('#burgs g.burg');
            console.log(`Burgs after computing: ${newBurgs.length} burgs`);
          }
        }
        
        // Debug: Check if routes exist before export
        const originalRoutes = svgNode.querySelectorAll('#routes path');
        console.log(`Original routes before PNG export: ${originalRoutes.length} routes`);
        if (originalRoutes.length === 0) {
          console.log('No routes found! Computing routes...');
          if (window.__state.computeRoutes) {
            window.__state.computeRoutes();
            // Check again after computing
            const newRoutes = svgNode.querySelectorAll('#routes path');
            console.log(`Routes after computing: ${newRoutes.length} routes`);
          }
        }
        
        // Create a clone and prepare for canvas rasterization
        const clone = svgNode.cloneNode(true);
        
        // Add namespaces and explicit size for canvas rendering
        clone.setAttribute("xmlns", "http://www.w3.org/2000/svg");
        clone.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink");
        clone.setAttribute("width", `${w}`);
        clone.setAttribute("height", `${h}`);
        if (!clone.getAttribute("viewBox")) {
          clone.setAttribute("viewBox", `0 0 ${w} ${h}`);
        }
        
        // Inline computed styles to ensure colors are preserved in export (raster-safe)
        inlineSvgStyles(clone, false);
        
        // Remove problematic attributes that can break canvas rendering (restrict to render tree)
        clone.querySelectorAll(':not(defs) [filter]').forEach(n => n.removeAttribute('filter'));
        clone.querySelectorAll('[mask]').forEach(n => n.removeAttribute('mask'));
        clone.querySelectorAll('[mix-blend-mode],[style*="mix-blend-mode"]').forEach(n => {
          n.style.mixBlendMode = '';
        });
        
        // Handle any paint servers (url references) by forcing solid fills
        clone.querySelectorAll('[fill^="url("], [stroke^="url("]').forEach(el => {
          const paint = getComputedStyle(el).fill;
          el.setAttribute('fill', paint && paint !== 'none' ? paint : WATER_COLOR);
        });
        
        // Add solid background ocean for raster-safe export
        const oceanEl = clone.querySelector('#oceanBase, .ocean, [data-layer="ocean"]');
        let oceanColor = WATER_COLOR;
        if (oceanEl) {
          const f = getComputedStyle(oceanEl).fill;
          if (f && f.startsWith('rgb(')) oceanColor = f;
        }
        ensureBackgroundOcean(clone, oceanColor);
        
        // Remove unused defs if nothing references them
        if (!clone.querySelector('[fill^="url("],[stroke^="url("],[filter],[mask]')) {
          const defs = clone.querySelector('defs');
          if (defs) defs.remove();
        }
        
        const svgText = new XMLSerializer().serializeToString(clone);
        const svgUrl = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svgText);
        const img = new Image();
        img.crossOrigin = 'anonymous';
        
        await new Promise(resolve => {
          img.onload = resolve;
          img.src = svgUrl;
        });
        
        const canvas = document.createElement('canvas');
        canvas.width = w;
        canvas.height = h;
        const ctx = canvas.getContext('2d');
        
        // Draw the SVG image (background is already included in SVG)
        ctx.drawImage(img, 0, 0, w, h);
        
        canvas.toBlob(blob => {
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = filename;
          a.click();
          URL.revokeObjectURL(a.href);
        }, 'image/png');
      }

      // Expose export functions globally
      window.saveSVG = saveSVG;
      window.savePNG = savePNG;

      // --- Climate and Biome System ---
      function computeClimate(sea) {
        const baseTempF = +document.getElementById('baseTempInput').value;
        const baseTempC = (baseTempF - 32) * 5/9; // Convert F to C
        const maxElevation_m = 2000; // meters
        const lapseRate = 6.5; // °C per 1000m
        
        // Compute temperature and precipitation for each cell
        cells.forEach(c => {
          // Temperature based on elevation
          const elevRatio = Math.max(0, c.high - sea) / (1 - sea);
          const elevation_m = elevRatio * maxElevation_m;
          c.temp = baseTempC - (elevation_m * lapseRate / 1000);
          
          // Precipitation (reuse existing model)
          c.precip = 0; // Will be set by computePrecipArray
        });
        
        // Get precipitation values and scale them
        const precipArray = computePrecipArray();
        const precipScale = +document.getElementById('precipScaleInput').value || 0.5;
        cells.forEach((c, i) => {
          c.precip = precipArray[i] * precipScale;
        });
        
        // Classify biomes
        cells.forEach(c => {
          c.biome = classifyBiome(c, sea);
        });
        
        // Debug: Log temperature and precipitation ranges
        const landCells = cells.filter(c => c.high >= sea);
        if (landCells.length > 0) {
          const temps = landCells.map(c => c.temp);
          const precips = landCells.map(c => c.precip);
          const minTempC = Math.min(...temps);
          const maxTempC = Math.max(...temps);
          const minTempF = minTempC * 9/5 + 32;
          const maxTempF = maxTempC * 9/5 + 32;
          const minPrecip = Math.min(...precips);
          const maxPrecip = Math.max(...precips);
          console.log(`Temperature range: ${minTempF.toFixed(1)}°F to ${maxTempF.toFixed(1)}°F (${minTempC.toFixed(1)}°C to ${maxTempC.toFixed(1)}°C)`);
          console.log(`Precipitation range: ${minPrecip.toFixed(3)} to ${maxPrecip.toFixed(3)}`);
        }
      }
      
      function classifyBiome(cell, seaLevel) {
        if (cell.high < seaLevel) return 'Ocean';
        
        const T = cell.temp;
        const P = cell.precip;
        
        // Adjust thresholds based on typical precipitation ranges
        if (T < -5) {
          return P > 0.3 ? 'Tundra' : 'Polar Desert';
        }
        if (T < 5) {
          return P > 0.6 ? 'Boreal Forest' : (P > 0.3 ? 'Cold Grassland' : 'Cold Desert');
        }
        if (T < 18) {
          if (P < 0.3) return 'Temperate Desert';
          if (P < 0.6) return 'Grassland';
          if (P < 1.2) return 'Temperate Forest';
          return 'Rainforest';
        }
        // T >= 18 (tropical)
        if (P < 0.3) return 'Hot Desert';
        if (P < 0.6) return 'Savanna';
        if (P < 1.0) return 'Tropical Seasonal Forest';
        return 'Tropical Rainforest';
      }
      
      function getBiomeColor(biome, elevation, seaLevel) {
        const biomeColors = {
          'Ocean': '#4D83AE',
          'Tundra': '#E8F4F8',
          'Polar Desert': '#F0F8FF',
          'Boreal Forest': '#2E5A27',
          'Cold Grassland': '#8FBC8F',
          'Cold Desert': '#F5DEB3',
          'Temperate Desert': '#DEB887',
          'Grassland': '#90EE90',
          'Temperate Forest': '#228B22',
          'Rainforest': '#006400',
          'Hot Desert': '#F4A460',
          'Savanna': '#F0E68C',
          'Tropical Seasonal Forest': '#32CD32',
          'Tropical Rainforest': '#228B22'
        };
        
        // For hybrid mode, blend with elevation
        const renderMode = document.getElementById('renderMode').value;
        if (renderMode === 'hybrid' && elevation > seaLevel + 0.3) {
          // Fade to white for high elevations
          const t = Math.min(1, (elevation - seaLevel - 0.3) / 0.4);
          return d3.interpolateRgb(biomeColors[biome] || '#228B22', '#ffffff')(t);
        }
        
        return biomeColors[biome] || '#228B22';
      }
      
      function updateBiomeLegend() {
        const renderMode = document.getElementById('renderMode').value;
        const legend = document.getElementById('biomeLegend');
        const legendItems = document.getElementById('legendItems');
        
        if (renderMode === 'biomes' || renderMode === 'hybrid') {
          const biomeColors = {
            'Ocean': '#4D83AE',
            'Tundra': '#E8F4F8',
            'Polar Desert': '#F0F8FF',
            'Boreal Forest': '#2E5A27',
            'Cold Grassland': '#8FBC8F',
            'Cold Desert': '#F5DEB3',
            'Temperate Desert': '#DEB887',
            'Grassland': '#90EE90',
            'Temperate Forest': '#228B22',
            'Rainforest': '#006400',
            'Hot Desert': '#F4A460',
            'Savanna': '#F0E68C',
            'Tropical Seasonal Forest': '#32CD32',
            'Tropical Rainforest': '#228B22'
          };
          
          // Group biomes by temperature category
          const biomeGroups = {
            'Cold Biomes': ['Tundra', 'Polar Desert', 'Boreal Forest', 'Cold Grassland', 'Cold Desert'],
            'Temperate Biomes': ['Temperate Desert', 'Grassland', 'Temperate Forest', 'Rainforest'],
            'Tropical Biomes': ['Hot Desert', 'Savanna', 'Tropical Seasonal Forest', 'Tropical Rainforest'],
            'Water': ['Ocean']
          };
          
          let legendHTML = '';
          
          Object.entries(biomeGroups).forEach(([groupName, biomes]) => {
            legendHTML += `<div style="margin-bottom: 8px;"><strong>${groupName}</strong></div>`;
            biomes.forEach(biome => {
              const color = biomeColors[biome];
              legendHTML += `
                <div style="display: flex; align-items: center; margin-bottom: 2px;">
                  <div style="width: 16px; height: 12px; background-color: ${color}; border: 1px solid #666; margin-right: 8px;"></div>
                  <span>${biome}</span>
                </div>
              `;
            });
            legendHTML += '<br>';
          });
          
          if (renderMode === 'hybrid') {
            legendHTML += `
              <div style="margin-top: 8px; font-style: italic; font-size: 11px;">
                Note: High elevations fade to white in hybrid mode
              </div>
            `;
          }
          
          legendItems.innerHTML = legendHTML;
          legend.style.display = 'block';
        } else {
          legend.style.display = 'none';
        }
      }

      // --- Rivers & precipitation (Azgaar-inspired) ---
      function windVecForLat(latDeg) {
        // return unit vector [ux, uy] in screen coords (x right, y down)
        if (Math.abs(latDeg) < 30) return [1, 0];   // easterlies → 
        if (Math.abs(latDeg) < 60) return [-1, 0];  // westerlies ←
        return [1, 0];                              // polar easterlies →
      }

      function windField(cells, H) {
        const U = Array(cells.length);
        for (let i = 0; i < cells.length; i++) {
          const lat = 90 - 180 * (cells[i].cy / height); // 0..1 → 90..-90
          U[i] = windVecForLat(lat);
        }
        return U;
      }

      function windVecs() {
        const mode = document.getElementById('windBelts').value;
        if (mode === 'hadley') {
          // Use wind field for each cell
          return windField(cells, cells.map(c => c.high));
        } else {
          // Random wind (original behavior)
          const pick = () => [[1,0],[-1,0],[0,1],[0,-1]][Math.floor(Math.random()*4)];
          return [pick()];
        }
      }

      function computePrecipArray() {
        const windMode = document.getElementById('windBelts').value;
        const intensity = +document.getElementById('rainInput').value; // 0..2
        const base = 0.4 * intensity + 0.1; // baseline drizzle
        const P = new Float32Array(cells.length);
        for (let i = 0; i < cells.length; i++) P[i] = base;
        
        if (windMode === 'hadley') {
          // Use wind field with orographic effects
          const U = windField(cells, cells.map(c => c.high));
          for (let i = 0; i < cells.length; i++) {
            const ci = cells[i];
            const [wx, wy] = U[i]; // Wind vector for this cell
            const nbs = ci.neighbors;
            for (let k = 0; k < nbs.length; k++) {
              const j = nbs[k];
              const vx = ci.cx - cells[j].cx;
              const vy = ci.cy - cells[j].cy;
              const dot = vx * wx + vy * wy; // >0 means wind approaches cell i from neighbor j
              const dh = ci.high - cells[j].high; // upslope from j -> i adds rain
              if (dot > 0 && dh > 0) {
                // Upslope: orographic bonus
                P[i] += intensity * dh * (dot / Math.hypot(vx, vy)) * 0.3;
              } else if (dot > 0 && dh < 0) {
                // Lee side: rain shadow
                P[i] -= intensity * (-dh) * (dot / Math.hypot(vx, vy)) * 0.15;
              }
            }
          }
        } else {
          // Original random wind system
          const winds = windVecs();
          const norm = (x,y) => { const L = Math.hypot(x,y)||1; return [x/L, y/L]; };
          winds.forEach(w => {
            const [wx, wy] = norm(w[0], w[1]);
            for (let i = 0; i < cells.length; i++) {
              const ci = cells[i];
              const nbs = ci.neighbors;
              for (let k = 0; k < nbs.length; k++) {
                const j = nbs[k];
                const vx = ci.cx - cells[j].cx;
                const vy = ci.cy - cells[j].cy;
                const dot = vx*wx + vy*wy; // >0 means wind approaches cell i from neighbor j
                const dh = ci.high - cells[j].high; // upslope from j -> i adds rain
                if (dot > 0 && dh > 0) P[i] += intensity * dh * (dot/Math.hypot(vx,vy)) * 0.6;
                else if (dot > 0 && dh < 0) P[i] += intensity * dh * 0.15; // leeward drying
              }
            }
          });
        }
        // smooth precipitation a bit (2 iterations)
        for (let it = 0; it < 2; it++) {
          const N = new Float32Array(cells.length);
          for (let i = 0; i < cells.length; i++) {
            let sum = P[i], cnt = 1;
            const nbs = cells[i].neighbors;
            for (let k = 0; k < nbs.length; k++) { sum += P[nbs[k]]; cnt++; }
            N[i] = sum / cnt;
          }
          P.set(N);
        }
        // Store precipitation array for tests
        window.__state.precipArray = P;
        return P;
      }

      function computeRivers() {
        riversShade.selectAll('path').remove();
        riversG.selectAll('path').remove();
        const sea = +document.getElementById('seaLevelInput').value;
        const landIdxs = [];
        for (let i = 0; i < cells.length; i++) if (cells[i].high >= sea) landIdxs.push(i);
        if (!landIdxs.length) { window.__state.riverStats = { majors:0, confluences:0, majorsDrawn:0, majorsReachedSea:0, avgMainLength:0 }; return; }

        // Update progress during river computation
        ProgressManager.update(62, 'Computing rivers...', 'Building distance field...');

        // Use cached typed arrays
        const {dist, down, flux} = window.__state.tmp;
        dist.fill(1e9); down.fill(-1); flux.fill(0);

        // Distance-to-coast field (toward sea only)
        const INF = 1e9;
        const bfsQueue = [];
        for (let i = 0; i < cells.length; i++) if (cells[i].high < sea) { dist[i] = 0; bfsQueue.push(i); }
        for (let qi = 0; qi < bfsQueue.length; qi++) {
          const v = bfsQueue[qi];
          const dv = dist[v] + 1;
          const nbs = cells[v].neighbors;
          for (let k = 0; k < nbs.length; k++) { const nb = nbs[k]; if (dist[nb] > dv) { dist[nb] = dv; bfsQueue.push(nb); } }
        }

        // Flow directions
        landIdxs.forEach(i => {
          let best = -1, bestH = Infinity;
          const di = dist[i];
          const nbs = cells[i].neighbors;
          for (let k = 0; k < nbs.length; k++) {
            const nb = nbs[k];
            if (dist[nb] < di && cells[nb].high <= bestH) { bestH = cells[nb].high; best = nb; }
          }
          if (best === -1) {
            for (let k = 0; k < nbs.length; k++) {
              const nb = nbs[k];
              if (cells[nb].high < cells[i].high && cells[nb].high < bestH) { bestH = cells[nb].high; best = nb; }
            }
          }
          if (best === -1) {
            let bestD = Infinity; bestH = Infinity;
            for (let k = 0; k < nbs.length; k++) {
              const nb = nbs[k]; const dd = dist[nb]; const hh = cells[nb].high;
              if (dd < bestD || (dd === bestD && hh < bestH)) { bestD = dd; bestH = hh; best = nb; }
            }
          }
          down[i] = best;
        });

        // Sort by elevation (top-down)
        const orderByElev = landIdxs.slice().sort((a,b) => cells[b].high - cells[a].high);

        // Precipitation-driven flux
        const precip = PRECIP || computePrecipArray();
        for (const i of orderByElev) flux[i] = Math.max(0, precip[i]);
        for (const i of orderByElev) { const j = down[i]; if (j !== -1) flux[j] += flux[i]; }

        // Helpers
        const valsAll = landIdxs.map(i => flux[i]).sort((a,b)=>a-b);
        const maxF = valsAll.length ? valsAll[valsAll.length-1] : 1;
        const up = Array.from({length: cells.length}, () => []);
        landIdxs.forEach(i => { const j = down[i]; if (j !== -1 && cells[j].high >= sea) up[j].push(i); });
        const countConfluences = (thr) => up.reduce((acc,arr,idx)=> acc + ((cells[idx].high>=sea && arr.filter(a=>flux[a]>=thr).length>=2)?1:0), 0);

        const curve = d3.curveCatmullRom.alpha(0.6);
        const pathOpen = d3.line().x(d=>d[0]).y(d=>d[1]).curve(curve);
        function lengthOf(pts){ let L=0; for (let i=1;i<pts.length;i++){ const dx=pts[i][0]-pts[i-1][0], dy=pts[i][1]-pts[i-1][1]; L+=Math.hypot(dx,dy);} return L; }

        // Polygonal river rendering based on Azgaar's technique
        function createPolygonalRiver(segments, flux, isMain) {
          const riverStyle = document.getElementById('riverStyle').value;
          if (riverStyle === 'lines') return false;
          
          const widening = +document.getElementById('riverWidthInput').value || 200;
          const maxWidth = isMain ? 4.2 : 2.2;
          
          segments.forEach(seg => {
            if (seg.length < 2) return;
            
            // Calculate total length manually
            let totalLength = 0;
            for (let i = 1; i < seg.length; i++) {
              const dx = seg[i][0] - seg[i-1][0];
              const dy = seg[i][1] - seg[i-1][1];
              totalLength += Math.hypot(dx, dy);
            }
            
            if (totalLength < 10) return; // Skip very short segments
            
            const riverPointsLeft = [], riverPointsRight = [];
            
            // Sample points along the river path
            const numSamples = Math.max(10, Math.floor(totalLength / 5));
            for (let i = 0; i <= numSamples; i++) {
              const t = i / numSamples;
              
              // Find position along the path
              let currentLength = 0;
              let targetLength = t * totalLength;
              let point = seg[0];
              
              for (let j = 1; j < seg.length; j++) {
                const dx = seg[j][0] - seg[j-1][0];
                const dy = seg[j][1] - seg[j-1][1];
                const segLength = Math.hypot(dx, dy);
                
                if (currentLength + segLength >= targetLength) {
                  const localT = (targetLength - currentLength) / segLength;
                  point = [
                    seg[j-1][0] + dx * localT,
                    seg[j-1][1] + dy * localT
                  ];
                  break;
                }
                currentLength += segLength;
                if (j === seg.length - 1) point = seg[j];
              }
              
              // Calculate tangent direction
              let tangent = [1, 0]; // default
              if (i > 0 && i < numSamples) {
                const prevT = (i - 1) / numSamples;
                const nextT = (i + 1) / numSamples;
                let prevPoint = seg[0], nextPoint = seg[0];
                
                // Find previous and next points
                currentLength = 0;
                let prevTarget = prevT * totalLength, nextTarget = nextT * totalLength;
                
                for (let j = 1; j < seg.length; j++) {
                  const dx = seg[j][0] - seg[j-1][0];
                  const dy = seg[j][1] - seg[j-1][1];
                  const segLength = Math.hypot(dx, dy);
                  
                  if (currentLength + segLength >= prevTarget && prevPoint === seg[0]) {
                    const localT = (prevTarget - currentLength) / segLength;
                    prevPoint = [
                      seg[j-1][0] + dx * localT,
                      seg[j-1][1] + dy * localT
                    ];
                  }
                  
                  if (currentLength + segLength >= nextTarget && nextPoint === seg[0]) {
                    const localT = (nextTarget - currentLength) / segLength;
                    nextPoint = [
                      seg[j-1][0] + dx * localT,
                      seg[j-1][1] + dy * localT
                    ];
                  }
                  
                  currentLength += segLength;
                  if (j === seg.length - 1) {
                    if (prevPoint === seg[0]) prevPoint = seg[j];
                    if (nextPoint === seg[0]) nextPoint = seg[j];
                  }
                }
                
                const tx = nextPoint[0] - prevPoint[0];
                const ty = nextPoint[1] - prevPoint[1];
                const length = Math.hypot(tx, ty);
                if (length > 0) {
                  tangent = [tx / length, ty / length];
                }
              }
              
              // Calculate offset using hyperbolic tangent with widening parameter
              const offset = Math.atan(t * 3) * (flux / maxF) * maxWidth * (widening / 200);
              
              // Create offset points
              const xLeft = point[0] + -tangent[1] * offset;
              const yLeft = point[1] + tangent[0] * offset;
              riverPointsLeft.push([xLeft, yLeft]);
              
              const xRight = point[0] + tangent[1] * offset;
              const yRight = point[1] + -tangent[0] * offset;
              riverPointsRight.unshift([xRight, yRight]);
            }
            
            if (riverPointsLeft.length < 2) return;
            
            // Create the river polygon
            const riverPolygon = [...riverPointsLeft, ...riverPointsRight];
            
            // Draw the polygon
            const polygonPath = 'M' + riverPolygon.map(p => p.join(',')).join('L') + 'Z';
            
            riversShade.append('path')
              .attr('class', 'riversShade ' + (isMain ? 'main' : 'trib'))
              .attr('d', polygonPath)
              .attr('fill', 'rgba(0,0,0,0.3)');
              
            riversG.append('path')
              .attr('class', 'rivers ' + (isMain ? 'main' : 'trib'))
              .attr('d', polygonPath)
              .attr('fill', '#4D83AE');
          });
          
          return true; // Indicate polygonal rendering was used
        }

        // Chain builder with lake-aware jumps
        function chainFrom(s, stopSet) {
          const segments = [];
          let edges = [];
          let current = s;
          let pts = [[cells[current].cx, cells[current].cy]];
          let steps = 0; let reachedSea = false;
          const visitedLakes = new Set();
          while (steps++ < 4000) {
            const j = down[current]; if (j === -1) break;
            const ekey = current + ">" + j; if (stopSet && stopSet.has(ekey)) break;
            const isSea = cells[j].high < sea;
            const isLake = (window.__state.isLake && window.__state.isLake[j] === 1);
            if (isSea || isLake) {
              const mid = [(cells[current].cx + cells[j].cx)/2, (cells[current].cy + cells[j].cy)/2];
              pts.push(mid);
              segments.push(pts);
              edges.push(ekey);
              if (isSea) { reachedSea = true; break; }
              
              // Handle lake outlet
              const lid = window.__state.lakeId ? window.__state.lakeId[j] : -1;
              if (visitedLakes.has(lid)) break; // avoid loops
              visitedLakes.add(lid);
              
              const lake = (window.__state.lakes || [])[lid];
              if (!lake) break; // no lake data
              
              const outlet = lake.outlet;
              if (outlet === -1 || outlet === undefined) break; // endorheic lake
              
              // Verify outlet is valid and leads to ocean
              if (outlet < 0 || outlet >= cells.length) break; // invalid outlet
              
              // Check if outlet leads to ocean or another lake
              const outletCell = cells[outlet];
              if (!outletCell) break; // invalid outlet cell
              
              // If outlet is also a lake, we might have a chain of lakes
              const outletIsLake = window.__state.isLake && window.__state.isLake[outlet] === 1;
              if (outletIsLake) {
                // For now, break to avoid complex lake chains
                // In the future, we could trace through multiple lakes
                break;
              }
              
              // Continue from outlet
              current = outlet;
              pts = [[cells[current].cx, cells[current].cy]]; // start new segment from outlet
              continue;
            } else {
              pts.push([cells[j].cx, cells[j].cy]);
              edges.push(ekey);
              current = j;
            }
          }
          const totalLen = segments.reduce((acc, p) => acc + lengthOf(p), 0);
          return { segments, edges, reachedSea, len: totalLen };
        }

        // Calibrate to ~5–15 mains
        let q = +document.getElementById('riverDensityInput').value; // 0.70..0.99 base
        let thrMain = d3.quantile(valsAll, q) || (maxF * 0.6);
        const sourcesCount = (thr) => {
          const good = new Set(landIdxs.filter(i=>flux[i]>=thr));
          let cnt = 0; good.forEach(i => { const hasUp = up[i].some(u=>good.has(u)); if (!hasUp) cnt++; });
          return cnt;
        };
        let majors = sourcesCount(thrMain);
        let guard = 0;
        while ((majors < 5 || majors > 15) && guard++ < 18) {
          if (majors < 5) { q = Math.max(0.70, q - 0.03); } else { q = Math.min(0.99, q + 0.02); }
          thrMain = d3.quantile(valsAll, q) || thrMain * (majors < 5 ? 0.8 : 1.2);
          majors = sourcesCount(thrMain);
        }

        const thrTrib = Math.max(d3.quantile(valsAll, Math.max(0.70, q - 0.10)) || thrMain*0.7, thrMain*0.5);
        const widthMain = d3.scaleSqrt().domain([Math.max(1e-6, thrMain), Math.max(1e-6, maxF)]).range([1.2, 4.2]);
        const widthTrib = d3.scaleSqrt().domain([Math.max(1e-6, thrTrib), Math.max(1e-6, maxF)]).range([0.45, 2.2]);

        const visitedMain = new Set();
        let majorsDrawn = 0, majorsReachedSea = 0; let totalMainLen = 0;

        const mainStarts = landIdxs.filter(i => flux[i] >= thrMain).sort((a,b)=>flux[b]-flux[a]);
        for (const s of mainStarts) {
          const j0 = down[s]; if (j0 !== -1 && visitedMain.has(s+">"+j0)) continue;
          const chain = chainFrom(s, visitedMain);
          if (!chain.segments.length) continue;
          if (chain.len < 60) continue;
          
          // Try polygonal rendering first
          const usedPolygonal = createPolygonalRiver(chain.segments, flux[s], true);
          if (!usedPolygonal) {
            // Fall back to line rendering
            chain.segments.forEach(seg => {
              riversShade.append('path').attr('class','riversShade main').attr('d', pathOpen(seg)).attr('stroke-width', Math.max(0.3, widthMain(flux[s])*0.4));
              riversG.append('path').attr('class','rivers main').attr('d', pathOpen(seg)).attr('stroke-width', widthMain(flux[s]));
            });
          }
          chain.edges.forEach(k => visitedMain.add(k));
          majorsDrawn++; totalMainLen += chain.len; if (chain.reachedSea) majorsReachedSea++;
        }

        const tribStarts = landIdxs.filter(i => flux[i] >= thrTrib).sort((a,b)=>flux[b]-flux[a]);
        for (const s of tribStarts) {
          const j0 = down[s]; if (j0 !== -1 && visitedMain.has(s+">"+j0)) continue;
          const chain = chainFrom(s, visitedMain);
          if (!chain.segments.length || chain.len < 30) continue;
          
          // Try polygonal rendering first
          const usedPolygonal = createPolygonalRiver(chain.segments, flux[s], false);
          if (!usedPolygonal) {
            // Fall back to line rendering
            chain.segments.forEach(seg => {
              riversShade.append('path').attr('class','riversShade trib').attr('d', pathOpen(seg)).attr('stroke-width', Math.max(0.2, widthTrib(flux[s])*0.35));
              riversG.append('path').attr('class','rivers trib').attr('d', pathOpen(seg)).attr('stroke-width', widthTrib(flux[s]));
            });
          }
        }

        const confl = countConfluences(thrTrib);
        const avgMainLength = majorsDrawn ? (totalMainLen / majorsDrawn) : 0;
        window.__state.riverStats = { majors, confluences: confl, thrMain, thrTrib, majorsDrawn, majorsReachedSea, avgMainLength };
        
        // Debug: Log lake information
        const lakes = window.__state.lakes || [];
        if (lakes.length > 0) {
          console.log(`Found ${lakes.length} lakes:`);
          lakes.forEach((lake, i) => {
            const outletValid = lake.outlet >= 0 && lake.outlet < cells.length;
            const outletIsLake = outletValid && window.__state.isLake && window.__state.isLake[lake.outlet] === 1;
            const outletIsOcean = outletValid && cells[lake.outlet].high < sea;
            console.log(`  Lake ${i}: size=${lake.size}, depth=${lake.depth.toFixed(3)}, outlet=${lake.outlet} (valid:${outletValid}, isLake:${outletIsLake}, isOcean:${outletIsOcean})`);
          });
        }
      }

      // --- Coastline builder (Azgaar-style: boundary between land and water) --- (Azgaar-style: boundary between land and water) --- (Azgaar-style: boundary between land and water) ---
      function drawCoastlines() {
        coastG.selectAll('path.coast').remove();
        const sea = +document.getElementById('seaLevelInput').value;
        const isWaterArr = (window.__state.isWater) || cells.map(c => c.high < sea);
        const isLand = cells.map((c,i) => !isWaterArr[i]);
        
        console.log(`Drawing coastlines - Sea level: ${sea}, Land cells: ${isLand.filter(l => l).length}, Water cells: ${isWaterArr.filter(w => w).length}`);
        
        // Update progress during coastline computation
        ProgressManager.update(72, 'Drawing coastlines...', 'Finding coastline edges...');

        // Build undirected edge map from Voronoi cell polygons
        const edgeMap = new Map(); // key -> {a,b,cells:Set}
        const keyOfPoint = (p) => `${p[0].toFixed(3)},${p[1].toFixed(3)}`;
        const edgeKey = (a,b) => {
          const qa = keyOfPoint(a), qb = keyOfPoint(b);
          return qa < qb ? `${qa}|${qb}` : `${qb}|${qa}`;
        };

        cells.forEach((c) => {
          const poly = c.poly;
          for (let i = 0; i < poly.length - 1; i++) { // last equals first
            const a = poly[i], b = poly[i + 1];
            const k = edgeKey(a, b);
            let e = edgeMap.get(k);
            if (!e) { e = { a, b, cells: new Set() }; edgeMap.set(k, e); }
            e.cells.add(c.index);
          }
        });

        // Filter edges where sides differ (land vs water OR hull)
        const coastEdges = [];
        edgeMap.forEach((e) => {
          const arr = Array.from(e.cells);
          const c0 = arr[0];
          const c1 = arr[1] !== undefined ? arr[1] : null; // null => hull
          const land0 = c0 != null ? isLand[c0] : false;
          const land1 = c1 != null ? isLand[c1] : false;
          if (land0 !== land1) coastEdges.push(e); // coastline segment
        });

        console.log(`Found ${coastEdges.length} coastline edges`);
        if (coastEdges.length === 0) return;

        // Chain edges into polylines by shared endpoints
        const pointToEdges = new Map(); // pointKey -> Set(edgeKey)
        coastEdges.forEach((e) => {
          const k = edgeKey(e.a, e.b);
          const ka = keyOfPoint(e.a), kb = keyOfPoint(e.b);
          if (!pointToEdges.has(ka)) pointToEdges.set(ka, new Set());
          if (!pointToEdges.has(kb)) pointToEdges.set(kb, new Set());
          pointToEdges.get(ka).add(k);
          pointToEdges.get(kb).add(k);
        });

        const edgesObj = new Map();
        coastEdges.forEach((e) => { edgesObj.set(edgeKey(e.a, e.b), { a: e.a, b: e.b, used: false }); });

        const chains = [];
        const takeNext = (ptKey) => {
          const set = pointToEdges.get(ptKey);
          if (!set) return null;
          for (const k of set) { const e = edgesObj.get(k); if (e && !e.used) return k; }
          return null;
        };

        edgesObj.forEach((seg) => {
          if (seg.used) return;
          seg.used = true;
          const startKey = keyOfPoint(seg.a), endKey = keyOfPoint(seg.b);
          const chain = [seg.a, seg.b];

          // extend forward from end
          let currKey = endKey;
          let prevKey = startKey;
          for (;;) {
            const nextKey = takeNext(currKey);
            if (!nextKey) break;
            const next = edgesObj.get(nextKey);
            next.used = true;
            const na = keyOfPoint(next.a), nb = keyOfPoint(next.b);
            const other = (na === currKey) ? nb : (nb === currKey ? na : null);
            if (!other || other === prevKey) break;
            chain.push(na === currKey ? next.b : next.a);
            prevKey = currKey; currKey = other;
          }

          // extend backward from start (prepend)
          currKey = startKey; prevKey = endKey;
          for (;;) {
            const nextKey = takeNext(currKey);
            if (!nextKey) break;
            const next = edgesObj.get(nextKey);
            next.used = true;
            const na = keyOfPoint(next.a), nb = keyOfPoint(next.b);
            const other = (na === currKey) ? nb : (nb === currKey ? na : null);
            if (!other || other === prevKey) break;
            chain.unshift(na === currKey ? next.b : next.a);
            prevKey = currKey; currKey = other;
          }

          chains.push(chain);
        });

        // Draw chains with path simplification
        const lineOpen = d3.line().x(d => d[0]).y(d => d[1]).curve(d3.curveBasis);
        const lineClosed = d3.line().x(d => d[0]).y(d => d[1]).curve(d3.curveBasisClosed);

        console.log(`Created ${chains.length} coastline chains`);
        chains.forEach((pts) => {
          const closed = (keyOfPoint(pts[0]) === keyOfPoint(pts[pts.length - 1]));
          
          // Simplify path based on map size (tolerance proportional to map scale)
          const tolerance = Math.max(0.15, Math.min(0.3, cells.length / 50000));
          const simplifiedPts = simplifyPath(pts, tolerance);
          
          coastG.append('path')
            .attr('class', 'coast')
            .attr('d', closed ? lineClosed(simplifiedPts) : lineOpen(simplifiedPts))
            .attr('fill', 'none')
            .attr('stroke', '#111')
            .attr('stroke-width', '0.6px')
            .attr('stroke-linejoin', 'round');
        });
        console.log(`Drew ${chains.length} coastline paths (simplified)`);
      }
    }

    // --- Burgs (Settlements) System ---

    /**
     * Score a cell for capital placement (strategic locations)
     * @param {Object} cell - The cell to score
     * @param {Array} cells - All cells array
     * @param {number} sea - Sea level
     * @returns {number} Score between 0 and 1
     */
    function scoreCellForCapital(cell, cells, sea) {
      const riverWeight = +document.getElementById('riverWeightInput').value || 0.4;
      const coastWeight = +document.getElementById('coastWeightInput').value || 0.3;
      const flatnessWeight = +document.getElementById('flatnessWeightInput').value || 0.2;
      const fertilityWeight = +document.getElementById('fertilityWeightInput').value || 0.1;

      // Skip water cells
      if (cell.high < sea) return 0;
      
      // Skip very high peaks (too steep for settlements)
      if (cell.high > 0.8) return 0;

      let riverProximity = 0;
      let coastProximity = 0;
      let flatness = 0;
      let fertility = 1; // Default fertility
      let harborQuality = 0;

      // Calculate river proximity (check neighbors for rivers)
      let riverNeighbors = 0;
      cell.neighbors.forEach(nb => {
        const neighborCell = cells[nb];
        const isWater = neighborCell.high < sea;
        const isLake = window.__state.isLake && window.__state.isLake[nb] === 1;
        if (isWater && !isLake) {
          riverNeighbors++;
        }
      });
      riverProximity = Math.min(1, riverNeighbors / cell.neighbors.length * 3);

      // Calculate river proximity
      riverProximity = Math.min(1, riverNeighbors / cell.neighbors.length * 3);

      // Calculate coast proximity with harbor quality check
      let minWaterDist = Infinity;
      let waterNeighbors = 0;
      for (let i = 0; i < cells.length; i++) {
        if (cells[i].high < sea) {
          const dist = Math.hypot(cell.cx - cells[i].cx, cell.cy - cells[i].cy);
          minWaterDist = Math.min(minWaterDist, dist);
          
          // Count water neighbors for harbor quality
          if (dist < 30) {
            waterNeighbors++;
          }
        }
      }
      coastProximity = Math.max(0, 1 - minWaterDist / 100); // Prefer cells within 100px of coast
      
      // Harbor quality: prefer sheltered locations (exactly one ocean neighbor)
      if (waterNeighbors === 1) {
        harborQuality = 1.0; // Perfect harbor (cove/estuary)
      } else if (waterNeighbors === 2) {
        harborQuality = 0.7; // Good harbor
      } else if (waterNeighbors > 2) {
        harborQuality = 0.3; // Exposed coast
      }

      // Calculate flatness (inverse of slope)
      let maxSlope = 0;
      cell.neighbors.forEach(nb => {
        const slope = Math.abs(cell.high - cells[nb].high);
        maxSlope = Math.max(maxSlope, slope);
      });
      flatness = Math.max(0, 1 - maxSlope * 5); // Prefer flatter areas

      // Calculate fertility (use precipitation if available)
      if (window.__state.precipArray) {
        fertility = Math.min(1, window.__state.precipArray[cell.index] || 0.5);
      }

      // Combine scores with weights (capitals emphasize strategic locations)
      const score = riverWeight * riverProximity + 
                   coastWeight * (coastProximity * 0.6 + harborQuality * 0.4) + 
                   flatnessWeight * flatness + 
                   fertilityWeight * fertility;

      // Debug: Log some sample scores
      if (Math.random() < 0.01) { // Log 1% of cells for debugging
        console.log(`Cell ${cell.index} CAPITAL scores - River: ${riverProximity.toFixed(2)}, Coast: ${coastProximity.toFixed(2)}, Harbor: ${harborQuality.toFixed(2)}, Flat: ${flatness.toFixed(2)}, Fert: ${fertility.toFixed(2)}, Total: ${score.toFixed(2)}`);
      }

      return Math.max(0, Math.min(1, score));
    }

    /**
     * Score a cell for town placement (including road access bonus)
     * @param {Object} cell - The cell to score
     * @param {Array} cells - All cells array
     * @param {number} sea - Sea level
     * @param {Array} capitals - Array of capital burgs
     * @returns {number} Score between 0 and 1
     */
    function scoreCellForTown(cell, cells, sea, capitals) {
      const riverWeight = +document.getElementById('riverWeightInput').value || 0.4;
      const coastWeight = +document.getElementById('coastWeightInput').value || 0.3;
      const flatnessWeight = +document.getElementById('flatnessWeightInput').value || 0.2;
      const fertilityWeight = +document.getElementById('fertilityWeightInput').value || 0.1;
      const roadWeight = 0.3; // Bonus for road access

      // Skip water cells
      if (cell.high < sea) return 0;
      
      // Skip very high peaks (too steep for settlements)
      if (cell.high > 0.8) return 0;

      let riverProximity = 0;
      let coastProximity = 0;
      let flatness = 0;
      let fertility = 1; // Default fertility
      let roadAccess = 0;

      // Calculate river proximity (same as capitals)
      let riverNeighbors = 0;
      cell.neighbors.forEach(nb => {
        const neighborCell = cells[nb];
        const isWater = neighborCell.high < sea;
        const isLake = window.__state.isLake && window.__state.isLake[nb] === 1;
        if (isWater && !isLake) {
          riverNeighbors++;
        }
      });
      riverProximity = Math.min(1, riverNeighbors / cell.neighbors.length * 3);

      // Calculate coast proximity (simpler than capitals)
      let minWaterDist = Infinity;
      for (let i = 0; i < cells.length; i++) {
        if (cells[i].high < sea) {
          const dist = Math.hypot(cell.cx - cells[i].cx, cell.cy - cells[i].cy);
          minWaterDist = Math.min(minWaterDist, dist);
        }
      }
      coastProximity = Math.max(0, 1 - minWaterDist / 100);

      // Calculate flatness (same as capitals)
      let maxSlope = 0;
      cell.neighbors.forEach(nb => {
        const slope = Math.abs(cell.high - cells[nb].high);
        maxSlope = Math.max(maxSlope, slope);
      });
      flatness = Math.max(0, 1 - maxSlope * 5);

      // Calculate fertility (same as capitals)
      if (window.__state.precipArray) {
        fertility = Math.min(1, window.__state.precipArray[cell.index] || 0.5);
      }

      // Calculate road access bonus (distance to nearest capital road)
      let minRoadDist = Infinity;
      if (window.__state.capitalRoads && window.__state.capitalRoads.length > 0) {
        for (const road of window.__state.capitalRoads) {
          // Simple distance to road segment (could be improved with actual path distance)
          const dist = Math.hypot(cell.cx - road.x, cell.cy - road.y);
          minRoadDist = Math.min(minRoadDist, dist);
        }
        roadAccess = Math.max(0, 1 - minRoadDist / 200); // Bonus within 200px of roads
      }

      // Combine scores with weights (towns emphasize road access)
      const baseScore = riverWeight * riverProximity + 
                       coastWeight * coastProximity + 
                       flatnessWeight * flatness + 
                       fertilityWeight * fertility;
      
      const roadBonus = roadWeight * roadAccess;
      const score = baseScore + roadBonus;

      // Debug: Log some sample scores
      if (Math.random() < 0.01) { // Log 1% of cells for debugging
        console.log(`Cell ${cell.index} TOWN scores - River: ${riverProximity.toFixed(2)}, Coast: ${coastProximity.toFixed(2)}, Flat: ${flatness.toFixed(2)}, Fert: ${fertility.toFixed(2)}, Road: ${roadAccess.toFixed(2)}, Total: ${score.toFixed(2)}`);
      }

      return Math.max(0, Math.min(1, score));
    }

    /**
     * Poisson disk sampling for burg placement
     * @param {Array} candidates - Array of {cell, score} objects
     * @param {number} radiusPx - Minimum distance between burgs in pixels
     * @returns {Array} Spaced subset of candidates
     */
    function poissonSample(candidates, radiusPx) {
      const accepted = [];
      const rejected = [];
      
      // Sort by score (highest first)
      const sorted = candidates.sort((a, b) => b.score - a.score);
      
      for (const candidate of sorted) {
        let tooClose = false;
        
        // Check distance to all accepted burgs
        for (const acceptedBurg of accepted) {
          const dist = Math.hypot(
            candidate.cell.cx - acceptedBurg.cell.cx,
            candidate.cell.cy - acceptedBurg.cell.cy
          );
          if (dist < radiusPx) {
            tooClose = true;
            break;
          }
        }
        
        if (!tooClose) {
          accepted.push(candidate);
        } else {
          rejected.push(candidate);
        }
      }
      
      return accepted;
    }

    /**
     * Build roads between capitals (MST approach)
     * @param {Array} capitals - Array of capital burgs
     */
    function buildCapitalRoads(capitals) {
      if (capitals.length < 2) return;
      
      console.log(`Building capital road network for ${capitals.length} capitals`);
      
      // Create edges between all capital pairs
      const edges = [];
      for (let i = 0; i < capitals.length; i++) {
        for (let j = i + 1; j < capitals.length; j++) {
          const dist = Math.hypot(
            capitals[i].x - capitals[j].x,
            capitals[i].y - capitals[j].y
          );
          edges.push({
            a: i,
            b: j,
            cost: dist
          });
        }
      }
      
      // Sort edges by cost for Kruskal's algorithm
      edges.sort((a, b) => a.cost - b.cost);
      
      // Kruskal's algorithm for MST
      const parent = new Array(capitals.length).fill(0).map((_, i) => i);
      
      function find(x) {
        if (parent[x] !== x) {
          parent[x] = find(parent[x]);
        }
        return parent[x];
      }
      
      function union(x, y) {
        parent[find(x)] = find(y);
      }
      
      const mstEdges = [];
      for (const edge of edges) {
        if (find(edge.a) !== find(edge.b)) {
          union(edge.a, edge.b);
          mstEdges.push(edge);
        }
      }
      
      // Store capital roads for town scoring
      window.__state.capitalRoads = mstEdges.map(edge => ({
        x: (capitals[edge.a].x + capitals[edge.b].x) / 2,
        y: (capitals[edge.a].y + capitals[edge.b].y) / 2,
        a: edge.a,
        b: edge.b
      }));
      
      console.log(`Built ${mstEdges.length} capital roads`);
    }

    /**
     * Create a burg object from a cell
     * @param {Object} cell - The cell to place the burg on
     * @param {Array} cells - All cells array
     * @param {number} sea - Sea level
     * @param {number} index - Burg index
     * @param {string} type - Burg type ('capital', 'town', 'port')
     * @returns {Object} Burg object
     */
    function placeBurg(cell, cells, sea, index, type = 'town') {
      const id = index;
      
      // Determine if it's a port (near coast)
      let isPort = false;
      let minWaterDist = Infinity;
      for (let i = 0; i < cells.length; i++) {
        if (cells[i].high < sea) {
          const dist = Math.hypot(cell.cx - cells[i].cx, cell.cy - cells[i].cy);
          minWaterDist = Math.min(minWaterDist, dist);
        }
      }
      isPort = minWaterDist < 15; // Within 15px of water (more selective)
      
      // Debug: Log port detection for some burgs
      if (Math.random() < 0.1) { // Log 10% of burgs
        console.log(`Burg ${id} port detection: minWaterDist=${minWaterDist.toFixed(1)}px, isPort=${isPort}, type=${type}`);
      }

      // Determine if it's on a river
      let onRiver = false;
      cell.neighbors.forEach(nb => {
        const neighborCell = cells[nb];
        // Check if neighbor is water but not a lake
        const isWater = neighborCell.high < sea;
        const isLake = window.__state.isLake && window.__state.isLake[nb] === 1;
        if (isWater && !isLake) {
          onRiver = true;
        }
      });

      // Determine population based on type and features
      let population = 1000;
      
      if (type === 'capital') {
        population = 5000; // Capitals are larger
      } else if (isPort) {
        population = 2000; // Ports are prosperous
      } else if (onRiver) {
        population = 1500; // River towns are moderately prosperous
      }

      // Generate name
      const name = BURG_NAMES[id % BURG_NAMES.length] + (id > BURG_NAMES.length - 1 ? ` ${Math.floor(id / BURG_NAMES.length) + 1}` : '');

      return {
        id: id,
        x: cell.cx,
        y: cell.cy,
        cell: cell.index,
        cultureId: null, // Will be assigned in Regions phase
        countryId: null, // Will be assigned in Regions phase
        population: population,
        type: type,
        port: isPort,
        onRiver: onRiver,
        name: name
      };
    }

    /**
     * Generate burgs using Azgaar's economic approach
     */
    function generateBurgs() {
      const totalCount = +document.getElementById('burgsCountInput').value || 25;
      const capitalCount = Math.max(2, Math.floor(totalCount * 0.12)); // 12% capitals
      const cityCount = Math.floor(totalCount * 0.28); // 28% cities/ports
      const villageCount = totalCount - capitalCount - cityCount; // 60% villages
      const sea = +document.getElementById('seaLevelInput').value;
      const cells = window.__state.cells;
      
      console.log(`Generating ${capitalCount} capitals + ${cityCount} cities + ${villageCount} villages using economic approach`);
      
      // Update progress during burg generation
      ProgressManager.update(82, 'Placing settlements...', 'Scoring land cells for capitals...');

      // Get land cells (use same logic as water detection)
      const isWater = window.__state.isWater || [];
      const landCells = cells.filter((c, i) => !isWater[i] && c.high <= 0.8);
      console.log(`Found ${landCells.length} land cells suitable for burgs`);
      
      if (landCells.length === 0) {
        console.log('No suitable land cells for burgs');
        window.__state.burgs = [];
        renderBurgs();
        return;
      }

      // === PHASE 1: Place Capitals (keep existing approach for now) ===
      ProgressManager.update(83, 'Placing settlements...', 'Placing capital cities...');
      
      // Score all land cells for capitals (emphasize strategic locations)
      const capitalCandidates = landCells.map(cell => ({
        cell: cell,
        score: scoreCellForCapital(cell, cells, sea)
      }));

      // Filter out low-scoring cells
      const goodCapitalCandidates = capitalCandidates.filter(c => c.score > 0.15);
      console.log(`Found ${goodCapitalCandidates.length} cells with good capital scores (>0.15)`);
      
      if (goodCapitalCandidates.length === 0) {
        console.log('No suitable cells found for capitals');
        window.__state.burgs = [];
        renderBurgs();
        return;
      }

      // Apply Poisson disk sampling for capitals
      const capitalSpacing = +document.getElementById('burgSpacingInput').value * 2 || 24;
      const spacedCapitals = poissonSample(goodCapitalCandidates, capitalSpacing);
      console.log(`After capital spacing, ${spacedCapitals.length} candidates remain`);
      
      // Take top N capitals by score
      const pickedCapitals = spacedCapitals.slice(0, capitalCount);
      console.log(`Selected ${pickedCapitals.length} capitals from candidates`);
      
      // Create capital burg objects
      const capitals = pickedCapitals.map((p, index) => placeBurg(p.cell, cells, sea, index, 'capital'));
      
      // === PHASE 2: Build Roads First (for economic scoring) ===
      ProgressManager.update(84, 'Placing settlements...', 'Building road network for economic scoring...');
      
      // Build land graph and roads between capitals
      const landGraph = buildLandGraph(cells, isWater);
      window.__state.landGraph = landGraph; // Store for later use
      
      // Build roads between capitals (this will be used for town scoring)
      buildCapitalRoads(capitals);
      
      // === PHASE 3: Place Cities (coastal/river focused) ===
      ProgressManager.update(85, 'Placing settlements...', 'Placing cities with coastal/river focus...');
      
      // Generate cities using coastal/river economic scoring
      const cities = generateCities(cells, capitals, cityCount, null);
      
      // === PHASE 4: Place Villages (inland/road focused) ===
      ProgressManager.update(86, 'Placing settlements...', 'Placing villages with inland/road focus...');
      
      // Generate villages using inland/road economic scoring
      const villages = generateVillages(cells, [...capitals, ...cities], villageCount, null);
      
      // === PHASE 5: Add Spur Roads to Settlements ===
      ProgressManager.update(87, 'Placing settlements...', 'Adding spur roads to settlements...');
      
      // Add spur roads to cities and villages that aren't on existing routes
      [...cities, ...villages].forEach(settlement => {
        ensureSpurToRoad(settlement, isRouteCell, nearestRouteCell, addSpurRoad);
      });
      
      // Combine all settlement types
      window.__state.burgs = [...capitals, ...cities, ...villages];
      
      console.log(`Generated ${capitals.length} capitals + ${cities.length} cities + ${villages.length} villages = ${window.__state.burgs.length} total burgs`);
      
      // Debug: Log sample burgs
      if (capitals.length > 0) {
        console.log('Sample capital:', capitals[0]);
      }
      if (cities.length > 0) {
        console.log('Sample city:', cities[0]);
      }
      if (villages.length > 0) {
        console.log('Sample village:', villages[0]);
      }
      
      // Render the burgs
      renderBurgs();
    }

    /**
     * Render burgs using D3 data-join
     */
    function renderBurgs() {
      const burgsG = d3.select('#burgs');
      console.log(`Rendering ${window.__state.burgs ? window.__state.burgs.length : 0} burgs`);
      
      // Clear existing burgs
      burgsG.selectAll('*').remove();
      
      if (!window.__state.burgs || window.__state.burgs.length === 0) {
        console.log('No burgs to render');
        return;
      }

      // Create burg symbols
      const burgs = burgsG.selectAll('g.burg')
        .data(window.__state.burgs, d => d.id)
        .enter()
        .append('g')
        .attr('class', 'burg')
        .attr('data-burg-id', d => d.id);

      // Add circles for burg symbols with different styles per type
      burgs.append('circle')
        .attr('cx', d => d.x)
        .attr('cy', d => d.y)
        .attr('r', d => {
          if (d.type === 'capital') return 4; // Capitals are largest
          if (d.type === 'city') return 3.5; // Cities are large
          if (d.type === 'village') return 2.5; // Villages are smallest
          if (d.port) return 3; // Ports are medium (fallback)
          return 2.5; // Default size
        })
        .each(function(d) {
          // Debug: Log each burg's properties
          console.log(`Burg ${d.id}: type=${d.type}, port=${d.port}, x=${d.x}, y=${d.y}`);
          
          let color;
          if (d.type === 'capital') {
            color = '#ff0000'; // Red for capitals
          } else if (d.type === 'city') {
            color = '#0066cc'; // Blue for cities
          } else if (d.type === 'village') {
            color = '#ff6600'; // Orange for villages
          } else if (d.port) {
            color = '#0066cc'; // Blue for ports (fallback)
          } else {
            color = '#ff6600'; // Orange for towns (fallback)
          }
          
          console.log(`Burg ${d.id} assigned color: ${color}`);
          
          // Apply color directly
          d3.select(this)
            .style('fill', color)
            .attr('fill', color);
        })
        .attr('stroke', '#fff')
        .attr('stroke-width', d => {
          if (d.type === 'capital') return '1.0';
          if (d.type === 'city') return '0.8';
          return '0.6'; // Villages and others
        })
        .attr('paint-order', 'stroke fill')
        .attr('vector-effect', 'non-scaling-stroke');

      // Add special symbols for capitals (star)
      burgs.filter(d => d.type === 'capital')
        .append('text')
        .attr('x', d => d.x)
        .attr('y', d => d.y + 1)
        .attr('text-anchor', 'middle')
        .attr('dominant-baseline', 'middle')
        .attr('font-size', '6px')
        .attr('fill', '#fff')
        .attr('stroke', '#000')
        .attr('stroke-width', '0.5')
        .attr('paint-order', 'stroke fill')
        .attr('vector-effect', 'non-scaling-stroke')
        .text('★');

      // Add port symbols for ports (anchor) - cities and villages can be ports
      burgs.filter(d => d.port && d.type !== 'capital')
        .append('text')
        .attr('x', d => d.x)
        .attr('y', d => d.y + 1)
        .attr('text-anchor', 'middle')
        .attr('dominant-baseline', 'middle')
        .attr('font-size', d => d.type === 'city' ? '4px' : '3px')
        .attr('fill', '#fff')
        .attr('stroke', '#000')
        .attr('stroke-width', '0.3')
        .attr('paint-order', 'stroke fill')
        .attr('vector-effect', 'non-scaling-stroke')
        .text('⚓');

      console.log(`Rendered ${window.__state.burgs.length} burgs`);
      
      // Debug: Log burg types and colors
      if (window.__state.burgs && window.__state.burgs.length > 0) {
        console.log('Burg types:', window.__state.burgs.map(b => ({ id: b.id, type: b.type, port: b.port, isPort: b.isPort, x: b.x, y: b.y })));
        console.log('First few burgs:', window.__state.burgs.slice(0, 3));
        
        // Debug: Check what colors are actually applied to DOM elements
        const burgCircles = document.querySelectorAll('#burgs circle');
        console.log('Burg circles found:', burgCircles.length);
        if (burgCircles.length > 0) {
          console.log('First circle fill:', burgCircles[0].getAttribute('fill'), burgCircles[0].style.fill);
        }
      }
    }

    // --- Azgaar-Style Economic Town Placement ---
    
    // Town placement weights (configurable)
    const TOWN_WEIGHTS = {
      wElev:  1.0,     // penalty for elevation
      wRiver: 0.18,    // bonus ~ river flux
      wHarbor: 0.8,    // bonus for sheltered coast
      wPath:  0.65,    // bonus for road usage (sqrt)
      wCross: 0.9,     // bonus for crossroads (deg-1)
      wNearRoad: 0.0,  // (optional) small penalty by distance to nearest road
      jitter: 0.05     // % noise of total score
    };

    // City weights - focused on coastal/river access and trade
    const CITY_WEIGHTS = {
      wElev:  0.8,     // less penalty for elevation (cities can be on hills)
      wRiver: 0.4,     // strong bonus for rivers (trade routes)
      wHarbor: 1.2,    // very strong bonus for harbors (trade)
      wCoast: 0.6,     // bonus for coastal access
      wPath:  0.4,     // moderate bonus for road usage
      wCross: 0.7,     // moderate bonus for crossroads
      wNearRoad: 0.0,  // no penalty for distance to roads
      jitter: 0.03     // less randomness for cities
    };

    // Village weights - focused on inland development and agriculture
    const VILLAGE_WEIGHTS = {
      wElev:  1.2,     // strong penalty for elevation (villages prefer flat land)
      wRiver: 0.15,    // moderate bonus for rivers (water source)
      wHarbor: 0.0,    // no bonus for harbors (inland)
      wCoast: 0.0,     // no bonus for coast (inland)
      wPath:  0.8,     // strong bonus for road usage (connectivity)
      wCross: 1.1,     // strong bonus for crossroads (trade)
      wFlat:  0.9,     // bonus for flat land (agriculture)
      wNearRoad: 0.1,  // small penalty for being far from roads
      jitter: 0.08     // more randomness for villages
    };

    /**
     * Build road usage data for economic scoring
     * @param {Object} routeData - Object containing routes and trails arrays
     * @param {Array} cells - All cells array
     */
    function buildRoadUsage(routeData, cells) {
      // Zero out road usage data
      for (const c of cells) { 
        c.path = 0; 
        c.cross = 0; 
      }
      
      // Count how many times each cell appears in any land route
      const touchBy = new Map(); // cellId -> Set(cellId neighbors touched by a route)
      
      const bump = (id, nextId) => {
        if (id == null) return;
        cells[id].path++;
        if (nextId != null) {
          let S = touchBy.get(id);
          if (!S) { S = new Set(); touchBy.set(id, S); }
          S.add(nextId);
        }
      };

      const visit = (segments) => {
        for (const seg of segments) {
          // seg should be an array of cell indices along the path (inclusive)
          for (let i = 0; i < seg.length; i++) {
            bump(seg[i], seg[i+1]);
            bump(seg[i], seg[i-1]);
          }
        }
      };

      visit(routeData.routes || []);
      visit(routeData.trails || []);

      // crossroads = number of *distinct* neighbors a route touches from this cell
      for (const [id, set] of touchBy.entries()) {
        cells[id].cross = set.size; // deg along route network
      }
      
      console.log(`Road usage built: ${cells.filter(c => c.path > 0).length} cells have road usage`);
    }

    /**
     * Calculate geographic score for a cell
     * @param {Object} c - Cell object
     * @returns {number} Geographic score
     */
    function geographicScore(c) {
      const elevP = Math.max(0, 1 - c.high);         // lowland best
      const riverB = Math.sqrt(Math.max(0, c.riverFlux || 0));
      const harborB = c.hasHarbor ? 1 : 0;
      return TOWN_WEIGHTS.wElev * elevP
           + TOWN_WEIGHTS.wRiver * riverB
           + TOWN_WEIGHTS.wHarbor * harborB;
    }

    /**
     * Calculate city geographic score (coastal/river focused)
     * @param {Object} c - Cell object
     * @param {Array} cells - All cells array
     * @param {Array} isWater - Water mask array
     * @returns {number} City geographic score
     */
    function cityGeographicScore(c, cells, isWater) {
      const elevP = Math.max(0, 1 - c.high);         // lowland preferred
      const riverB = Math.sqrt(Math.max(0, c.riverFlux || 0));
      const harborB = c.hasHarbor ? 1 : 0;
      
      // Calculate coastal access
      let coastB = 0;
      let minWaterDist = Infinity;
      for (let i = 0; i < cells.length; i++) {
        if (isWater[i]) {
          const dist = Math.hypot(c.cx - cells[i].cx, c.cy - cells[i].cy);
          minWaterDist = Math.min(minWaterDist, dist);
        }
      }
      if (minWaterDist < 50) { // Within 50px of water
        coastB = Math.max(0, 1 - (minWaterDist / 50));
      }
      
      return CITY_WEIGHTS.wElev * elevP
           + CITY_WEIGHTS.wRiver * riverB
           + CITY_WEIGHTS.wHarbor * harborB
           + CITY_WEIGHTS.wCoast * coastB;
    }

    /**
     * Calculate village geographic score (inland/agriculture focused)
     * @param {Object} c - Cell object
     * @param {Array} cells - All cells array
     * @param {Array} isWater - Water mask array
     * @returns {number} Village geographic score
     */
    function villageGeographicScore(c, cells, isWater) {
      const elevP = Math.max(0, 1 - c.high);         // flat land preferred
      const riverB = Math.sqrt(Math.max(0, c.riverFlux || 0));
      const flatB = Math.max(0, 1 - c.high);         // flat land bonus for agriculture
      
      // Calculate distance to nearest road for penalty
      let nearRoadDist = 0;
      if (VILLAGE_WEIGHTS.wNearRoad > 0) {
        // Simple distance calculation - could be optimized
        let minRoadDist = Infinity;
        for (let i = 0; i < cells.length; i++) {
          if ((cells[i].path || 0) > 0) {
            const dist = Math.hypot(c.cx - cells[i].cx, c.cy - cells[i].cy);
            minRoadDist = Math.min(minRoadDist, dist);
          }
        }
        nearRoadDist = minRoadDist < Infinity ? minRoadDist : 100; // Default penalty if no roads
      }
      
      return VILLAGE_WEIGHTS.wElev * elevP
           + VILLAGE_WEIGHTS.wRiver * riverB
           + VILLAGE_WEIGHTS.wFlat * flatB
           - VILLAGE_WEIGHTS.wNearRoad * nearRoadDist;
    }

    /**
     * Calculate economic score for a cell
     * @param {Object} c - Cell object
     * @param {number} nearestRoadDist - Distance to nearest road (optional)
     * @returns {number} Economic score
     */
    function economicScore(c, nearestRoadDist = 0) {
      const pathB = Math.sqrt(c.path || 0);
      const crossB = Math.max(0, (c.cross || 0) - 1);
      const nearRoadPenalty = (TOWN_WEIGHTS.wNearRoad > 0) ? (nearestRoadDist * TOWN_WEIGHTS.wNearRoad) : 0;
      return TOWN_WEIGHTS.wPath * pathB
           + TOWN_WEIGHTS.wCross * crossB
           - nearRoadPenalty;
    }

    /**
     * Calculate city economic score (trade focused)
     * @param {Object} c - Cell object
     * @returns {number} City economic score
     */
    function cityEconomicScore(c) {
      const pathB = Math.sqrt(c.path || 0);
      const crossB = Math.max(0, (c.cross || 0) - 1);
      return CITY_WEIGHTS.wPath * pathB
           + CITY_WEIGHTS.wCross * crossB;
    }

    /**
     * Calculate village economic score (connectivity focused)
     * @param {Object} c - Cell object
     * @returns {number} Village economic score
     */
    function villageEconomicScore(c) {
      const pathB = Math.sqrt(c.path || 0);
      const crossB = Math.max(0, (c.cross || 0) - 1);
      return VILLAGE_WEIGHTS.wPath * pathB
           + VILLAGE_WEIGHTS.wCross * crossB;
    }

    /**
     * Add random jitter to scores
     * @param {number} base - Base score
     * @returns {number} Score with jitter
     */
    function randomJitter(base) {
      const j = TOWN_WEIGHTS.jitter;
      return base * ((Math.random() * 2 * j) - j); // ±j%
    }

    /**
     * Add random jitter to city scores
     * @param {number} base - Base score
     * @returns {number} Score with jitter
     */
    function cityRandomJitter(base) {
      const j = CITY_WEIGHTS.jitter;
      return base * ((Math.random() * 2 * j) - j); // ±j%
    }

    /**
     * Add random jitter to village scores
     * @param {number} base - Base score
     * @returns {number} Score with jitter
     */
    function villageRandomJitter(base) {
      const j = VILLAGE_WEIGHTS.jitter;
      return base * ((Math.random() * 2 * j) - j); // ±j%
    }

    /**
     * Generate cities using coastal/river economic approach
     * @param {Array} cells - All cells array
     * @param {Array} capitals - Array of capital burgs
     * @param {number} targetCityCount - Number of cities to generate
     * @param {Function} nameFor - Name generation function
     * @returns {Array} Array of city burgs
     */
    function generateCities(cells, capitals, targetCityCount, nameFor) {
      const sea = +document.getElementById('seaLevelInput').value;
      const isWater = window.__state.isWater || [];
      
      // Mark capitals + neighbors as reserved
      const used = new Uint8Array(cells.length);
      for (const cap of capitals) {
        used[cap.cell] = 1;
        for (const n of cells[cap.cell].neighbors) used[n] = 1;
      }

      // Score all land cells for cities
      const scored = [];
      for (let i = 0; i < cells.length; i++) {
        const c = cells[i];
        if (isWater[i] || used[i]) continue;
        
        const geoScore = cityGeographicScore(c, cells, isWater);
        const econScore = cityEconomicScore(c);
        const base = geoScore + econScore;
        const score = base + cityRandomJitter(base);
        scored.push({i, score});
      }

      scored.sort((a, b) => b.score - a.score);

      const cities = [];
      for (const s of scored) {
        if (cities.length >= targetCityCount) break;
        if (used[s.i]) continue;
        const c = cells[s.i];
        if (isWater[s.i]) continue;

        // Place city (burg)
        const city = {
          cell: s.i,
          x: c.cx, 
          y: c.cy,
          type: "city",
          name: nameFor ? nameFor(c) : null,
          id: capitals.length + cities.length,
          population: 2000,
          port: false,
          onRiver: false
        };
        
        // Determine if it's a port (near coast)
        let minWaterDist = Infinity;
        for (let i = 0; i < cells.length; i++) {
          if (isWater[i]) {
            const dist = Math.hypot(c.cx - cells[i].cx, c.cy - cells[i].cy);
            minWaterDist = Math.min(minWaterDist, dist);
          }
        }
        city.port = minWaterDist < 25; // Within 25px of water
        
        // Determine if it's on a river
        c.neighbors.forEach(nb => {
          const neighborCell = cells[nb];
          const isWaterNeighbor = isWater[nb];
          const isLake = window.__state.isLake && window.__state.isLake[nb] === 1;
          if (isWaterNeighbor && !isLake) {
            city.onRiver = true;
          }
        });

        // Generate name if not provided
        if (!city.name) {
          city.name = BURG_NAMES[city.id % BURG_NAMES.length] + 
                     (city.id > BURG_NAMES.length - 1 ? ` ${Math.floor(city.id / BURG_NAMES.length) + 1}` : '');
        }

        cities.push(city);

        // Block this cell + neighbors
        used[s.i] = 1;
        for (const n of c.neighbors) used[n] = 1;
      }

      console.log(`Generated ${cities.length} cities using coastal/river economic scoring`);
      return cities;
    }

    /**
     * Generate villages using inland/road economic approach
     * @param {Array} cells - All cells array
     * @param {Array} existingBurgs - Array of existing burgs (capitals + cities)
     * @param {number} targetVillageCount - Number of villages to generate
     * @param {Function} nameFor - Name generation function
     * @returns {Array} Array of village burgs
     */
    function generateVillages(cells, existingBurgs, targetVillageCount, nameFor) {
      const sea = +document.getElementById('seaLevelInput').value;
      const isWater = window.__state.isWater || [];
      
      // Mark existing burgs + neighbors as reserved
      const used = new Uint8Array(cells.length);
      for (const burg of existingBurgs) {
        used[burg.cell] = 1;
        for (const n of cells[burg.cell].neighbors) used[n] = 1;
      }

      // Score all land cells for villages
      const scored = [];
      for (let i = 0; i < cells.length; i++) {
        const c = cells[i];
        if (isWater[i] || used[i]) continue;
        
        const geoScore = villageGeographicScore(c, cells, isWater);
        const econScore = villageEconomicScore(c);
        const base = geoScore + econScore;
        const score = base + villageRandomJitter(base);
        scored.push({i, score});
      }

      scored.sort((a, b) => b.score - a.score);

      const villages = [];
      for (const s of scored) {
        if (villages.length >= targetVillageCount) break;
        if (used[s.i]) continue;
        const c = cells[s.i];
        if (isWater[s.i]) continue;

        // Place village (burg)
        const village = {
          cell: s.i,
          x: c.cx, 
          y: c.cy,
          type: "village",
          name: nameFor ? nameFor(c) : null,
          id: existingBurgs.length + villages.length,
          population: 500,
          port: false,
          onRiver: false
        };
        
        // Determine if it's a port (near coast) - less likely for villages
        let minWaterDist = Infinity;
        for (let i = 0; i < cells.length; i++) {
          if (isWater[i]) {
            const dist = Math.hypot(c.cx - cells[i].cx, c.cy - cells[i].cy);
            minWaterDist = Math.min(minWaterDist, dist);
          }
        }
        village.port = minWaterDist < 10; // Only very close to water
        
        // Determine if it's on a river
        c.neighbors.forEach(nb => {
          const neighborCell = cells[nb];
          const isWaterNeighbor = isWater[nb];
          const isLake = window.__state.isLake && window.__state.isLake[nb] === 1;
          if (isWaterNeighbor && !isLake) {
            village.onRiver = true;
          }
        });

        // Generate name if not provided
        if (!village.name) {
          village.name = BURG_NAMES[village.id % BURG_NAMES.length] + 
                        (village.id > BURG_NAMES.length - 1 ? ` ${Math.floor(village.id / BURG_NAMES.length) + 1}` : '');
        }

        villages.push(village);

        // Block this cell + neighbors
        used[s.i] = 1;
        for (const n of c.neighbors) used[n] = 1;
      }

      console.log(`Generated ${villages.length} villages using inland/road economic scoring`);
      return villages;
    }

    /**
     * Generate towns using Azgaar's economic approach
     * @param {Array} cells - All cells array
     * @param {Array} capitals - Array of capital burgs
     * @param {number} targetTownCount - Number of towns to generate
     * @param {Function} nameFor - Name generation function
     * @returns {Array} Array of town burgs
     */
    function generateTowns(cells, capitals, targetTownCount, nameFor) {
      const sea = +document.getElementById('seaLevelInput').value;
      const isWater = window.__state.isWater || [];
      
      // Mark capitals + neighbors as reserved
      const used = new Uint8Array(cells.length);
      for (const cap of capitals) {
        used[cap.cell] = 1;
        for (const n of cells[cap.cell].neighbors) used[n] = 1;
      }

      // Score all land cells
      const scored = [];
      for (let i = 0; i < cells.length; i++) {
        const c = cells[i];
        if (isWater[i] || used[i]) continue;
        
        const base = (c.geoScore ?? geographicScore(c)) + economicScore(c, 0);
        const score = base + randomJitter(base);
        scored.push({i, score});
      }

      scored.sort((a, b) => b.score - a.score);

      const towns = [];
      for (const s of scored) {
        if (towns.length >= targetTownCount) break;
        if (used[s.i]) continue;
        const c = cells[s.i];
        if (isWater[s.i]) continue;

        // Place town (burg)
        const town = {
          cell: s.i,
          x: c.cx, 
          y: c.cy,
          type: "town",
          name: nameFor ? nameFor(c) : null,
          id: capitals.length + towns.length,
          population: 1000,
          port: false,
          onRiver: false
        };
        
        // Determine if it's a port (near coast)
        let minWaterDist = Infinity;
        for (let i = 0; i < cells.length; i++) {
          if (isWater[i]) {
            const dist = Math.hypot(c.cx - cells[i].cx, c.cy - cells[i].cy);
            minWaterDist = Math.min(minWaterDist, dist);
          }
        }
        town.port = minWaterDist < 15; // Within 15px of water
        
        // Determine if it's on a river
        c.neighbors.forEach(nb => {
          const neighborCell = cells[nb];
          const isWaterNeighbor = isWater[nb];
          const isLake = window.__state.isLake && window.__state.isLake[nb] === 1;
          if (isWaterNeighbor && !isLake) {
            town.onRiver = true;
          }
        });

        // Generate name if not provided
        if (!town.name) {
          town.name = BURG_NAMES[town.id % BURG_NAMES.length] + 
                     (town.id > BURG_NAMES.length - 1 ? ` ${Math.floor(town.id / BURG_NAMES.length) + 1}` : '');
        }

        towns.push(town);

        // Block this cell + neighbors
        used[s.i] = 1;
        for (const n of c.neighbors) used[n] = 1;
      }

      console.log(`Generated ${towns.length} towns using economic scoring`);
      return towns;
    }

    /**
     * Ensure towns have spur roads to the network
     * @param {Object} town - Town burg object
     * @param {Function} isRouteCell - Function to check if cell is on a route
     * @param {Function} nearestRouteCellFn - Function to find nearest route cell
     * @param {Function} addRoadPathFn - Function to add road path
     */
    function ensureSpurToRoad(town, isRouteCell, nearestRouteCellFn, addRoadPathFn) {
      const id = town.cell;
      if (isRouteCell(id)) return;
      
      const toId = nearestRouteCellFn(id);
      if (toId == null) return;
      
      const landGraph = window.__state.landGraph;
      if (!landGraph) return;
      
      const pathCells = shortestPath(id, toId, landGraph, new Set(), new Set());
      if (pathCells && pathCells.length) {
        addRoadPathFn(pathCells, {kind: "spur"});
      }
    }

    /**
     * Check if a cell is on a route
     * @param {number} cellId - Cell index
     * @returns {boolean} True if cell is on a route
     */
    function isRouteCell(cellId) {
      const cells = window.__state.cells;
      if (!cells || !cells[cellId]) return false;
      return (cells[cellId].path || 0) > 0;
    }

    /**
     * Find nearest cell that's on a route
     * @param {number} cellId - Starting cell index
     * @returns {number|null} Nearest route cell index or null
     */
    function nearestRouteCell(cellId) {
      const cells = window.__state.cells;
      if (!cells || !cells[cellId]) return null;
      
      // Simple BFS to find nearest route cell
      const visited = new Set();
      const queue = [{cell: cellId, dist: 0}];
      
      while (queue.length > 0) {
        const {cell, dist} = queue.shift();
        if (visited.has(cell)) continue;
        visited.add(cell);
        
        if (isRouteCell(cell)) {
          return cell;
        }
        
        // Add neighbors to queue
        const cellObj = cells[cell];
        if (cellObj && cellObj.neighbors) {
          for (const neighbor of cellObj.neighbors) {
            if (!visited.has(neighbor)) {
              queue.push({cell: neighbor, dist: dist + 1});
            }
          }
        }
      }
      
      return null;
    }

    /**
     * Add a spur road path
     * @param {Array} pathCells - Array of cell indices forming the path
     * @param {Object} options - Path options
     */
    function addSpurRoad(pathCells, options) {
      if (!pathCells || pathCells.length < 2) return;
      
      const cells = window.__state.cells;
      const points = pathCells.map(cellId => [cells[cellId].cx, cells[cellId].cy]);
      
      const line = d3.line().x(d => d[0]).y(d => d[1]).curve(d3.curveBasis);
      const smoothed = smoothLine(points, 1);
      
      // Add to trails (spurs are local connections)
      const trailsG = d3.select('#routes .trails');
      trailsG.append('path')
        .attr('d', line(smoothed))
        .attr('fill', 'none')
        .attr('stroke', '#9b7b3a')
        .attr('stroke-width', '0.8px')
        .attr('stroke-dasharray', '2 2')
        .attr('stroke-linecap', 'round')
        .attr('stroke-linejoin', 'round')
        .attr('vector-effect', 'non-scaling-stroke');
      
      console.log(`Added spur road with ${pathCells.length} cells`);
    }

    // --- Routes System ---
    
    /**
     * Build a navigation graph over land cells
     * @param {Array} cells - All cells array
     * @param {Array} isWater - Water mask array
     * @returns {Object} Graph with nodes and edges
     */
    function buildLandGraph(cells, isWater) {
      const nodes = [];
      const edges = [];
      
      // Create nodes for all land cells
      for (let i = 0; i < cells.length; i++) {
        if (!isWater[i]) {
          nodes.push({ i: i, x: cells[i].cx, y: cells[i].cy, high: cells[i].high });
        }
      }
      
      // Create edges between neighboring land cells
      for (let i = 0; i < cells.length; i++) {
        if (isWater[i]) continue; // Skip water cells
        
        const cell = cells[i];
        for (const neighborIndex of cell.neighbors) {
          if (neighborIndex > i && !isWater[neighborIndex]) { // Avoid duplicate edges
            const neighbor = cells[neighborIndex];
            const dist = Math.hypot(cell.cx - neighbor.cx, cell.cy - neighbor.cy);
            const slope = Math.abs(cell.high - neighbor.high);
            const riverCross = crossesRiverSegment(cell, neighbor) ? 1 : 0;
            
            const slopePenalty = +document.getElementById('slopePenaltyInput').value || 1.2;
            const riverPenalty = +document.getElementById('riverPenaltyInput').value || 1.0;
            
            const w = dist * (1 + slope * slopePenalty + riverCross * riverPenalty);
            
            edges.push({
              a: i,
              b: neighborIndex,
              dist: dist,
              slope: slope,
              riverCross: riverCross,
              w: w
            });
          }
        }
      }
      return { nodes, edges };
    }
    
    /**
     * Check if a path crosses a river segment
     * @param {Object} cellA - First cell
     * @param {Object} cellB - Second cell
     * @returns {boolean} True if path crosses a river
     */
    function crossesRiverSegment(cellA, cellB) {
      // Simple check: if either cell has a river neighbor, consider it a crossing
      const isWater = window.__state.isWater || [];
      const isLake = window.__state.isLake || [];
      
      // Check if either cell has a river neighbor (water but not lake)
      for (const cell of [cellA, cellB]) {
        for (const nb of cell.neighbors) {
          const neighborCell = window.__state.cells[nb];
          if (neighborCell) {
            const isWaterNeighbor = neighborCell.high < (+document.getElementById('seaLevelInput').value || 0.35);
            const isLakeNeighbor = isLake[nb] === 1;
            if (isWaterNeighbor && !isLakeNeighbor) {
              return true;
            }
          }
        }
      }
      
      return false;
    }
    
    /**
     * A* pathfinding algorithm for land navigation using edge weights
     * @param {number} startIndex - Starting cell index
     * @param {number} endIndex - Ending cell index
     * @param {Object} graph - Land graph
     * @param {Set} usedEdges - Set of already-used edges for road reuse discount
     * @param {Set} burgCells - Set of burg cell indices for pass-through bonus
     * @returns {Array} Path as array of cell indices
     */
    function shortestPath(startIndex, endIndex, graph, usedEdges = new Set(), burgCells = new Set()) {
      const cells = window.__state.cells;
      const isWater = window.__state.isWater || [];
      
      // Skip if start or end is water
      if (isWater[startIndex] || isWater[endIndex]) {
        console.log(`shortestPath: start or end is water (start: ${isWater[startIndex]}, end: ${isWater[endIndex]})`);
        return null;
      }
      
      // Check if start and end are the same
      if (startIndex === endIndex) {
        console.log(`shortestPath: start and end are the same (${startIndex})`);
        return [startIndex];
      }
      
      // Create edge lookup map for fast access
      const edgeMap = new Map();
      for (const edge of graph.edges) {
        const key = `${Math.min(edge.a, edge.b)}-${Math.max(edge.a, edge.b)}`;
        edgeMap.set(key, edge);
      }
      
      // A* implementation
      const openSet = new Set([startIndex]);
      const cameFrom = new Map();
      const gScore = new Map();
      const fScore = new Map();
      
      gScore.set(startIndex, 0);
      fScore.set(startIndex, heuristic(startIndex, endIndex, cells));
      
      let iterations = 0;
      const maxIterations = 10000; // Prevent infinite loops
      
      while (openSet.size > 0 && iterations < maxIterations) {
        iterations++;
        
        // Find node with lowest fScore
        let current = null;
        let lowestF = Infinity;
        for (const node of openSet) {
          const f = fScore.get(node) || Infinity;
          if (f < lowestF) {
            lowestF = f;
            current = node;
          }
        }
        
        if (current === endIndex) {
          // Reconstruct path
          const path = [];
          while (current !== undefined) {
            path.unshift(current);
            current = cameFrom.get(current);
          }
          console.log(`A* found path in ${iterations} iterations`);
          return path;
        }
        
        openSet.delete(current);
        
        // Check neighbors
        const currentCell = cells[current];
        for (const neighborIndex of currentCell.neighbors) {
          if (isWater[neighborIndex]) continue; // Skip water neighbors
          
          // Calculate edge cost using stored weights
          const edgeKey = `${Math.min(current, neighborIndex)}-${Math.max(current, neighborIndex)}`;
          const edge = edgeMap.get(edgeKey);
          let tentativeG = gScore.get(current) || Infinity;
          
          if (edge) {
            // Use the precomputed edge weight
            let cost = edge.w;
            
            // Apply existing road discount if this edge was already used
            if (usedEdges.has(edgeKey)) {
              cost *= 0.15; // Azgaar's existing road discount
            }
            
            // Apply burg pass-through bonus
            if (burgCells.has(neighborIndex)) {
              cost *= 0.85; // 15% discount for passing through burgs
            }
            
            tentativeG += cost;
          } else {
            // Fallback to Euclidean distance if edge not found
            const dist = Math.hypot(
              currentCell.cx - cells[neighborIndex].cx,
              currentCell.cy - cells[neighborIndex].cy
            );
            tentativeG += dist;
          }
          
          const neighborG = gScore.get(neighborIndex) || Infinity;
          if (tentativeG < neighborG) {
            cameFrom.set(neighborIndex, current);
            gScore.set(neighborIndex, tentativeG);
            fScore.set(neighborIndex, tentativeG + heuristic(neighborIndex, endIndex, cells));
            
            // Always add to open set if we found a better path
            openSet.add(neighborIndex);
          }
        }
      }
      
      console.log(`A* failed after ${iterations} iterations, falling back to BFS`);
      
      // Fallback to simple BFS if A* fails
      const visited = new Set();
      const queue = [[startIndex, [startIndex]]];
      visited.add(startIndex);
      
      while (queue.length > 0) {
        const [current, path] = queue.shift();
        
        if (current === endIndex) {
          console.log(`BFS fallback found path`);
          return path;
        }
        
        // Check neighbors
        const currentCell = cells[current];
        for (const neighborIndex of currentCell.neighbors) {
          if (visited.has(neighborIndex)) continue;
          if (isWater[neighborIndex]) continue; // Skip water neighbors
          
          visited.add(neighborIndex);
          queue.push([neighborIndex, [...path, neighborIndex]]);
        }
      }
      
      return null; // No path found
    }
    
    /**
     * Heuristic function for A* (Euclidean distance)
     * @param {number} a - Cell index
     * @param {number} b - Cell index  
     * @param {Array} cells - All cells array
     * @returns {number} Heuristic value
     */
    function heuristic(a, b, cells) {
      return Math.hypot(cells[a].cx - cells[b].cx, cells[a].cy - cells[b].cy);
    }
    
    /**
     * Calculate the total cost of a path using edge weights from land graph
     * @param {Array} path - Array of cell indices
     * @param {Object} landGraph - Land graph with edges
     * @returns {number} Total path cost
     */
    function calculatePathCost(path, landGraph) {
      if (path.length < 2) return 0;
      
      // Create edge lookup map
      const edgeMap = new Map();
      for (const edge of landGraph.edges) {
        const key = `${Math.min(edge.a, edge.b)}-${Math.max(edge.a, edge.b)}`;
        edgeMap.set(key, edge);
      }
      
      let totalCost = 0;
      for (let i = 1; i < path.length; i++) {
        const prev = path[i - 1];
        const curr = path[i];
        const edgeKey = `${Math.min(prev, curr)}-${Math.max(prev, curr)}`;
        const edge = edgeMap.get(edgeKey);
        
        if (edge) {
          totalCost += edge.w; // Use precomputed edge weight
        } else {
          // Fallback to Euclidean distance
          const prevCell = window.__state.cells[prev];
          const currCell = window.__state.cells[curr];
          totalCost += Math.hypot(prevCell.cx - currCell.cx, prevCell.cy - currCell.cy);
        }
      }
      
      return totalCost;
    }
    
    /**
     * Mark all edges in a path as used for road reuse discount
     * @param {Array} path - Array of cell indices
     * @param {Set} usedEdges - Set to track used edges
     */
    function markPathEdgesAsUsed(path, usedEdges) {
      for (let i = 1; i < path.length; i++) {
        const prev = path[i - 1];
        const curr = path[i];
        const edgeKey = `${Math.min(prev, curr)}-${Math.max(prev, curr)}`;
        usedEdges.add(edgeKey);
      }
    }
    
    /**
     * Calculate the total cost of a sea path using edge weights from sea graph
     * @param {Array} path - Array of cell indices
     * @param {Object} seaGraph - Sea graph with edges
     * @returns {number} Total path cost
     */
    function calculateSeaPathCost(path, seaGraph) {
      if (path.length < 2) return 0;
      
      // Create edge lookup map
      const edgeMap = new Map();
      for (const edge of seaGraph.edges) {
        const key = `${Math.min(edge.a, edge.b)}-${Math.max(edge.a, edge.b)}`;
        edgeMap.set(key, edge);
      }
      
      let totalCost = 0;
      for (let i = 1; i < path.length; i++) {
        const prev = path[i - 1];
        const curr = path[i];
        const edgeKey = `${Math.min(prev, curr)}-${Math.max(prev, curr)}`;
        const edge = edgeMap.get(edgeKey);
        
        if (edge) {
          totalCost += edge.w; // Use precomputed edge weight with offshore bias
        } else {
          // Fallback to Euclidean distance
          const prevCell = window.__state.cells[prev];
          const currCell = window.__state.cells[curr];
          totalCost += Math.hypot(prevCell.cx - currCell.cx, prevCell.cy - currCell.cy);
        }
      }
      
      return totalCost;
    }
    
    /**
     * Optimized Dijkstra for sea navigation with edge reuse penalty
     * @param {number} startIndex - Starting cell index
     * @param {Object} graph - Sea graph
     * @param {Set} usedEdges - Set of already-used edges for penalty
     * @returns {Object} Map of node index to distance
     */
    function dijkstraSea(startIndex, graph, usedEdges = new Set()) {
      const cells = window.__state.cells;
      const isWater = window.__state.isWater || [];
      
      if (!isWater[startIndex]) {
        console.log(`dijkstraSea: start is not water (start: ${isWater[startIndex]})`);
        return {};
      }
      
      // Create edge lookup map for fast access
      const edgeMap = new Map();
      for (const edge of graph.edges) {
        const key = `${Math.min(edge.a, edge.b)}-${Math.max(edge.a, edge.b)}`;
        edgeMap.set(key, edge);
      }
      
      const distances = {};
      const visited = new Set();
      const queue = [{ node: startIndex, cost: 0 }];
      
      distances[startIndex] = 0;
      
      while (queue.length > 0) {
        // Sort by cost (could use priority queue for better performance)
        queue.sort((a, b) => a.cost - b.cost);
        const { node: current, cost: currentCost } = queue.shift();
        
        if (visited.has(current)) continue;
        visited.add(current);
        
        // Find all edges from current node
        for (const edge of graph.edges) {
          let nextIndex = null;
          if (edge.a === current) {
            nextIndex = edge.b;
          } else if (edge.b === current) {
            nextIndex = edge.a;
          }
          
          if (nextIndex === null || visited.has(nextIndex)) continue;
          
          // Calculate edge cost with reuse penalty
          const edgeKey = `${Math.min(current, nextIndex)}-${Math.max(current, nextIndex)}`;
          let edgeCost = edge.w;
          
          // Apply reuse penalty if edge was already used
          if (usedEdges.has(edgeKey)) {
            edgeCost *= 0.15; // Azgaar's existing lane discount
          } else {
            edgeCost *= 1.5; // New lane penalty
          }
          
          const newCost = currentCost + edgeCost;
          
          if (distances[nextIndex] === undefined || newCost < distances[nextIndex]) {
            distances[nextIndex] = newCost;
            queue.push({ node: nextIndex, cost: newCost });
          }
        }
      }
      
      return distances;
    }
    
    /**
     * Simple BFS pathfinding for sea navigation using the sea graph
     * @param {number} startIndex - Starting cell index
     * @param {number} endIndex - Ending cell index
     * @param {Object} graph - Sea graph
     * @returns {Array} Path as array of cell indices
     */
    function shortestPathSea(startIndex, endIndex, graph) {
      const cells = window.__state.cells;
      const isWater = window.__state.isWater || [];
      
      // Skip if start or end is not water
      if (!isWater[startIndex] || !isWater[endIndex]) {
        console.log(`shortestPathSea: start or end is not water (start: ${isWater[startIndex]}, end: ${isWater[endIndex]})`);
        return null;
      }
      
      // Check if start and end are the same
      if (startIndex === endIndex) {
        return [startIndex];
      }
      
      // Weighted BFS using sea graph edges with offshore bias
      const visited = new Set();
      const queue = [[startIndex, [startIndex], 0]]; // [current, path, cost]
      visited.add(startIndex);
      
      while (queue.length > 0) {
        // Sort queue by cost to prefer lower-cost (more offshore) paths
        queue.sort((a, b) => a[2] - b[2]);
        const [current, path, cost] = queue.shift();
        
        if (current === endIndex) {
          console.log(`shortestPathSea: found path with ${path.length} cells between ${startIndex} and ${endIndex}`);
          return path;
        }
        
        // Find all edges from current node in sea graph
        for (const edge of graph.edges) {
          let nextIndex = null;
          if (edge.a === current) {
            nextIndex = edge.b;
          } else if (edge.b === current) {
            nextIndex = edge.a;
          }
          
          if (nextIndex !== null && !visited.has(nextIndex)) {
            // Calculate cost based on distance and land proximity
            const nextCell = cells[nextIndex];
            let landProximity = 0;
            
            // Count land neighbors to bias away from coast
            for (const nb of nextCell.neighbors) {
              if (!isWater[nb]) {
                landProximity += 1;
              }
            }
            
            // Higher cost for cells near land (encourages offshore routes)
            const newCost = cost + edge.w + (landProximity * 10);
            
            visited.add(nextIndex);
            queue.push([nextIndex, [...path, nextIndex], newCost]);
          }
        }
      }
      
      console.log(`shortestPathSea: no path found between ${startIndex} and ${endIndex}`);
      return null; // No path found
    }
    
    /**
     * Heuristic function for A* (Euclidean distance)
     * @param {number} a - Cell index
     * @param {number} b - Cell index
     * @param {Array} cells - All cells array
     * @returns {number} Heuristic value
     */
    function heuristic(a, b, cells) {
      return Math.hypot(cells[a].cx - cells[b].cx, cells[a].cy - cells[b].cy);
    }
    
    /**
     * Convert path indices to polyline points
     * @param {Array} pathIndices - Array of cell indices
     * @returns {Array} Array of [x, y] points
     */
    function polylineFromPath(pathIndices) {
      const cells = window.__state.cells;
      return pathIndices.map(index => [cells[index].cx, cells[index].cy]);
    }
    
    /**
     * Smooth a polyline using Chaikin smoothing
     * @param {Array} points - Array of [x, y] points
     * @param {number} iterations - Number of smoothing iterations
     * @returns {Array} Smoothed polyline
     */
    function smoothLine(points, iterations = 1) {
      if (points.length < 3) return points;
      
      let smoothed = points;
      for (let iter = 0; iter < iterations; iter++) {
        const newPoints = [];
        for (let i = 0; i < smoothed.length - 1; i++) {
          const [x1, y1] = smoothed[i];
          const [x2, y2] = smoothed[i + 1];
          
          newPoints.push([x1, y1]);
          newPoints.push([(x1 + x2) / 2, (y1 + y2) / 2]);
        }
        newPoints.push(smoothed[smoothed.length - 1]);
        smoothed = newPoints;
      }
      
      return smoothed;
    }
    
    /**
     * Mark ports in burgs array
     * @param {Array} burgs - Burgs array
     * @param {Array} cells - All cells array
     * @param {Array} isWater - Water mask array
     */
    function markPorts(burgs, cells, isWater) {
      const sea = +document.getElementById('seaLevelInput').value;
      
      burgs.forEach(burg => {
        // Check if burg is near water (within 16 pixels)
        let minWaterDist = Infinity;
        for (let i = 0; i < cells.length; i++) {
          if (isWater[i]) {
            const dist = Math.hypot(burg.x - cells[i].cx, burg.y - cells[i].cy);
            minWaterDist = Math.min(minWaterDist, dist);
          }
        }
        
        const isPort = minWaterDist < 32; // Increased from 16 to 32 for better port detection
        burg.isPort = isPort;
        burg.port = isPort; // keep renderers and routers in sync
      });
    }
    
    /**
     * Find the nearest water cell to a given cell
     * @param {number} fromIndex - Starting cell index
     * @param {Array} isWater - Water mask array
     * @param {Array} cells - All cells array
     * @returns {number} Index of nearest water cell, or -1 if none found
     */
    function nearestWaterCellIndex(fromIndex, isWater, cells) {
      if (isWater[fromIndex]) return fromIndex;
      const visited = new Uint8Array(cells.length);
      const q = [fromIndex];
      visited[fromIndex] = 1;
      while (q.length) {
        const i = q.shift();
        for (const nb of cells[i].neighbors) {
          if (visited[nb]) continue;
          if (isWater[nb]) return nb;       // first water cell found
          visited[nb] = 1;
          q.push(nb);
        }
      }
      return -1; // none found (shouldn't happen on coastal ports)
    }
    

    
    /**
     * Helper function to get or create a group
     * @param {Object} parent - Parent D3 selection
     * @param {string} className - Class name for the group
     * @returns {Object} D3 selection for the group
     */
    function getOrCreateGroup(parent, className) {
      let group = parent.select(`.${className}`);
      if (group.size() === 0) {
        group = parent.append('g').attr('class', className);
      }
      return group;
    }
    
    /**
     * Find connected components of burgs using flood fill on land cells
     * @param {Array} burgs - Burgs array
     * @param {Object} landGraph - Land navigation graph
     * @returns {Array} Array of arrays, each containing connected burgs
     */
    function findConnectedComponents(burgs, landGraph) {
      if (burgs.length === 0) return [];
      
      const cells = window.__state.cells;
      const isWater = window.__state.isWater || [];
      
      // Create a map of burg cell indices to burg objects
      const burgByCell = new Map();
      burgs.forEach(burg => burgByCell.set(burg.cell, burg));
      
      const components = [];
      const visitedCells = new Set();
      const visitedBurgs = new Set();
      
      for (const burg of burgs) {
        if (visitedBurgs.has(burg.id)) continue;
        
        // Start a new component with this burg
        const component = [];
        const cellQueue = [burg.cell];
        visitedCells.add(burg.cell);
        visitedBurgs.add(burg.id);
        component.push(burg);
        
        // Flood fill from this burg's cell to find all connected land cells
        let floodSize = 0;
        while (cellQueue.length > 0) {
          const currentCellIndex = cellQueue.shift();
          const currentCell = cells[currentCellIndex];
          floodSize++;
          
          // Check all neighbors of this cell
          for (const neighborIndex of currentCell.neighbors) {
            if (visitedCells.has(neighborIndex)) continue;
            if (isWater[neighborIndex]) continue; // Skip water cells
            
            visitedCells.add(neighborIndex);
            cellQueue.push(neighborIndex);
            
            // If there's a burg on this cell, add it to the component
            const neighborBurg = burgByCell.get(neighborIndex);
            if (neighborBurg && !visitedBurgs.has(neighborBurg.id)) {
              visitedBurgs.add(neighborBurg.id);
              component.push(neighborBurg);
              console.log(`Flood found burg ${neighborBurg.id} at cell ${neighborIndex}`);
            }
          }
        }
        console.log(`Flood from burg ${burg.id} (cell ${burg.cell}) explored ${floodSize} cells, found ${component.length} burgs`);
        
        components.push(component);
      }
      
      console.log(`findConnectedComponents: found ${components.length} connected components:`, 
        components.map(c => c.length));
      
      // Debug: show which burgs are in which component
      components.forEach((component, i) => {
        console.log(`Component ${i}:`, component.map(b => `burg ${b.id} (cell ${b.cell})`));
      });
      
      // Debug: show burg positions to verify they're on different landmasses
      console.log('Burg positions:', burgs.map(b => ({ id: b.id, cell: b.cell, x: cells[b.cell].cx, y: cells[b.cell].cy })));
      
      return components;
    }
    
    /**
     * Build primary road network (MST between major burgs)
     * @param {Array} burgs - Burgs array
     * @param {Object} landGraph - Land navigation graph
     */
    function buildBackboneRoads(burgs, landGraph) {
      if (burgs.length < 2) return [];
      
      const roadDensity = +document.getElementById('roadDensityInput').value || 0.6;
      const hubCount = Math.max(2, Math.round(burgs.length * (0.35 + 0.5 * roadDensity)));
      
      // Create sets for tracking used edges and burg cells
      const usedEdges = new Set();
      const burgCells = new Set(burgs.map(b => b.cell));
      
      // Collect all route segments for road usage tracking
      const allRouteSegments = [];
      
      // Group burgs by connected components
      const components = findConnectedComponents(burgs, landGraph);
      console.log(`Found ${components.length} connected land components`);
      
      // Build roads within each component
      components.forEach((componentBurgs, componentIndex) => {
        console.log(`Processing component ${componentIndex} with ${componentBurgs.length} burgs`);
        if (componentBurgs.length < 2) {
          console.log(`Component ${componentIndex} has < 2 burgs, skipping`);
          return;
        }
        
        // Select hubs within this component
        const componentHubs = componentBurgs
          .sort((a, b) => b.population - a.population)
          .slice(0, Math.max(2, Math.round(componentBurgs.length * 0.6)));
        
        console.log(`Component ${componentIndex}: selected ${componentHubs.length} hubs from ${componentBurgs.length} burgs`);
        
        // Build complete graph of hub-to-hub path costs within component
        const hubEdges = [];
        
        console.log(`Component ${componentIndex}: building ${componentHubs.length * (componentHubs.length - 1) / 2} potential hub connections`);
        
        for (let i = 0; i < componentHubs.length; i++) {
          for (let j = i + 1; j < componentHubs.length; j++) {
            console.log(`Trying path from hub ${i} (cell ${componentHubs[i].cell}) to hub ${j} (cell ${componentHubs[j].cell})`);
            const path = shortestPath(componentHubs[i].cell, componentHubs[j].cell, landGraph, usedEdges, burgCells);
            if (path) {
              console.log(`Found path: ${path.length} cells`);
              
              // Calculate weighted cost using edge weights from land graph
              const cost = calculatePathCost(path, landGraph);
              hubEdges.push({ a: i, b: j, cost: cost, path: path });
            } else {
              console.log(`Component ${componentIndex}: no path between hubs ${i} and ${j} (cells ${componentHubs[i].cell} and ${componentHubs[j].cell})`);
            }
          }
        }
        
        console.log(`Component ${componentIndex}: found ${hubEdges.length} valid hub connections`);
        
        // Sort edges by cost for Kruskal's algorithm
        hubEdges.sort((a, b) => a.cost - b.cost);
        
        // Kruskal's algorithm for MST within component
        const parent = new Array(componentHubs.length).fill(0).map((_, i) => i);
        
        function find(x) {
          if (parent[x] !== x) {
            parent[x] = find(parent[x]);
          }
          return parent[x];
        }
        
        function union(x, y) {
          parent[find(x)] = find(y);
        }
        
        const mstEdges = [];
        for (const edge of hubEdges) {
          if (find(edge.a) !== find(edge.b)) {
            union(edge.a, edge.b);
            mstEdges.push(edge);
          }
        }
        
        // Render MST edges as roads and mark used edges
        const roadsG = d3.select('#routes .roads');
        const line = d3.line().x(d => d[0]).y(d => d[1]).curve(d3.curveBasis);
        
        // Collect all road paths first and mark used edges
        const roadPaths = mstEdges.map(edge => {
          // Mark edges as used for future pathfinding
          markPathEdgesAsUsed(edge.path, usedEdges);
          
          // Add to route segments for road usage tracking
          allRouteSegments.push(edge.path);
          
          const points = polylineFromPath(edge.path);
          const smoothed = smoothLine(points, 1);
          return {
            d: line(smoothed),
            fill: 'none',
            stroke: '#6b4e16',
            'stroke-width': '1.5px',
            'stroke-linecap': 'round',
            'stroke-linejoin': 'round',
            'vector-effect': 'non-scaling-stroke'
          };
        });
        
        // Batch add all paths at once
        roadsG.selectAll('path')
          .data(roadPaths)
          .enter()
          .append('path')
          .each(function(d) {
            Object.entries(d).forEach(([attr, value]) => {
              d3.select(this).attr(attr, value);
            });
          });
        
        console.log(`Component ${componentIndex}: ${mstEdges.length} roads between ${componentHubs.length} hubs`);
      });
      
      return allRouteSegments;
    }
    
    /**
     * Build local trail network
     * @param {Array} burgs - Burgs array
     * @param {Object} landGraph - Land navigation graph
     */
    function buildLocalTrails(burgs, landGraph) {
      if (burgs.length < 2) return [];
      
      const trailDensity = +document.getElementById('trailDensityInput').value || 0.5;
      const maxDistance = 160 + (trailDensity * 80); // 160-240px range
      const maxConnections = Math.max(1, Math.round(1 + trailDensity * 2)); // 1-3 connections
      
      // Create sets for tracking used edges and burg cells
      const usedEdges = new Set();
      const burgCells = new Set(burgs.map(b => b.cell));
      
      const line = d3.line().x(d => d[0]).y(d => d[1]).curve(d3.curveBasis);
      const existingTrails = [];
      const trailPaths = [];
      const allTrailSegments = [];
      
      // Group burgs by connected components
      const components = findConnectedComponents(burgs, landGraph);
      
      // Build trails within each component
      components.forEach((componentBurgs, componentIndex) => {
        console.log(`Building trails for component ${componentIndex} with ${componentBurgs.length} burgs`);
        if (componentBurgs.length < 2) {
          console.log(`Component ${componentIndex} has < 2 burgs, skipping trails`);
          return;
        }
        
        componentBurgs.forEach(burg => {
          // Find nearby burgs within max distance (only within same component)
          const nearby = componentBurgs
            .filter(other => other !== burg)
            .map(other => ({
              burg: other,
              dist: Math.hypot(burg.x - other.x, burg.y - other.y)
            }))
            .filter(item => item.dist <= maxDistance)
            .sort((a, b) => a.dist - b.dist)
            .slice(0, maxConnections);
          
          console.log(`Burg ${burg.id} (cell ${burg.cell}): found ${nearby.length} nearby burgs within ${maxDistance}px`);
        
          nearby.forEach(item => {
            const path = shortestPath(burg.cell, item.burg.cell, landGraph, usedEdges, burgCells);
            if (path) {
              const points = polylineFromPath(path);
              const smoothed = smoothLine(points, 1);
              
              // Check for overlap with existing trails (simple bounding box check)
              const trailKey = [Math.min(burg.cell, item.burg.cell), Math.max(burg.cell, item.burg.cell)].join('-');
              if (!existingTrails.includes(trailKey)) {
                existingTrails.push(trailKey);
                
                // Add to trail segments for road usage tracking
                allTrailSegments.push(path);
                
                // Collect trail path data instead of adding immediately
                trailPaths.push({
                  d: line(smoothed),
                  fill: 'none',
                  stroke: '#9b7b3a',
                  'stroke-width': '1px',
                  'stroke-dasharray': '3 3',
                  'stroke-linecap': 'round',
                  'stroke-linejoin': 'round',
                  'vector-effect': 'non-scaling-stroke'
                });
              }
            }
          });
        });
        
        console.log(`Component ${componentIndex}: ${existingTrails.length} trails built`);
      });
      
      // Batch add all trail paths at once
      const trailsG = d3.select('#routes .trails');
      trailsG.selectAll('path')
        .data(trailPaths)
        .enter()
        .append('path')
        .each(function(d) {
          Object.entries(d).forEach(([attr, value]) => {
            d3.select(this).attr(attr, value);
          });
        });
      
      console.log(`Total trails built: ${existingTrails.length}`);
      
      return allTrailSegments;
    }
    
    /**
     * Build sea navigation graph
     * @param {Array} cells - All cells array
     * @param {Array} isWater - Water mask array
     * @returns {Object} Sea navigation graph
     */
    function buildSeaGraph(cells, isWater) {
      const nodes = [];
      const edges = [];
      
      // Create nodes for all water cells
      for (let i = 0; i < cells.length; i++) {
        if (isWater[i]) {
          nodes.push({ i: i, x: cells[i].cx, y: cells[i].cy });
        }
      }
      
      console.log(`buildSeaGraph: created ${nodes.length} water nodes`);
      
      // Create edges between neighboring water cells
      for (let i = 0; i < cells.length; i++) {
        if (!isWater[i]) continue; // Skip land cells
        
        const cell = cells[i];
        for (const neighborIndex of cell.neighbors) {
          if (neighborIndex > i && isWater[neighborIndex]) { // Avoid duplicate edges
            const neighbor = cells[neighborIndex];
            const dist = Math.hypot(cell.cx - neighbor.cx, cell.cy - neighbor.cy);
            
            // Add small penalty near land to bias routes offshore
            let landPenalty = 0;
            for (const nb of [cell, neighbor]) {
              for (const nbIndex of nb.neighbors) {
                if (!isWater[nbIndex]) {
                  landPenalty += 0.1;
                  break;
                }
              }
            }
            
            const w = dist * (1 + landPenalty);
            edges.push({ a: i, b: neighborIndex, dist: dist, w: w });
          }
        }
      }
      
      console.log(`buildSeaGraph: created ${edges.length} water edges`);
      return { nodes, edges };
    }
    
    /**
     * Disjoint Set Union (DSU) for tracking connected components
     */
    class DSU {
      constructor(n) {
        this.p = [...Array(n).keys()];
        this.r = Array(n).fill(0);
      }
      
      find(x) {
        return this.p[x] === x ? x : this.p[x] = this.find(this.p[x]);
      }
      
      union(a, b) {
        a = this.find(a);
        b = this.find(b);
        if (a === b) return false;
        if (this.r[a] < this.r[b]) [a, b] = [b, a];
        this.p[b] = a;
        if (this.r[a] === this.r[b]) this.r[a]++;
        return true;
      }
    }
    
    /**
     * Connect sea network ensuring all ports are connected
     * @param {Array} ports - Array of port objects with cell indices
     * @param {Array} mstEdges - MST edges from Kruskal
     * @param {Function} oceanPath - Function to find ocean path between two cells
     * @returns {Array} Array of path segments to render
     */
    function connectSeaNetwork(ports, mstEdges, oceanPath) {
      const n = ports.length;
      const dsu = new DSU(n);
      const segments = [];
      
      // 1) Add MST edges (when path exists)
      for (const [i, j] of mstEdges) {
        const path = oceanPath(ports[i].cell, ports[j].cell);
        if (path && path.length) {
          segments.push(path);
          dsu.union(i, j);
        }
      }
      
      // 2) Force-connect any remaining components
      const root0 = dsu.find(0);
      for (let u = 0; u < n; u++) {
        if (dsu.find(u) === root0) continue;
        
        // Find nearest port in the main component by euclidean distance
        let bestV = -1, bestD = Infinity;
        for (let v = 0; v < n; v++) {
          if (dsu.find(v) === root0) {
            const dx = ports[u].x - ports[v].x;
            const dy = ports[u].y - ports[v].y;
            const d = dx * dx + dy * dy;
            if (d < bestD) {
              bestD = d;
              bestV = v;
            }
          }
        }
        
        const path = oceanPath(ports[u].cell, ports[bestV].cell);
        if (path && path.length) {
          segments.push(path);
          dsu.union(u, bestV);
        }
      }
      
      return segments;
    }
    
    /**
     * Build sea route backbone using Azgaar-style single-source approach
     * @param {Array} portBurgs - Array of port burgs
     * @param {Object} seaGraph - Sea navigation graph
     * @param {Object} landGraph - Land navigation graph
     */
    function buildSeaBackbone(portBurgs, seaGraph, landGraph) {
      if (portBurgs.length < 2) return;
      const cells = window.__state.cells;
      const isWater = window.__state.isWater;

      // 1) Group ports by island (land component)
      const islandGroups = findConnectedComponents(portBurgs, landGraph);
      console.log(`Found ${islandGroups.length} island groups for sea routing`);
      
      // 2) Map ports to nearest water cells and ensure all islands have sea access
      const portsWithSeaIndex = portBurgs
        .map(p => ({
          ...p,
          seaIndex: nearestWaterCellIndex(p.cell, isWater, cells)
        }))
        .filter(p => p.seaIndex >= 0);
      
      // Ensure every island has at least one port with sea access
      const islandsWithSeaAccess = new Set();
      islandGroups.forEach((islandPorts, islandId) => {
        const hasSeaAccess = islandPorts.some(p => 
          portsWithSeaIndex.some(ps => ps.id === p.id)
        );
        if (hasSeaAccess) {
          islandsWithSeaAccess.add(islandId);
        } else {
          console.warn(`Island ${islandId} has no ports with sea access!`);
        }
      });
      
      console.log(`Islands with sea access: ${islandsWithSeaAccess.size}/${islandGroups.length}`);
      
      // 3) Build island-level distance tables using single-source Dijkstra
      const islandDistances = new Map(); // islandId -> { hubPort, distances }
      const usedEdges = new Set(); // Track used edges for penalty
      
      islandGroups.forEach((islandPorts, islandId) => {
        if (islandPorts.length === 0 || !islandsWithSeaAccess.has(islandId)) return;
        
        // Pick hub port (first port with sea access)
        const hubPort = islandPorts.find(p => {
          const portWithSea = portsWithSeaIndex.find(ps => ps.id === p.id);
          return portWithSea && portWithSea.seaIndex >= 0;
        });
        
        if (!hubPort) return;
        
        const hubSeaIndex = portsWithSeaIndex.find(ps => ps.id === hubPort.id).seaIndex;
        
        // Run single-source Dijkstra from hub
        const distances = dijkstraSea(hubSeaIndex, seaGraph, usedEdges);
        
        islandDistances.set(islandId, {
          hubPort,
          hubSeaIndex,
          distances
        });
        
        console.log(`Island ${islandId}: hub at port ${hubPort.id}, computed distances to ${Object.keys(distances).length} ocean nodes`);
      });
      
      // 4) Build inter-island connections
      const islandConnections = [];
      
      // Find largest island (most ports) that has sea access
      const largestIslandId = islandGroups.reduce((max, ports, id) => {
        if (!islandsWithSeaAccess.has(id)) return max;
        if (!islandsWithSeaAccess.has(max)) return id;
        return ports.length > islandGroups[max]?.length ? id : max;
      }, 0);
      
      const largestIsland = islandDistances.get(largestIslandId);
      if (!largestIsland) {
        console.warn('No largest island with sea access found!');
        return;
      }
      
      console.log(`Largest island: ${largestIslandId} with ${islandGroups[largestIslandId].length} ports`);
      
      // Connect each island to largest island
      islandGroups.forEach((islandPorts, islandId) => {
        if (islandId === largestIslandId || islandPorts.length === 0 || !islandsWithSeaAccess.has(islandId)) return;
        
        const islandData = islandDistances.get(islandId);
        if (!islandData) {
          console.warn(`Island ${islandId} has no distance data despite having sea access!`);
          return;
        }
        
        // Find best connection to largest island
        let bestConnection = null;
        let bestCost = Infinity;
        
        islandPorts.forEach(port => {
          const portWithSea = portsWithSeaIndex.find(ps => ps.id === port.id);
          if (!portWithSea) return;
          
          const cost = islandData.distances[portWithSea.seaIndex] || Infinity;
          if (cost < bestCost) {
            bestCost = cost;
            bestConnection = {
              fromIsland: islandId,
              fromPort: port,
              fromSeaIndex: portWithSea.seaIndex,
              toIsland: largestIslandId,
              cost: cost
            };
          }
        });
        
        if (bestConnection && bestCost < Infinity) {
          islandConnections.push(bestConnection);
          console.log(`Connected island ${islandId} to largest island ${largestIslandId} with cost ${bestCost.toFixed(1)}`);
        } else {
          console.warn(`Failed to connect island ${islandId} to largest island ${largestIslandId}`);
        }
      });
      
      // 5) Add optional connections between big islands (≥4 ports)
      const bigIslands = islandGroups
        .map((ports, id) => ({ id, portCount: ports.length }))
        .filter(island => island.portCount >= 4 && island.id !== largestIslandId);
      
      bigIslands.forEach(island => {
        const islandData = islandDistances.get(island.id);
        if (!islandData) return;
        
        // Find best connection to largest island (already computed above)
        const existingConnection = islandConnections.find(conn => conn.fromIsland === island.id);
        if (existingConnection) {
          // Add one more connection to another big island if beneficial
          bigIslands.forEach(otherIsland => {
            if (otherIsland.id <= island.id) return; // Avoid duplicates
            
            const otherData = islandDistances.get(otherIsland.id);
            if (!otherData) return;
            
            // Simple heuristic: connect if both islands are big and close
            const distance = Math.hypot(
              islandData.hubPort.x - otherData.hubPort.x,
              islandData.hubPort.y - otherData.hubPort.y
            );
            
            if (distance < 300) { // Threshold for big island connections
              islandConnections.push({
                fromIsland: island.id,
                fromPort: islandData.hubPort,
                fromSeaIndex: islandData.hubSeaIndex,
                toIsland: otherIsland.id,
                cost: distance
              });
            }
          });
        }
      });
      
      // 6) Render connections
      const seaG = d3.select('#routes .searoutes');
      const line = d3.line().x(d => d[0]).y(d => d[1]).curve(d3.curveBasis);
      
      islandConnections.forEach(connection => {
        // Find path from source to target
        const targetPort = islandGroups[connection.toIsland]?.[0];
        if (!targetPort) return;
        
        const targetWithSea = portsWithSeaIndex.find(ps => ps.id === targetPort.id);
        if (!targetWithSea) return;
        
        const path = shortestPathSea(connection.fromSeaIndex, targetWithSea.seaIndex, seaGraph);
        if (path) {
          const points = polylineFromPath(path);
          const smoothed = smoothLine(points, 1);
          
          seaG.append('path')
            .attr('d', line(smoothed))
            .attr('fill', 'none')
            .attr('stroke', '#cfe9ff')
            .attr('stroke-width', '1.2px')
            .attr('stroke-dasharray', '6 4')
            .attr('stroke-linecap', 'round')
            .attr('stroke-linejoin', 'round')
            .attr('opacity', '0.9')
            .attr('vector-effect', 'non-scaling-stroke');
        }
      });
      
             // 7) Gap patcher: add direct routes for islands with poor connectivity
       const gapPatches = [];
       
       islandGroups.forEach((islandPorts, islandId) => {
         if (islandPorts.length < 2 || !islandsWithSeaAccess.has(islandId)) return;
         
         const islandData = islandDistances.get(islandId);
         if (!islandData) return;
         
         // Find the farthest port on this island
         let farthestPort = null;
         let maxDistance = 0;
         
         islandPorts.forEach(port => {
           const portWithSea = portsWithSeaIndex.find(ps => ps.id === port.id);
           if (!portWithSea) return;
           
           const distance = islandData.distances[portWithSea.seaIndex] || 0;
           if (distance > maxDistance) {
             maxDistance = distance;
             farthestPort = port;
           }
         });
         
         if (!farthestPort) return;
         
         // Check if the farthest port has poor connectivity via existing routes
         const farthestWithSea = portsWithSeaIndex.find(ps => ps.id === farthestPort.id);
         if (!farthestWithSea) return;
         
         // Find the cost to reach other ports via existing routes vs direct
         islandPorts.forEach(otherPort => {
           if (otherPort.id === farthestPort.id) return;
           
           const otherWithSea = portsWithSeaIndex.find(ps => ps.id === otherPort.id);
           if (!otherWithSea) return;
           
           const viaExistingCost = islandData.distances[farthestWithSea.seaIndex] + 
                                 islandData.distances[otherWithSea.seaIndex];
           const directCost = Math.hypot(
             farthestPort.x - otherPort.x,
             farthestPort.y - otherPort.y
           );
           
           // More aggressive gap patching: add if detour is ≥3× direct route (was 4×)
           if (viaExistingCost >= 3 * directCost) {
             gapPatches.push({
               fromPort: farthestPort,
               fromSeaIndex: farthestWithSea.seaIndex,
               toPort: otherPort,
               toSeaIndex: otherWithSea.seaIndex,
               cost: directCost
             });
             console.log(`Added gap patch on island ${islandId}: ${farthestPort.id} to ${otherPort.id} (detour ${viaExistingCost.toFixed(1)} vs direct ${directCost.toFixed(1)})`);
           }
         });
       });
       
       // 8) Ensure all islands with sea access are connected (fallback)
       const connectedIslands = new Set([largestIslandId]);
       islandConnections.forEach(conn => connectedIslands.add(conn.fromIsland));
       
       const unconnectedIslands = Array.from(islandsWithSeaAccess).filter(id => !connectedIslands.has(id));
       if (unconnectedIslands.length > 0) {
         console.warn(`Found ${unconnectedIslands.length} unconnected islands:`, unconnectedIslands);
         
         // Force connect unconnected islands to largest island
         unconnectedIslands.forEach(islandId => {
           const islandPorts = islandGroups[islandId];
           const islandData = islandDistances.get(islandId);
           
           if (!islandData || islandPorts.length === 0) return;
           
           // Find any port with sea access
           const anyPort = islandPorts.find(port => {
             const portWithSea = portsWithSeaIndex.find(ps => ps.id === port.id);
             return portWithSea && portWithSea.seaIndex >= 0;
           });
           
           if (anyPort) {
             const portWithSea = portsWithSeaIndex.find(ps => ps.id === anyPort.id);
             console.log(`Force connecting unconnected island ${islandId} via port ${anyPort.id}`);
             
             // Add a direct connection to largest island
             const targetPort = islandGroups[largestIslandId]?.[0];
             if (targetPort) {
               const targetWithSea = portsWithSeaIndex.find(ps => ps.id === targetPort.id);
               if (targetWithSea) {
                 gapPatches.push({
                   fromPort: anyPort,
                   fromSeaIndex: portWithSea.seaIndex,
                   toPort: targetPort,
                   toSeaIndex: targetWithSea.seaIndex,
                   cost: Math.hypot(anyPort.x - targetPort.x, anyPort.y - targetPort.y)
                 });
               }
             }
           }
         });
       }
       
       // Render gap patches
       gapPatches.forEach(patch => {
         const path = shortestPathSea(patch.fromSeaIndex, patch.toSeaIndex, seaGraph);
         if (path) {
           const points = polylineFromPath(path);
           const smoothed = smoothLine(points, 1);
           
           seaG.append('path')
             .attr('d', line(smoothed))
             .attr('fill', 'none')
             .attr('stroke', '#cfe9ff')
             .attr('stroke-width', '1.0px')
             .attr('stroke-dasharray', '3 3')
             .attr('stroke-linecap', 'round')
             .attr('stroke-linejoin', 'round')
             .attr('opacity', '0.7')
             .attr('vector-effect', 'non-scaling-stroke');
         }
       });
       
       console.log(`Built ${islandConnections.length} inter-island sea connections + ${gapPatches.length} gap patches`);
     }
    
    // Guard against multiple simultaneous executions
    let isComputingRoutes = false;
    
    /**
     * Main routes computation function
     */
    function computeRoutes() {
      // Prevent multiple simultaneous executions
      if (isComputingRoutes) {
        console.log('computeRoutes already running, skipping...');
        return;
      }
      
      isComputingRoutes = true;
      
      try {
        // Guard against calling before water mask exists
        if (!window.__state.isWater) {
          const sea = +DOM.seaLevelInput.value;
          computeLakes(sea);
        }
      
      // Update progress during route computation
      ProgressManager.update(92, 'Building routes...', 'Computing land networks...');
      
      // Use centralized route layers
      const roadsG = RouteLayers.roads;
      const trailsG = RouteLayers.trails;
      const seaG = RouteLayers.sea;
      
      // Incremental updates - only rebuild what's dirty
      if (RouteDirty.burgs || RouteDirty.landGraph) {
        roadsG.selectAll('path').remove();
        trailsG.selectAll('path').remove();
      }
      if (RouteDirty.sea) {
        seaG.selectAll('path').remove();
      }
      
      const cells = window.__state.cells;
      const isWater = window.__state.isWater;
      const burgs = window.__state.burgs || [];
      
      if (!cells || !isWater || burgs.length < 2) {
        return;
      }
      
      const landGraph = buildLandGraph(cells, isWater);
      
      // Debug: Check if we have enough data
      if (DEBUG) {
        console.log('burgs', burgs.length);
        console.log('land edges', landGraph.edges.length);
      }
      
      markPorts(burgs, cells, isWater);
      
      // Collect route data for economic town placement
      const routeData = { routes: [], trails: [] };
      
      // Build primary roads (only if enabled)
      if (document.getElementById('roadsOnInput') && document.getElementById('roadsOnInput').checked) {
        ProgressManager.update(93, 'Building routes...', 'Computing primary roads...');
        
        // Add timeout to prevent hanging on roads computation
        const roadsTimeout = setTimeout(() => {
          console.warn('Roads computation taking too long, skipping...');
          return;
        }, 5000); // 5 second timeout
        
        try {
          routeData.routes = buildBackboneRoads(burgs, landGraph);
        } finally {
          clearTimeout(roadsTimeout);
        }
      }
      
      // Build local trails (only if enabled)
      if (document.getElementById('trailsOnInput') && document.getElementById('trailsOnInput').checked) {
        ProgressManager.update(94, 'Building routes...', 'Computing local trails...');
        
        // Add timeout to prevent hanging on trails computation
        const trailsTimeout = setTimeout(() => {
          console.warn('Trails computation taking too long, skipping...');
          return;
        }, 5000); // 5 second timeout
        
        try {
          routeData.trails = buildLocalTrails(burgs, landGraph);
        } finally {
          clearTimeout(trailsTimeout);
        }
      }
      
      // Build road usage data for economic town placement
      if (routeData.routes.length > 0 || routeData.trails.length > 0) {
        buildRoadUsage(routeData, cells);
      }
      
      // Build sea routes if enabled
      if (DOM.seaRoutesOnInput.checked) {
        ProgressManager.update(95, 'Building routes...', 'Computing sea networks...');
        if (DEBUG) console.log('Sea routes enabled, building sea graph...');
        
        const seaRouteStart = performance.now();
        
        // Add timeout to prevent hanging
        const seaRouteTimeout = setTimeout(() => {
          console.warn('Sea route computation taking too long, skipping...');
          return;
        }, 10000); // 10 second timeout
        
        try {
          const seaGraph = buildSeaGraph(cells, isWater);
          if (DEBUG) console.log(`Sea graph: ${seaGraph.nodes.length} nodes, ${seaGraph.edges.length} edges`);
          
          const portBurgs = burgs.filter(b => b.isPort || b.port);
          if (DEBUG) console.log(`Found ${portBurgs.length} port burgs:`, portBurgs.map(p => ({ id: p.id, cell: p.cell, name: p.name })));
          
          if (portBurgs.length >= 2) {
            // Group ports by landmass component for better sea route planning
            const components = findConnectedComponents(burgs, landGraph);
            const portComponents = components.map(component => 
              component.filter(burg => burg.isPort || burg.port)
            ).filter(ports => ports.length > 0);
            
            if (DEBUG) console.log(`Port components:`, portComponents.map(ports => ports.length));
            
            // Build sea routes between different landmasses
            buildSeaBackbone(portBurgs, seaGraph, landGraph);
            
            const seaRouteTime = performance.now() - seaRouteStart;
            console.log(`Sea routes built in ${seaRouteTime.toFixed(1)}ms`);
          } else {
            if (DEBUG) console.log('Not enough port burgs for sea routes (need >= 2)');
          }
        } finally {
          clearTimeout(seaRouteTimeout);
        }
      } else {
        if (DEBUG) console.log('Sea routes disabled');
      }
      
      // Remove any test/debug lines
      d3.select('#test-line, #debug-line, .test-line, .debug-line').remove();
      
      // Debug: Check what was actually rendered
      if (DEBUG) {
        console.log('roads:', document.querySelectorAll('#routes .roads path').length);
        console.log('trails:', document.querySelectorAll('#routes .trails path').length);
        console.log('sea:', document.querySelectorAll('#routes .searoutes path').length);
      }
      
      // Optional: Add one-liner after rendering to confirm you drew something
      console.log('sea:', document.querySelectorAll('#routes .searoutes path').length);
      
      // Raise burgs above routes for crisp rendering
      d3.select('#burgs').raise();
      } catch (error) {
        console.error('Error in computeRoutes:', error);
      } finally {
        isComputingRoutes = false;
      }
    }

    // --- Test harness --- (kept original tests and added border checks)
    document.getElementById('runTests').addEventListener('click', runTests);

    function runTests() {
      const out = document.getElementById('testResults');
      out.innerHTML = '';

      function assert(name, condition) {
        const li = document.createElement('li');
        li.textContent = (condition ? '✓ ' : '✗ ') + name;
        li.className = condition ? 'pass' : 'fail';
        out.appendChild(li);
      }

      try {
        // Existing tests
        const n = sizeInput.valueAsNumber;
        const cellPaths = d3.selectAll('path.mapCell').size();
        assert('renders one SVG path per site', cellPaths === n);

        const st = window.__state;
        const mid = Math.floor(st.cells.length / 2);
        const beforeSeed = st.cells[mid].high;
        st.add(mid, 'island');
        const afterSeed = st.cells[mid].high;
        const neighborRaised = st.cells[st.cells[mid].neighbors[0]] ? (st.cells[st.cells[mid].neighbors[0]].high > 0) : true; // tolerate edge cases
        assert('add() increases height at the seed cell', afterSeed > beforeSeed);
        const allClamped = st.cells.every(c => c.high >= 0 && c.high <= 1);
        assert('all cell heights stay within [0, 1]', allClamped);
        assert('add() affects at least one neighbor', neighborRaised);

        // New tests
        // T4: autoSeed raises heights in many cells
        const raisedBefore = st.cells.filter(c => c.high > 0).length;
        st.autoSeed();
        const raisedAfter = st.cells.filter(c => c.high > 0).length;
        assert('autoSeed() raises heights in multiple cells', raisedAfter > raisedBefore + 5);

        // T5: sea level = 1.0 -> all water
        document.getElementById('seaLevelInput').value = 1.0; st.recolor();
        const waterAtMaxSea = st.cells.filter(c => c.high < 1.0).length;
        assert('sea level = 1.0 -> all water', waterAtMaxSea === st.cells.length);

        // T6: sea level = 0.0 -> all land
        document.getElementById('seaLevelInput').value = 0.0; st.recolor();
        const waterAtZeroSea = st.cells.filter(c => c.high < 0.0).length;
        assert('sea level = 0.0 -> all land', waterAtZeroSea === 0);

        // T7: default sea level (0.35) -> mix of land and water after autoSeed
        document.getElementById('seaLevelInput').value = 0.35; st.recolor();
        const water = st.cells.filter(c => c.high < 0.35).length;
        const land = st.cells.length - water;
        assert('sea level 0.35 -> mixed terrain', water > 0 && land > 0);

        // T8: Azgaar palette produces a gradient (many unique fills)
        const fills = new Set(Array.from(document.querySelectorAll('path.mapCell')).slice(0, 200).map(p => p.getAttribute('fill')));
        assert('Azgaar palette -> gradient (many unique fills)', fills.size > 5);

        // T9: Center area is significant after autoSeed (center-biased island)
        const svgSel = st.svg;
        const w = +svgSel.attr('width');
        const h = +svgSel.attr('height');
        const centerIdx = st.delaunay.find(w / 2, h / 2);
        assert('Center cell height is significant after autoSeed', st.cells[centerIdx].high > 0.4);

        // T10: Coastlines appear for mixed terrain
        st.recolor();
        const coastCount = d3.selectAll('g.coastline path.coast').size();
        assert('Coastlines are drawn when terrain is mixed', coastCount > 0);

        // T11: No coastlines when all water
        document.getElementById('seaLevelInput').value = 1.0; st.recolor();
        const coastAllWater = d3.selectAll('g.coastline path.coast').size();
        assert('No coastlines at sea level 1.0', coastAllWater === 0);

        // T12: No coastlines when all land
        document.getElementById('seaLevelInput').value = 0.0; st.recolor();
        const coastAllLand = d3.selectAll('g.coastline path.coast').size();
        assert('No coastlines at sea level 0.0', coastAllLand === 0);

        // T13: Border mask keeps a water frame around the map
        document.getElementById('seaLevelInput').value = 0.35; st.applyBorder(); st.recolor();
        const margin = st.borderPx * 0.9;
        const nearEdgeLand = st.cells.some(c => Math.min(c.cx, c.cy, w - c.cx, h - c.cy) < margin && c.high >= 0.35);
        assert('No land within the border margin', !nearEdgeLand);

        // T14: Water is a single uniform color below sea level
        document.getElementById('seaLevelInput').value = 0.5; st.recolor();
        const seaLvl = 0.5;
        const waterCells = st.cells.map((c,i)=>({i, h:c.high})).filter(o => o.h < seaLvl);
        let uniform = true;
        if (waterCells.length >= 2) {
          const getFill = (idx)=> (document.getElementById(String(idx))||{}).getAttribute ? document.getElementById(String(idx)).getAttribute('fill') : null;
          const first = getFill(waterCells[0].i);
          for (let k = 1; k < Math.min(200, waterCells.length); k++) {
            if (getFill(waterCells[k].i) !== first) { uniform = false; break; }
          }
        }
        assert('Water below sea level uses a uniform color', uniform);

        // T15: Low land near sea level should be greener than purple (G channel dominant)
        document.getElementById('seaLevelInput').value = 0.35; st.recolor();
        const seaLvl2 = 0.35;
        const nearShoreLand = st.cells.map((c,i)=>({i, h:c.high})).filter(o => o.h >= seaLvl2 && o.h < seaLvl2 + 0.03);
        function rgbParse(s){
          if(!s) return null; const i1=s.indexOf('('), i2=s.indexOf(')'); if(i1<0||i2<0) return null; const a=s.slice(i1+1,i2).split(',').map(x=>parseInt(x,10)); if(a.length<3) return null; return {r:a[0], g:a[1], b:a[2]};
        }
        let greenish = true;
        if (nearShoreLand.length){
          const idx = nearShoreLand[0].i; const fill = (document.getElementById(String(idx))||{}).getAttribute ? document.getElementById(String(idx)).getAttribute('fill') : null; const rgb = rgbParse(fill);
          greenish = !!rgb && (rgb.g > rgb.r && rgb.g > rgb.b);
        }
        assert('Low land near sea level is greenish', greenish);

        // T16: Highest peaks render light (snow‑capped), not dark
        document.getElementById('seaLevelInput').value = 0.35; st.recolor();
        const landCells = st.cells.map((c,i)=>({i, h:c.high})).filter(o=>o.h >= 0.35).sort((a,b)=>b.h-a.h);
        const top = landCells.slice(0, Math.max(1, Math.floor(landCells.length*0.01)));
        let snowOK = true;
        if (top.length){
          const getFill = (idx)=> (document.getElementById(String(idx))||{}).getAttribute ? document.getElementById(String(idx)).getAttribute('fill') : null;
          const lum = (s)=>{ if(!s) return 0; const i1=s.indexOf('('), i2=s.indexOf(')'); if(i1<0||i2<0) return 0; const a=s.slice(i1+1,i2).split(',').map(x=>parseInt(x,10)); if(a.length<3) return 0; const [r,g,b]=a.map(v=>{v/=255; return v<=0.03928? v/12.92 : Math.pow((v+0.055)/1.055,2.4);}); return 0.2126*r+0.7152*g+0.0722*b; };
          const lumVals = top.map(o=>lum(getFill(o.i))).filter(v=>!isNaN(v));
          const avgLum = lumVals.reduce((s,v)=>s+v,0)/lumVals.length;
          snowOK = avgLum > 0.75; // should be quite light
        }
        assert('High peaks are light (snow‑caps)', snowOK);

        // T17: No strokes on cells (fills meet with no borders)
        const anyStroked = Array.from(document.querySelectorAll('path.mapCell')).some(p => {
          const s = window.getComputedStyle(p);
          const sw = s.getPropertyValue('stroke-width');
          const stc = s.getPropertyValue('stroke');
          return (sw && sw !== '0px') && (stc && stc !== 'none' && stc !== 'rgba(0, 0, 0, 0)');
        });
        assert('Cells render without strokes/borders', !anyStroked);

        // T18: Rivers exist at default settings
        document.getElementById('seaLevelInput').value = 0.35; st.recolor();
        const riverCount = d3.selectAll('g.rivers path.rivers').size();
        assert('At least one river is drawn', riverCount > 0);

        // T19: No rivers when all water
        document.getElementById('seaLevelInput').value = 1.0; st.recolor();
        const riverNone = d3.selectAll('g.rivers path.rivers').size();
        assert('No rivers when map is all water', riverNone === 0);

        // T20: More rainfall -> more rivers
        document.getElementById('seaLevelInput').value = 0.35;
        document.getElementById('rainInput').value = 0.2; st.recolor();
        const riversLow = d3.selectAll('g.rivers path.rivers').size();
        document.getElementById('rainInput').value = 1.8; st.recolor();
        const riversHigh = d3.selectAll('g.rivers path.rivers').size();
        assert('Higher rainfall increases river count', riversHigh > riversLow);

        // T21: Higher river-density quantile -> fewer rivers
        document.getElementById('rainInput').value = 1.0;
        document.getElementById('riverDensityInput').value = 0.98; st.recolor();
        const riversDense = d3.selectAll('g.rivers path.rivers').size();
        document.getElementById('riverDensityInput').value = 0.85; st.recolor();
        const riversSparse = d3.selectAll('g.rivers path.rivers').size();
        assert('Lower threshold draws more rivers', riversSparse >= riversDense);

        // T22: Tributaries are drawn (in addition to main rivers)
        document.getElementById('seaLevelInput').value = 0.35;
        document.getElementById('rainInput').value = 1.4; st.recolor();
        const majors = d3.selectAll('g.rivers path.rivers.main').size();
        const tribs = d3.selectAll('g.rivers path.rivers.trib').size();
        assert('Tributaries are present', tribs > 0 && majors >= 5 && majors <= 15);

        // T23: Tributaries are thinner than mains (average width)
        function avgWidth(sel){ const arr = []; d3.selectAll(sel).each(function(){ const w = +this.getAttribute('stroke-width')||0; if (w>0) arr.push(w); }); return arr.length? (arr.reduce((a,b)=>a+b,0)/arr.length) : 0; }
        const avgMain = avgWidth('g.rivers path.rivers.main');
        const avgTrib = avgWidth('g.rivers path.rivers.trib');
        assert('Tributaries are thinner than main rivers', avgTrib > 0 && avgMain > 0 && avgTrib < avgMain);

        // T24: Rivers have visible tapering (variation in widths across segments)
        st.recolor();
        const widths = []; d3.selectAll('g.rivers path.rivers').each(function(){ const w = +this.getAttribute('stroke-width')||0; if (w>0) widths.push(w); });
        const minW = Math.min.apply(null, widths), maxW = Math.max.apply(null, widths);
        assert('River widths vary (tapering present)', widths.length>5 && maxW > minW * 1.3);

        // T25: At least one confluence exists at higher rain
        document.getElementById('rainInput').value = 1.6; st.recolor();
        const rs = window.__state.riverStats || {confluences:0};
        assert('Confluences detected (>=1)', rs.confluences >= 1);

        // T26: Most main rivers reach the ocean
        document.getElementById('rainInput').value = 1.2; st.recolor();
        const rs2 = window.__state.riverStats || {majorsDrawn:0, majorsReachedSea:0};
        const fracOcean = rs2.majorsDrawn ? (rs2.majorsReachedSea / rs2.majorsDrawn) : 0;
        assert('Major rivers: majority reach the ocean', rs2.majorsDrawn === 0 || fracOcean >= 0.6);

        // T27: Main rivers are reasonably long on average
        const rs3 = window.__state.riverStats || {avgMainLength:0};
        assert('Average main length is decent (>=60px)', rs3.avgMainLength >= 60 || rs2.majorsDrawn === 0);

        // T28: Lakes (if any) have a valid outlet or are endorheic
        document.getElementById('seaLevelInput').value = 0.35; st.recolor();
        const lakes = window.__state.lakes || [];
        let lakesOk = true;
        for (let i = 0; i < lakes.length; i++) {
          const L = lakes[i];
          if (!L) continue;
          if (L.outlet == null || L.outlet === -1) continue; // endorheic allowed
          if (!(L.outlet >= 0 && L.outlet < st.cells.length)) { lakesOk = false; break; }
        }
        assert('Lakes (if any) have outlet or are endorheic', lakesOk);

        // T29: Lake cells render as water (transparent polygon fill over ocean backdrop)
        let foundLakeCell = -1;
        if (window.__state.lakeId) {
          for (let i = 0; i < st.cells.length; i++) { if (st.cells[i].high >= 0.35 && window.__state.lakeId[i] >= 0) { foundLakeCell = i; break; } }
        }
        let lakeFillNone = true;
        if (foundLakeCell >= 0) {
          const el = document.getElementById(String(foundLakeCell));
          lakeFillNone = !!el && el.getAttribute('fill') === 'none';
        }
        assert('Lake polygons use no fill (water shows through)', foundLakeCell === -1 || lakeFillNone);

        // T30: Lake filtering reduces excessive small lakes
        const lakeArray = window.__state.lakes || [];
        const lakeCells = window.__state.isLake ? window.__state.isLake.reduce((sum, val) => sum + val, 0) : 0;
        const totalLandCells = st.cells.filter(c => c.high >= 0.35).length;
        const lakePercentage = totalLandCells > 0 ? (lakeCells / totalLandCells) : 0;
        assert('Lake filtering prevents excessive lake coverage', lakePercentage < 0.15); // Lakes should not cover more than 15% of land

        // T31: Biome system assigns valid biomes to land cells
        document.getElementById('renderMode').value = 'biomes'; st.recolor();
        const biomeLandCells = st.cells.filter(c => c.high >= 0.35);
        const validBiomes = ['Tundra', 'Boreal Forest', 'Temperate Forest', 'Grassland', 'Desert', 'Savanna', 'Tropical Rainforest'];
        const hasValidBiomes = biomeLandCells.every(c => c.biome && validBiomes.includes(c.biome));
        assert('All land cells have valid biome assignments', hasValidBiomes);

        // T32: Temperature decreases with elevation
        const highCells = st.cells.filter(c => c.high > 0.6).slice(0, 10);
        const lowCells = st.cells.filter(c => c.high > 0.35 && c.high < 0.45).slice(0, 10);
        const avgHighTemp = highCells.reduce((sum, c) => sum + c.temp, 0) / highCells.length;
        const avgLowTemp = lowCells.reduce((sum, c) => sum + c.temp, 0) / lowCells.length;
        assert('Temperature decreases with elevation', avgHighTemp < avgLowTemp);

        // T33: Erosion reduces jaggy ridges (thermal erosion test)
        document.getElementById('talusInput').value = 0.02;
        document.getElementById('thermalStrengthInput').value = 0.5;
        document.getElementById('smoothAlphaInput').value = 0.2;
        st.generate(); // Regenerate with erosion
        const erodedLandCells = st.cells.filter(c => c.high > 0.35);
        let maxHeightDiff = 0;
        erodedLandCells.forEach(c => {
          c.neighbors.forEach(nb => {
            const diff = Math.abs(c.high - st.cells[nb].high);
            maxHeightDiff = Math.max(maxHeightDiff, diff);
          });
        });
        assert('Erosion reduces extreme height differences', maxHeightDiff < 0.8); // Should be less than 0.8 after erosion

        // T34: Wind belt system creates latitudinal precipitation patterns
        document.getElementById('windBelts').value = 'hadley';
        document.getElementById('rainInput').value = 1.0;
        st.recolor();
        const precipArray = window.__state.precipArray || [];
        if (precipArray.length > 0) {
          // Check that different latitude bands have different precipitation patterns
          const northernCells = st.cells.filter(c => c.cy < 300).slice(0, 20); // Top portion
          const southernCells = st.cells.filter(c => c.cy > 500).slice(0, 20); // Bottom portion
          const northernPrecip = northernCells.reduce((sum, c) => sum + (precipArray[c.index] || 0), 0) / northernCells.length;
          const southernPrecip = southernCells.reduce((sum, c) => sum + (precipArray[c.index] || 0), 0) / southernCells.length;
          // Should have some variation due to wind belts
          assert('Wind belts create latitudinal precipitation variation', Math.abs(northernPrecip - southernPrecip) > 0.01);
        } else {
          assert('Wind belt precipitation computation works', true); // Fallback if no precip array
        }

        // T35: Shaded relief creates depth perception
        document.getElementById('shadingMode').value = 'shaded';
        st.recolor();
        const shadedCells = d3.selectAll('path.mapCell').filter(function() {
          const fill = this.getAttribute('fill');
          return fill && fill.startsWith('rgb('); // Shaded cells use rgb() format
        });
        assert('Shaded relief applies RGB shading to land cells', shadedCells.size() > 0);

        // T36: Export functions are available
        assert('SVG export function is available', typeof window.saveSVG === 'function');
        assert('PNG export function is available', typeof window.savePNG === 'function');
        
        // T37: Ocean background is properly set for export
        const svg = document.querySelector('svg');
        const oceanRect = svg.querySelector('rect.ocean');
        assert('Ocean background rect exists', !!oceanRect);
        assert('Ocean background has correct fill color', oceanRect.getAttribute('fill') === WATER_COLOR);
        
        // T38: Rivers are properly computed and rendered
        const riverGroups = svg.querySelectorAll('g.rivers, g.riversShade');
        const riverPaths = svg.querySelectorAll('g.rivers path, g.riversShade path');
        assert('River groups exist in SVG', riverGroups.length > 0);
        assert('River paths are rendered', riverPaths.length > 0);
        
        // T38.5: Coastlines are properly computed and rendered
        const coastlineGroups = svg.querySelectorAll('g.coastline');
        const coastlinePaths = svg.querySelectorAll('g.coastline path.coast');
        assert('Coastline groups exist in SVG', coastlineGroups.length > 0);
        assert('Coastline paths are rendered', coastlinePaths.length > 0);
        
        // T38.6: Burgs are properly computed and rendered
        const burgGroups = svg.querySelectorAll('#burgs');
        const burgs = svg.querySelectorAll('#burgs g.burg');
        assert('Burg groups exist in SVG', burgGroups.length > 0);
        assert('Burgs are rendered', burgs.length > 0);
        
        // T38.7: Burgs have proper styling
        if (burgs.length > 0) {
          const sampleBurg = burgs[0];
          const circle = sampleBurg.querySelector('circle');
          assert('Burgs have circle elements', !!circle);
          if (circle) {
            const hasFill = circle.hasAttribute('fill');
            const hasStroke = circle.hasAttribute('stroke');
            const hasStrokeWidth = circle.hasAttribute('stroke-width');
            assert('Burg circles have proper styling', hasFill && hasStroke && hasStrokeWidth);
          }
        }
        
        // T38.8: Routes are properly computed and rendered
        const routeGroups = svg.querySelectorAll('#routes');
        const roads = svg.querySelectorAll('#routes .roads path');
        const trails = svg.querySelectorAll('#routes .trails path');
        const seaRoutes = svg.querySelectorAll('#routes .searoutes path');
        assert('Route groups exist in SVG', routeGroups.length > 0);
        assert('Roads are rendered', roads.length > 0);
        assert('Trails are rendered', trails.length > 0);
        
        // T38.9: Routes have proper styling
        if (roads.length > 0) {
          const sampleRoad = roads[0];
          const hasStroke = sampleRoad.hasAttribute('stroke');
          const hasStrokeWidth = sampleRoad.hasAttribute('stroke-width');
          assert('Road paths have proper styling', hasStroke && hasStrokeWidth);
        }
        
        // Check that rivers have proper styling
        if (riverPaths.length > 0) {
          const samplePath = riverPaths[0];
          const hasStroke = samplePath.hasAttribute('stroke') || samplePath.style.stroke;
          const hasStrokeWidth = samplePath.hasAttribute('stroke-width') || samplePath.style.strokeWidth;
          assert('River paths have stroke attributes', hasStroke || hasStrokeWidth);
        }
        
        // Test ocean export preservation
        const clone = svg.cloneNode(true);
        const cloneOcean = clone.querySelector('rect.ocean');
        cloneOcean.setAttribute('fill', WATER_COLOR);
        cloneOcean.setAttribute('style', `fill: ${WATER_COLOR}`);
        inlineSvgStyles(clone, true);
        assert('Ocean fill is preserved during export styling', cloneOcean.getAttribute('fill') === WATER_COLOR);
        
        // Test river export preservation
        const exportRiverGroups = clone.querySelectorAll('g.rivers, g.riversShade');
        const exportRiverPaths = clone.querySelectorAll('g.rivers path, g.riversShade path');
        assert('River groups are present in export clone', exportRiverGroups.length > 0);
        assert('River paths are present in export clone', exportRiverPaths.length > 0);
        
        // Check that river styles are properly inlined
        if (exportRiverPaths.length > 0) {
          const samplePath = exportRiverPaths[0];
          const hasStroke = samplePath.hasAttribute('stroke') || samplePath.style.stroke;
          const hasStrokeWidth = samplePath.hasAttribute('stroke-width') || samplePath.style.strokeWidth;
          assert('River paths have stroke attributes inlined', hasStroke || hasStrokeWidth);
        }
        
        // T39: Coastlines are properly exported
        const exportCoastlineGroups = clone.querySelectorAll('g.coastline');
        const exportCoastlinePaths = clone.querySelectorAll('g.coastline path.coast');
        assert('Coastline groups are present in export clone', exportCoastlineGroups.length > 0);
        assert('Coastline paths are present in export clone', exportCoastlinePaths.length > 0);
        
        // Check that coastline styles are properly inlined
        if (exportCoastlinePaths.length > 0) {
          const samplePath = exportCoastlinePaths[0];
          const hasStroke = samplePath.hasAttribute('stroke') || samplePath.style.stroke;
          const hasStrokeWidth = samplePath.hasAttribute('stroke-width') || samplePath.style.strokeWidth;
          assert('Coastline paths have stroke attributes inlined', hasStroke || hasStrokeWidth);
        }
        
        // T40: Burgs are properly exported
        const exportBurgGroups = clone.querySelectorAll('#burgs');
        const exportBurgs = clone.querySelectorAll('#burgs g.burg');
        assert('Burg groups are present in export clone', exportBurgGroups.length > 0);
        assert('Burgs are present in export clone', exportBurgs.length > 0);
        
        // Check that burg styles are properly inlined
        if (exportBurgs.length > 0) {
          const sampleBurg = exportBurgs[0];
          const circle = sampleBurg.querySelector('circle');
          if (circle) {
            const hasFill = circle.hasAttribute('fill') || circle.style.fill;
            const hasStroke = circle.hasAttribute('stroke') || circle.style.stroke;
            const hasStrokeWidth = circle.hasAttribute('stroke-width') || circle.style.strokeWidth;
            assert('Burg circles have style attributes inlined', hasFill && hasStroke && hasStrokeWidth);
          }
        }
        
        // T41: Routes are properly exported
        const exportRouteGroups = clone.querySelectorAll('#routes');
        const exportRoads = clone.querySelectorAll('#routes .roads path');
        const exportTrails = clone.querySelectorAll('#routes .trails path');
        const exportSeaRoutes = clone.querySelectorAll('#routes .searoutes path');
        assert('Route groups are present in export clone', exportRouteGroups.length > 0);
        assert('Roads are present in export clone', exportRoads.length > 0);
        assert('Trails are present in export clone', exportTrails.length > 0);
        
        // Check that route styles are properly inlined
        if (exportRoads.length > 0) {
          const sampleRoad = exportRoads[0];
          const hasStroke = sampleRoad.hasAttribute('stroke') || sampleRoad.style.stroke;
          const hasStrokeWidth = sampleRoad.hasAttribute('stroke-width') || sampleRoad.style.strokeWidth;
          assert('Road paths have stroke attributes inlined', hasStroke && hasStrokeWidth);
        }

      } catch (e) {
        const li = document.createElement('li');
        li.textContent = '✗ Tests crashed: ' + (e && e.message ? e.message : e);
        li.className = 'fail';
        out.appendChild(li);
        console.error(e);
      }
    }

    // Modal and tab functionality
    window.toggleSettings = function() {
      const modal = document.getElementById('settingsModal');
      if (modal.style.display === 'block') {
        modal.style.display = 'none';
      } else {
        modal.style.display = 'block';
      }
    }

    window.showTab = function(tabName) {
      // Hide all tab contents
      const tabContents = document.querySelectorAll('.tab-content');
      tabContents.forEach(content => {
        content.classList.remove('active');
      });

      // Remove active class from all tab buttons
      const tabButtons = document.querySelectorAll('.tab-btn');
      tabButtons.forEach(btn => {
        btn.classList.remove('active');
      });

      // Show selected tab content
      const selectedTab = document.getElementById(tabName + '-tab');
      if (selectedTab) {
        selectedTab.classList.add('active');
      }

      // Add active class to selected tab button
      const selectedButton = document.querySelector(`[onclick="showTab('${tabName}')"]`);
      if (selectedButton) {
        selectedButton.classList.add('active');
      }
    }

    // Close modal when clicking outside of it
    window.onclick = function(event) {
      const modal = document.getElementById('settingsModal');
      if (event.target === modal) {
        modal.style.display = 'none';
      }
    }

    // Close modal with Escape key
    document.addEventListener('keydown', function(event) {
      if (event.key === 'Escape') {
        const modal = document.getElementById('settingsModal');
        if (modal.style.display === 'block') {
          modal.style.display = 'none';
        }
      }
    });
  })();
  </script>
</body>
</html>
